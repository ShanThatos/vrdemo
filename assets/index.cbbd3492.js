var Xa=Object.defineProperty,Za=Object.defineProperties;var Ka=Object.getOwnPropertyDescriptors;var cs=Object.getOwnPropertySymbols;var Zi=Object.prototype.hasOwnProperty,Ki=Object.prototype.propertyIsEnumerable;var Qs=(i,t,e)=>t in i?Xa(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,k=(i,t)=>{for(var e in t||(t={}))Zi.call(t,e)&&Qs(i,e,t[e]);if(cs)for(var e of cs(t))Ki.call(t,e)&&Qs(i,e,t[e]);return i},j=(i,t)=>Za(i,Ka(t));var In=(i,t)=>{var e={};for(var n in i)Zi.call(i,n)&&t.indexOf(n)<0&&(e[n]=i[n]);if(i!=null&&cs)for(var n of cs(i))t.indexOf(n)<0&&Ki.call(i,n)&&(e[n]=i[n]);return e};var E=(i,t,e)=>(Qs(i,typeof t!="symbol"?t+"":t,e),e);const Ja=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerpolicy&&(r.referrerPolicy=s.referrerpolicy),s.crossorigin==="use-credentials"?r.credentials="include":s.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(s){if(s.ep)return;s.ep=!0;const r=e(s);fetch(s.href,r)}};Ja();const $e=1e-5,kt=class{constructor(t){E(this,"values",new Float32Array(3));t!==void 0&&(this.xyz=t)}set x(t){this.values[0]=t}get x(){return this.values[0]}set y(t){this.values[1]=t}get y(){return this.values[1]}set z(t){this.values[2]=t}get z(){return this.values[2]}set xy(t){this.values[0]=t[0],this.values[1]=t[1]}get xy(){return[this.values[0],this.values[1]]}set xyz(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2]}get xyz(){return[this.values[0],this.values[1],this.values[2]]}static cross(t,e,n){n||(n=new kt);const s=t.x,r=t.y,a=t.z,o=e.x,c=e.y,l=e.z;return n.x=r*l-a*c,n.y=a*o-s*l,n.z=s*c-r*o,n}static dot(t,e){const n=t.x,s=t.y,r=t.z,a=e.x,o=e.y,c=e.z;return n*a+s*o+r*c}static distance(t,e){return Math.sqrt(this.squaredDistance(t,e))}static squaredDistance(t,e){const n=e.x-t.x,s=e.y-t.y,r=e.z-t.z;return n*n+s*s+r*r}static direction(t,e,n){n||(n=new kt);const s=t.x-e.x,r=t.y-e.y,a=t.z-e.z;let o=Math.sqrt(s*s+r*r+a*a);return o===0?(n.x=0,n.y=0,n.z=0,n):(o=1/o,n.x=s*o,n.y=r*o,n.z=a*o,n)}static lerp(t,e,n,s){return s||(s=new kt),s.x=t.x+n*(e.x-t.x),s.y=t.y+n*(e.y-t.y),s.z=t.z+n*(e.z-t.z),s}static sum(t,e,n){return n||(n=new kt),n.x=t.x+e.x,n.y=t.y+e.y,n.z=t.z+e.z,n}static difference(t,e,n){return n||(n=new kt),n.x=t.x-e.x,n.y=t.y-e.y,n.z=t.z-e.z,n}static product(t,e,n){return n||(n=new kt),n.x=t.x*e.x,n.y=t.y*e.y,n.z=t.z*e.z,n}static quotient(t,e,n){return n||(n=new kt),n.x=t.x/e.x,n.y=t.y/e.y,n.z=t.z/e.z,n}at(t){return this.values[t]}reset(){this.x=0,this.y=0,this.z=0}copy(t){return t||(t=new kt),t.x=this.x,t.y=this.y,t.z=this.z,t}negate(t){return t||(t=this),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}equals(t,e=$e){return!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}length(){return Math.sqrt(this.squaredLength())}squaredLength(){const t=this.x,e=this.y,n=this.z;return t*t+e*e+n*n}add(t,e){return e||(e=this),e.x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e}subtract(t,e){return e||(e=this),e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e}multiply(t,e){return e||(e=this),e.x=this.x*t.x,e.y=this.y*t.y,e.z=this.z*t.z,e}divide(t,e){return e||(e=this),e.x=this.x/t.x,e.y=this.y/t.y,e.z=this.z/t.z,e}scale(t,e){return e||(e=this),e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}normalize(t){t||(t=this);let e=this.length();return e===1?(t.xyz=this.xyz,t):e===0?(t.x=0,t.y=0,t.z=0,t):(e=1/e,t.x=this.x*e,t.y=this.y*e,t.z=this.z*e,t)}multiplyMat3(t,e){return e||(e=this),t.multiplyVec3(this,e)}multiplyByQuat(t,e){return e||(e=this),t.multiplyVec3(this,e)}};let x=kt;E(x,"zero",new kt([0,0,0])),E(x,"one",new kt([1,1,1])),E(x,"up",new kt([0,1,0])),E(x,"right",new kt([1,0,0])),E(x,"forward",new kt([0,0,1]));const $t=class{constructor(t){E(this,"values",new Float32Array(2));t!==void 0&&(this.xy=t)}get x(){return this.values[0]}get y(){return this.values[1]}get xy(){return[this.values[0],this.values[1]]}set x(t){this.values[0]=t}set y(t){this.values[1]=t}set xy(t){this.values[0]=t[0],this.values[1]=t[1]}static cross(t,e,n){n||(n=new x);const s=t.x,r=t.y,a=e.x,o=e.y,c=s*o-r*a;return n.x=0,n.y=0,n.z=c,n}static dot(t,e){return t.x*e.x+t.y*e.y}static distance(t,e){return Math.sqrt(this.squaredDistance(t,e))}static squaredDistance(t,e){const n=e.x-t.x,s=e.y-t.y;return n*n+s*s}static direction(t,e,n){n||(n=new $t);const s=t.x-e.x,r=t.y-e.y;let a=Math.sqrt(s*s+r*r);return a===0?(n.x=0,n.y=0,n):(a=1/a,n.x=s*a,n.y=r*a,n)}static lerp(t,e,n,s){s||(s=new $t);const r=t.x,a=t.y,o=e.x,c=e.y;return s.x=r+n*(o-r),s.y=a+n*(c-a),s}static sum(t,e,n){return n||(n=new $t),n.x=t.x+e.x,n.y=t.y+e.y,n}static difference(t,e,n){return n||(n=new $t),n.x=t.x-e.x,n.y=t.y-e.y,n}static product(t,e,n){return n||(n=new $t),n.x=t.x*e.x,n.y=t.y*e.y,n}static quotient(t,e,n){return n||(n=new $t),n.x=t.x/e.x,n.y=t.y/e.y,n}at(t){return this.values[t]}reset(){this.x=0,this.y=0}copy(t){return t||(t=new $t),t.x=this.x,t.y=this.y,t}negate(t){return t||(t=this),t.x=-this.x,t.y=-this.y,t}equals(t,e=$e){return!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e)}length(){return Math.sqrt(this.squaredLength())}squaredLength(){const t=this.x,e=this.y;return t*t+e*e}add(t,e){return e||(e=this),e.x=this.x+t.x,e.y=this.y+t.y,e}subtract(t,e){return e||(e=this),e.x=this.x-t.x,e.y=this.y-t.y,e}multiply(t,e){return e||(e=this),e.x=this.x*t.x,e.y=this.y*t.y,e}divide(t,e){return e||(e=this),e.x=this.x/t.x,e.y=this.y/t.y,e}scale(t,e){return e||(e=this),e.x=this.x*t,e.y=this.y*t,e}normalize(t){t||(t=this);let e=this.length();return e===1?(t.xy=this.xy,t):e===0?(t.x=0,t.y=0,t):(e=1/e,t.x=this.x*e,t.y=this.y*e,t)}multiplyMat2(t,e){return e||(e=this),t.multiplyVec2(this,e)}multiplyMat3(t,e){return e||(e=this),t.multiplyVec2(this,e)}};let sn=$t;E(sn,"zero",new $t([0,0])),E(sn,"one",new $t([1,1]));const Dn=class{constructor(t){E(this,"values",new Float32Array(4));t!==void 0&&this.init(t)}static product(t,e,n){n||(n=new Dn);const s=t.at(0),r=t.at(2),a=t.at(1),o=t.at(3);return n.init([s*e.at(0)+r*e.at(1),a*e.at(0)+o*e.at(1),s*e.at(2)+r*e.at(3),a*e.at(2)+o*e.at(3)]),n}at(t){return this.values[t]}init(t){for(let e=0;e<4;e++)this.values[e]=t[e];return this}reset(){for(let t=0;t<4;t++)this.values[t]=0}copy(t){t||(t=new Dn);for(let e=0;e<4;e++)t.values[e]=this.values[e];return t}all(){const t=[];for(let e=0;e<4;e++)t[e]=this.values[e];return t}row(t){return[this.values[t],this.values[t+2]]}col(t){return[this.values[t*2+0],this.values[t*2+1]]}equals(t,e=$e){for(let n=0;n<4;n++)if(Math.abs(this.values[n]-t.at(n))>e)return!1;return!0}determinant(){return this.values[0]*this.values[3]-this.values[2]*this.values[1]}setIdentity(){return this.values[0]=1,this.values[1]=0,this.values[2]=0,this.values[3]=1,this}transpose(t){t||(t=this);const e=this.values[1];return t.values[1]=this.values[2],t.values[2]=e,t.values[0]=this.values[0],t.values[3]=this.values[3],t}inverse(t){t||(t=this);const e=1/this.determinant(),n=this.values[0];return t.values[0]=e*this.values[3],t.values[1]=e*-this.values[1],t.values[2]=e*-this.values[2],t.values[3]=e*n,t}multiply(t,e){e||(e=this);const n=this.values[0],s=this.values[2],r=this.values[1],a=this.values[3];return e.values[0]=n*t.at(0)+s*t.at(1),e.values[1]=r*t.at(0)+a*t.at(1),e.values[2]=n*t.at(2)+s*t.at(3),e.values[3]=r*t.at(2)+a*t.at(3),e}multiplyVec2(t,e){e||(e=new sn);const n=t.x,s=t.y;return e.xy=[n*this.values[0]+s*this.values[2],n*this.values[1]+s*this.values[3]],e}rotate(t,e){e||(e=this);const n=this.values[0],s=this.values[2],r=this.values[1],a=this.values[3],o=Math.sin(t),c=Math.cos(t);return e.values[0]=n*c+s*o,e.values[1]=r*c+a*o,e.values[2]=n*-o+s*c,e.values[3]=r*-o+a*c,e}scale(t,e){e||(e=this);const n=this.values[0],s=this.values[1],r=this.values[2],a=this.values[3],o=t.x,c=t.y;return e.values[0]=n*o,e.values[1]=s*o,e.values[2]=r*c,e.values[3]=a*c,e}};let ti=Dn;E(ti,"identity",new Dn().setIdentity());const ae=class{constructor(t){E(this,"values",new Float32Array(4));t!==void 0&&(this.xyzw=t)}get x(){return this.values[0]}get y(){return this.values[1]}get z(){return this.values[2]}get w(){return this.values[3]}get xy(){return[this.values[0],this.values[1]]}get xyz(){return[this.values[0],this.values[1],this.values[2]]}get xyzw(){return[this.values[0],this.values[1],this.values[2],this.values[3]]}set x(t){this.values[0]=t}set y(t){this.values[1]=t}set z(t){this.values[2]=t}set w(t){this.values[3]=t}set xy(t){this.values[0]=t[0],this.values[1]=t[1]}set xyz(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2]}set xyzw(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3]}get r(){return this.values[0]}get g(){return this.values[1]}get b(){return this.values[2]}get a(){return this.values[3]}get rg(){return[this.values[0],this.values[1]]}get rgb(){return[this.values[0],this.values[1],this.values[2]]}get rgba(){return[this.values[0],this.values[1],this.values[2],this.values[3]]}set r(t){this.values[0]=t}set g(t){this.values[1]=t}set b(t){this.values[2]=t}set a(t){this.values[3]=t}set rg(t){this.values[0]=t[0],this.values[1]=t[1]}set rgb(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2]}set rgba(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3]}static mix(t,e,n,s){return s||(s=new ae),s.x=t.x+n*(e.x-t.x),s.y=t.y+n*(e.y-t.y),s.z=t.z+n*(e.z-t.z),s.w=t.w+n*(e.w-t.w),s}static sum(t,e,n){return n||(n=new ae),n.x=t.x+e.x,n.y=t.y+e.y,n.z=t.z+e.z,n.w=t.w+e.w,n}static difference(t,e,n){return n||(n=new ae),n.x=t.x-e.x,n.y=t.y-e.y,n.z=t.z-e.z,n.w=t.w-e.w,n}static product(t,e,n){return n||(n=new ae),n.x=t.x*e.x,n.y=t.y*e.y,n.z=t.z*e.z,n.w=t.w*e.w,n}static quotient(t,e,n){return n||(n=new ae),n.x=t.x/e.x,n.y=t.y/e.y,n.z=t.z/e.z,n.w=t.w/e.w,n}at(t){return this.values[t]}reset(){this.x=0,this.y=0,this.z=0,this.w=0}copy(t){return t||(t=new ae),t.x=this.x,t.y=this.y,t.z=this.z,t.w=this.w,t}negate(t){return t||(t=this),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=-this.w,t}equals(t,e=$e){return!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e||Math.abs(this.w-t.w)>e)}length(){return Math.sqrt(this.squaredLength())}squaredLength(){const t=this.x,e=this.y,n=this.z,s=this.w;return t*t+e*e+n*n+s*s}add(t,e){return e||(e=this),e.x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e.w=this.w+t.w,e}subtract(t,e){return e||(e=this),e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e.w=this.w-t.w,e}multiply(t,e){return e||(e=this),e.x=this.x*t.x,e.y=this.y*t.y,e.z=this.z*t.z,e.w=this.w*t.w,e}divide(t,e){return e||(e=this),e.x=this.x/t.x,e.y=this.y/t.y,e.z=this.z/t.z,e.w=this.w/t.w,e}scale(t,e){return e||(e=this),e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e.w=this.w*t,e}normalize(t){t||(t=this);let e=this.length();return e===1?(t.xyzw=this.xyzw,t):e===0?(t.x=0,t.y=0,t.z=0,t.w=0,t):(e=1/e,t.x=this.x*e,t.y=this.y*e,t.z=this.z*e,t.w=this.w*e,t)}multiplyMat4(t,e){return e||(e=this),t.multiplyVec4(this,e)}};let Ne=ae;E(Ne,"zero",new ae([0,0,0,1])),E(Ne,"one",new ae([1,1,1,1]));const oe=class{constructor(t){E(this,"values",new Float32Array(16));t!==void 0&&this.init(t)}static frustum(t,e,n,s,r,a,o){o||(o=new oe);const c=e-t,l=s-n,u=a-r;return o.init([r*2/c,0,0,0,0,r*2/l,0,0,(e+t)/c,(s+n)/l,-(a+r)/u,-1,0,0,-(a*r*2)/u,0])}static perspective(t,e,n,s,r){r||(r=new oe);const a=n*Math.tan(t*Math.PI/360),o=a*e;return oe.frustum(-o,o,-a,a,n,s,r)}static orthographic(t,e,n,s,r,a,o){o||(o=new oe);const c=e-t,l=s-n,u=a-r;return o.init([2/c,0,0,0,0,2/l,0,0,0,0,-2/u,0,-(t+e)/c,-(s+n)/l,-(a+r)/u,1])}static lookAt(t,e,n=x.up,s){if(s||(s=new oe),t.equals(e))return s.setIdentity();const r=x.difference(t,e).normalize(),a=x.cross(n,r).normalize(),o=x.cross(r,a).normalize();return s.init([a.x,o.x,r.x,0,a.y,o.y,r.y,0,a.z,o.z,r.z,0,-x.dot(a,t),-x.dot(o,t),-x.dot(r,t),1])}static product(t,e,n){n||(n=new oe);const s=t.at(0),r=t.at(4),a=t.at(8),o=t.at(12),c=t.at(1),l=t.at(5),u=t.at(9),h=t.at(13),d=t.at(2),f=t.at(6),p=t.at(10),g=t.at(14),m=t.at(3),_=t.at(7),v=t.at(11),S=t.at(15),A=e.at(0),w=e.at(4),b=e.at(8),y=e.at(12),T=e.at(1),O=e.at(5),D=e.at(9),M=e.at(13),C=e.at(2),P=e.at(6),N=e.at(10),V=e.at(14),F=e.at(3),U=e.at(7),G=e.at(11),q=e.at(15);return n.init([s*A+r*T+a*C+o*F,c*A+l*T+u*C+h*F,d*A+f*T+p*C+g*F,m*A+_*T+v*C+S*F,s*w+r*O+a*P+o*U,c*w+l*O+u*P+h*U,d*w+f*O+p*P+g*U,m*w+_*O+v*P+S*U,s*b+r*D+a*N+o*G,c*b+l*D+u*N+h*G,d*b+f*D+p*N+g*G,m*b+_*D+v*N+S*G,s*y+r*M+a*V+o*q,c*y+l*M+u*V+h*q,d*y+f*M+p*V+g*q,m*y+_*M+v*V+S*q]),n}at(t){return this.values[t]}init(t){for(let e=0;e<16;e++)this.values[e]=t[e];return this}reset(){for(let t=0;t<16;t++)this.values[t]=0}copy(t){t||(t=new oe);for(let e=0;e<16;e++)t.values[e]=this.values[e];return t}all(){const t=[];for(let e=0;e<16;e++)t[e]=this.values[e];return t}row(t){return[this.values[t],this.values[t+4],this.values[t+8],this.values[t+12]]}col(t){return[this.values[t*4+0],this.values[t*4+1],this.values[t*4+2],this.values[t*4+3]]}equals(t,e=$e){for(let n=0;n<16;n++)if(Math.abs(this.values[n]-t.at(n))>e)return!1;return!0}determinant(){const t=this.values[0],e=this.values[1],n=this.values[2],s=this.values[3],r=this.values[4],a=this.values[5],o=this.values[6],c=this.values[7],l=this.values[8],u=this.values[9],h=this.values[10],d=this.values[11],f=this.values[12],p=this.values[13],g=this.values[14],m=this.values[15],_=t*a-r*e,v=t*u-l*e,S=t*p-f*e,A=r*u-l*a,w=r*p-f*a,b=l*p-f*u,y=n*c-o*s,T=n*d-h*s,O=n*m-g*s,D=o*d-h*c,M=o*m-g*c,C=h*m-g*d;return _*C-v*M+S*D+A*O-w*T+b*y}setIdentity(){return this.values[0]=1,this.values[1]=0,this.values[2]=0,this.values[3]=0,this.values[4]=0,this.values[5]=1,this.values[6]=0,this.values[7]=0,this.values[8]=0,this.values[9]=0,this.values[10]=1,this.values[11]=0,this.values[12]=0,this.values[13]=0,this.values[14]=0,this.values[15]=1,this}transpose(t){t||(t=this);const e=this.values[1],n=this.values[2],s=this.values[3],r=this.values[6],a=this.values[7],o=this.values[11];return t.values[0]=this.values[0],t.values[1]=this.values[4],t.values[2]=this.values[8],t.values[3]=this.values[12],t.values[4]=e,t.values[5]=this.values[5],t.values[6]=this.values[9],t.values[7]=this.values[13],t.values[8]=n,t.values[9]=r,t.values[10]=this.values[10],t.values[11]=this.values[14],t.values[12]=s,t.values[13]=a,t.values[14]=o,t.values[15]=this.values[15],t}inverse(t){t||(t=this);const e=this.values[0],n=this.values[1],s=this.values[2],r=this.values[3],a=this.values[4],o=this.values[5],c=this.values[6],l=this.values[7],u=this.values[8],h=this.values[9],d=this.values[10],f=this.values[11],p=this.values[12],g=this.values[13],m=this.values[14],_=this.values[15],v=e*o-a*n,S=e*h-u*n,A=e*g-p*n,w=a*h-u*o,b=a*g-p*o,y=u*g-p*h,T=s*l-c*r,O=s*f-d*r,D=s*_-m*r,M=c*f-d*l,C=c*_-m*l,P=d*_-m*f,N=1/(v*P-S*C+A*M+w*D-b*O+y*T);return t.values[0]=(o*P-h*C+g*M)*N,t.values[4]=(-a*P+u*C-p*M)*N,t.values[8]=(l*y-f*b+_*w)*N,t.values[12]=(-c*y+d*b-m*w)*N,t.values[1]=(-n*P+h*D-g*O)*N,t.values[5]=(e*P-u*D+p*O)*N,t.values[9]=(-r*y+f*A-_*S)*N,t.values[13]=(s*y-d*A+m*S)*N,t.values[2]=(n*C-o*D+g*T)*N,t.values[6]=(-e*C+a*D-p*T)*N,t.values[10]=(r*b-l*A+_*v)*N,t.values[14]=(-s*b+c*A-m*v)*N,t.values[3]=(-n*M+o*O-h*T)*N,t.values[7]=(e*M-a*O+u*T)*N,t.values[11]=(-r*w+l*S-f*v)*N,t.values[15]=(s*w-c*S+d*v)*N,t}multiply(t,e){e||(e=this);const n=this.values[0],s=this.values[1],r=this.values[2],a=this.values[3],o=this.values[4],c=this.values[5],l=this.values[6],u=this.values[7],h=this.values[8],d=this.values[9],f=this.values[10],p=this.values[11],g=this.values[12],m=this.values[13],_=this.values[14],v=this.values[15],S=t.values[0],A=t.values[1],w=t.values[2],b=t.values[3],y=t.values[4],T=t.values[5],O=t.values[6],D=t.values[7],M=t.values[8],C=t.values[9],P=t.values[10],N=t.values[11],V=t.values[12],F=t.values[13],U=t.values[14],G=t.values[15];return e.values[0]=n*S+o*A+h*w+g*b,e.values[1]=s*S+c*A+d*w+m*b,e.values[2]=r*S+l*A+f*w+_*b,e.values[3]=a*S+u*A+p*w+v*b,e.values[4]=n*y+o*T+h*O+g*D,e.values[5]=s*y+c*T+d*O+m*D,e.values[6]=r*y+l*T+f*O+_*D,e.values[7]=a*y+u*T+p*O+v*D,e.values[8]=n*M+o*C+h*P+g*N,e.values[9]=s*M+c*C+d*P+m*N,e.values[10]=r*M+l*C+f*P+_*N,e.values[11]=a*M+u*C+p*P+v*N,e.values[12]=n*V+o*F+h*U+g*G,e.values[13]=s*V+c*F+d*U+m*G,e.values[14]=r*V+l*F+f*U+_*G,e.values[15]=a*V+u*F+p*U+v*G,e}multiplyVec3(t,e){e||(e=new x);const n=t.x,s=t.y,r=t.z;return e.xyz=[this.values[0]*n+this.values[4]*s+this.values[8]*r,this.values[1]*n+this.values[5]*s+this.values[9]*r,this.values[2]*n+this.values[6]*s+this.values[10]*r],e}multiplyPt3(t,e){e||(e=new x);const n=t.x,s=t.y,r=t.z;return e.xyz=[this.values[0]*n+this.values[4]*s+this.values[8]*r+this.values[12],this.values[1]*n+this.values[5]*s+this.values[9]*r+this.values[13],this.values[2]*n+this.values[6]*s+this.values[10]*r+this.values[14]],e}multiplyVec4(t,e){e||(e=new Ne);const n=t.x,s=t.y,r=t.z,a=t.w;return e.xyzw=[this.values[0]*n+this.values[4]*s+this.values[8]*r+this.values[12]*a,this.values[1]*n+this.values[5]*s+this.values[9]*r+this.values[13]*a,this.values[2]*n+this.values[6]*s+this.values[10]*r+this.values[14]*a,this.values[3]*n+this.values[7]*s+this.values[11]*r+this.values[15]*a],e}toMat3(t){return t||(t=new cn),t.init([this.values[0],this.values[1],this.values[2],this.values[4],this.values[5],this.values[6],this.values[8],this.values[9],this.values[10]])}toInverseMat3(t){t||(t=new cn);const e=this.values[0],n=this.values[1],s=this.values[2],r=this.values[4],a=this.values[5],o=this.values[6],c=this.values[8],l=this.values[9],u=this.values[10],h=u*a-l*o,d=-u*n+l*s,f=o*n-a*s,p=1/(e*h+r*d+c*f);return t.init([h*p,d*p,f*p,(-u*r+c*o)*p,(u*e-c*s)*p,(-o*e+r*s)*p,(l*r-c*a)*p,(-l*e+c*n)*p,(a*e-r*n)*p])}translate(t,e){e||(e=this);const n=t.x,s=t.y,r=t.z;return e.values[0]=this.values[0],e.values[1]=this.values[1],e.values[2]=this.values[2],e.values[3]=this.values[3],e.values[4]=this.values[4],e.values[5]=this.values[5],e.values[6]=this.values[6],e.values[7]=this.values[7],e.values[8]=this.values[8],e.values[9]=this.values[9],e.values[10]=this.values[10],e.values[11]=this.values[11],e.values[12]=this.values[0]*n+this.values[4]*s+this.values[8]*r+this.values[12],e.values[13]=this.values[1]*n+this.values[5]*s+this.values[9]*r+this.values[13],e.values[14]=this.values[2]*n+this.values[6]*s+this.values[10]*r+this.values[14],e.values[15]=this.values[3]*n+this.values[7]*s+this.values[11]*r+this.values[15],e}scale(t,e){e||(e=this);const n=t.x,s=t.y,r=t.z;return e.values[0]=this.values[0]*n,e.values[1]=this.values[1]*n,e.values[2]=this.values[2]*n,e.values[3]=this.values[3]*n,e.values[4]=this.values[4]*s,e.values[5]=this.values[5]*s,e.values[6]=this.values[6]*s,e.values[7]=this.values[7]*s,e.values[8]=this.values[8]*r,e.values[9]=this.values[9]*r,e.values[10]=this.values[10]*r,e.values[11]=this.values[11]*r,e.values[12]=this.values[12],e.values[13]=this.values[13],e.values[14]=this.values[14],e.values[15]=this.values[15],e}rotate(t,e,n){n||(n=this);let s=e.x,r=e.y,a=e.z,o=Math.sqrt(s*s+r*r+a*a);o!==1&&(o=1/o,s*=o,r*=o,a*=o);const c=Math.sin(t),l=Math.cos(t),u=1-l,h=this.values[0],d=this.values[1],f=this.values[2],p=this.values[3],g=this.values[4],m=this.values[5],_=this.values[6],v=this.values[7],S=this.values[8],A=this.values[9],w=this.values[10],b=this.values[11],y=s*s*u+l,T=r*s*u+a*c,O=a*s*u-r*c,D=s*r*u-a*c,M=r*r*u+l,C=a*r*u+s*c,P=s*a*u+r*c,N=r*a*u-s*c,V=a*a*u+l;return n.values[0]=h*y+g*T+S*O,n.values[1]=d*y+m*T+A*O,n.values[2]=f*y+_*T+w*O,n.values[3]=p*y+v*T+b*O,n.values[4]=h*D+g*M+S*C,n.values[5]=d*D+m*M+A*C,n.values[6]=f*D+_*M+w*C,n.values[7]=p*D+v*M+b*C,n.values[8]=h*P+g*N+S*V,n.values[9]=d*P+m*N+A*V,n.values[10]=f*P+_*N+w*V,n.values[11]=p*P+v*N+b*V,n.values[12]=this.values[12],n.values[13]=this.values[13],n.values[14]=this.values[14],n.values[15]=this.values[15],n}};let lt=oe;E(lt,"identity",new oe().setIdentity());const Xt=class{constructor(t){E(this,"values",new Float32Array(4));t!==void 0&&(this.xyzw=t)}get x(){return this.values[0]}get y(){return this.values[1]}get z(){return this.values[2]}get w(){return this.values[3]}get xy(){return[this.values[0],this.values[1]]}get xyz(){return[this.values[0],this.values[1],this.values[2]]}get xyzw(){return[this.values[0],this.values[1],this.values[2],this.values[3]]}set x(t){this.values[0]=t}set y(t){this.values[1]=t}set z(t){this.values[2]=t}set w(t){this.values[3]=t}set xy(t){this.values[0]=t[0],this.values[1]=t[1]}set xyz(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2]}set xyzw(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3]}static dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z+t.w*e.w}static sum(t,e,n){return n||(n=new Xt),n.x=t.x+e.x,n.y=t.y+e.y,n.z=t.z+e.z,n.w=t.w+e.w,n}static product(t,e,n){n||(n=new Xt);const s=t.x,r=t.y,a=t.z,o=t.w,c=e.x,l=e.y,u=e.z,h=e.w;return n.x=s*h+o*c+r*u-a*l,n.y=r*h+o*l+a*c-s*u,n.z=a*h+o*u+s*l-r*c,n.w=o*h-s*c-r*l-a*u,n}static slerp(t,e,n,s){s||(s=new Xt);const r=t.x*e.x+t.y*e.y+t.z*e.z+t.w*e.w;if(Math.abs(r)>=1)return s.xyzw=t.xyzw,s;const a=Math.acos(r),o=Math.sqrt(1-r*r);if(Math.abs(o)<.001)return s.x=t.x*.5+e.x*.5,s.y=t.y*.5+e.y*.5,s.z=t.z*.5+e.z*.5,s.w=t.w*.5+e.w*.5,s;const c=Math.sin((1-n)*a)/o,l=Math.sin(n*a)/o;return s.x=t.x*c+e.x*l,s.y=t.y*c+e.y*l,s.z=t.z*c+e.z*l,s.w=t.w*c+e.w*l,s}static slerpShort(t,e,n,s){if(s||(s=new Xt),n<=0)return s.xyzw=t.xyzw,s;if(n>=1)return s.xyzw=e.xyzw,s;let r=Xt.dot(t,e);const a=e.copy();r<0&&(a.x=-a.x,a.y=-a.y,a.z=-a.z,a.w=-a.w,r=-r);let o,c;if(r>.9999)o=1-n,c=0+n;else{const l=Math.sqrt(1-r*r),u=Math.atan2(l,r),h=1/l;o=Math.sin((1-n)*u)*h,c=Math.sin((0+n)*u)*h}return s.x=o*t.x+c*a.x,s.y=o*t.y+c*a.y,s.z=o*t.z+c*a.z,s.w=o*t.w+c*a.w,s}static fromAxisAngle(t,e,n){n||(n=new Xt),e*=.5;const s=Math.sin(e);return n.x=t.x*s,n.y=t.y*s,n.z=t.z*s,n.w=Math.cos(e),n}at(t){return this.values[t]}reset(){for(let t=0;t<4;t++)this.values[t]=0}copy(t){t||(t=new Xt);for(let e=0;e<4;e++)t.values[e]=this.values[e];return t}equals(t,e=$e){for(let n=0;n<4;n++)if(Math.abs(this.values[n]-t.at(n))>e)return!1;return!0}setIdentity(){return this.x=0,this.y=0,this.z=0,this.w=1,this}calculateW(){const t=this.x,e=this.y,n=this.z;return this.w=Math.sqrt(Math.abs(1-t*t-e*e-n*n)),this}inverse(t){t||(t=this);const e=Xt.dot(this,this);if(!e)return t.xyzw=[0,0,0,0],t;const n=e?1/e:0;return t.x=this.x*-n,t.y=this.y*-n,t.z=this.z*-n,t.w=this.w*n,t}conjugate(t){return t||(t=this),t.values[0]=this.values[0]*-1,t.values[1]=this.values[1]*-1,t.values[2]=this.values[2]*-1,t.values[3]=this.values[3],t}length(){const t=this.x,e=this.y,n=this.z,s=this.w;return Math.sqrt(t*t+e*e+n*n+s*s)}normalize(t){t||(t=this);const e=this.x,n=this.y,s=this.z,r=this.w;let a=Math.sqrt(e*e+n*n+s*s+r*r);return a?(a=1/a,t.x=e*a,t.y=n*a,t.z=s*a,t.w=r*a,t):(t.x=0,t.y=0,t.z=0,t.w=0,t)}add(t,e){e||(e=this);for(let n=0;n<4;n++)e.values[n]=this.values[n]+t.at(n);return e}multiply(t,e){e||(e=this);const n=this.values[0],s=this.values[1],r=this.values[2],a=this.values[3],o=t.x,c=t.y,l=t.z,u=t.w;return e.x=n*u+a*o+s*l-r*c,e.y=s*u+a*c+r*o-n*l,e.z=r*u+a*l+n*c-s*o,e.w=a*u-n*o-s*c-r*l,e}multiplyVec3(t,e){e||(e=new x);const n=t.x,s=t.y,r=t.z,a=this.x,o=this.y,c=this.z,l=this.w,u=l*n+o*r-c*s,h=l*s+c*n-a*r,d=l*r+a*s-o*n,f=-a*n-o*s-c*r;return e.x=u*l+f*-a+h*-c-d*-o,e.y=h*l+f*-o+d*-a-u*-c,e.z=d*l+f*-c+u*-o-h*-a,e}toMat3(t){t||(t=new cn);const e=this.x,n=this.y,s=this.z,r=this.w,a=e+e,o=n+n,c=s+s,l=e*a,u=e*o,h=e*c,d=n*o,f=n*c,p=s*c,g=r*a,m=r*o,_=r*c;return t.init([1-(d+p),u+_,h-m,u-_,1-(l+p),f+g,h+m,f-g,1-(l+d)]),t}toMat4(t){t||(t=new lt);const e=this.x,n=this.y,s=this.z,r=this.w,a=e+e,o=n+n,c=s+s,l=e*a,u=e*o,h=e*c,d=n*o,f=n*c,p=s*c,g=r*a,m=r*o,_=r*c;return t.init([1-(d+p),u+_,h-m,0,u-_,1-(l+p),f+g,0,h+m,f-g,1-(l+d),0,0,0,0,1]),t}};let ce=Xt;E(ce,"identity",new Xt().setIdentity());const Rn=class{constructor(t){E(this,"values",new Float32Array(9));t!==void 0&&this.init(t)}static product(t,e,n){n||(n=new Rn);const s=t.values[0],r=t.values[3],a=t.values[6],o=t.values[1],c=t.values[4],l=t.values[7],u=t.values[2],h=t.values[5],d=t.values[8],f=e.values[0],p=e.values[3],g=e.values[6],m=e.values[1],_=e.values[4],v=e.values[7],S=e.values[2],A=e.values[5],w=e.values[8];return n.init([s*f+r*m+a*S,o*f+c*m+l*S,u*f+h*m+d*S,s*p+r*_+a*A,o*p+c*_+l*A,u*p+h*_+d*A,s*g+r*v+a*w,o*g+c*v+l*w,u*g+h*v+d*w]),n}at(t){return this.values[t]}init(t){for(let e=0;e<9;e++)this.values[e]=t[e];return this}reset(){for(let t=0;t<9;t++)this.values[t]=0}copy(t){t||(t=new Rn);for(let e=0;e<9;e++)t.values[e]=this.values[e];return t}all(){const t=[];for(let e=0;e<9;e++)t[e]=this.values[e];return t}row(t){return[this.values[t],this.values[t+3],this.values[t+6]]}col(t){return[this.values[t*3],this.values[t*3+1],this.values[t*3+2]]}equals(t,e=$e){for(let n=0;n<9;n++)if(Math.abs(this.values[n]-t.at(n))>e)return!1;return!0}determinant(){const t=this.values[0],e=this.values[3],n=this.values[6],s=this.values[1],r=this.values[4],a=this.values[7],o=this.values[2],c=this.values[5],l=this.values[8],u=l*r-a*c,h=-l*s+a*o,d=c*s-r*o;return t*u+e*h+n*d}setIdentity(){return this.values[0]=1,this.values[1]=0,this.values[2]=0,this.values[3]=0,this.values[4]=1,this.values[5]=0,this.values[6]=0,this.values[7]=0,this.values[8]=1,this}transpose(t){t||(t=this);const e=this.values[1],n=this.values[2],s=this.values[5];return t.values[0]=this.values[0],t.values[1]=this.values[3],t.values[2]=this.values[6],t.values[3]=e,t.values[4]=this.values[4],t.values[5]=this.values[7],t.values[6]=n,t.values[7]=s,t.values[8]=this.values[8],t}inverse(t){t||(t=this);const e=this.values[0],n=this.values[3],s=this.values[6],r=this.values[1],a=this.values[4],o=this.values[7],c=this.values[2],l=this.values[5],u=this.values[8],h=u*a-o*l,d=-u*r+o*c,f=l*r-a*c,p=1/(e*h+n*d+s*f);return t.values[0]=h*p,t.values[3]=(-u*n+s*l)*p,t.values[6]=(o*n-s*a)*p,t.values[1]=d*p,t.values[4]=(u*e-s*c)*p,t.values[7]=(-o*e+s*r)*p,t.values[2]=f*p,t.values[5]=(-l*e+n*c)*p,t.values[8]=(a*e-n*r)*p,t}multiply(t,e){e||(e=this);const n=this.values[0],s=this.values[3],r=this.values[6],a=this.values[1],o=this.values[4],c=this.values[7],l=this.values[2],u=this.values[5],h=this.values[8],d=t.values[0],f=t.values[3],p=t.values[6],g=t.values[1],m=t.values[4],_=t.values[7],v=t.values[2],S=t.values[5],A=t.values[8];return e.values[0]=n*d+s*g+r*v,e.values[1]=a*d+o*g+c*v,e.values[2]=l*d+u*g+h*v,e.values[3]=n*f+s*m+r*S,e.values[4]=a*f+o*m+c*S,e.values[5]=l*f+u*m+h*S,e.values[6]=n*p+s*_+r*A,e.values[7]=a*p+o*_+c*A,e.values[8]=l*p+u*_+h*A,e}multiplyVec2(t,e){e||(e=new sn);const n=t.x,s=t.y;return e.xy=[n*this.values[0]+s*this.values[3]+this.values[6],n*this.values[1]+s*this.values[4]+this.values[7]],e}multiplyVec3(t,e){e||(e=new x);const n=t.x,s=t.y,r=t.z;return e.xyz=[n*this.values[0]+s*this.values[3]+r*this.values[6],n*this.values[1]+s*this.values[4]+r*this.values[7],n*this.values[2]+s*this.values[5]+r*this.values[8]],e}toMat4(t){return t||(t=new lt),t.init([this.values[0],this.values[1],this.values[2],0,this.values[3],this.values[4],this.values[5],0,this.values[6],this.values[7],this.values[8],0,0,0,0,1]),t}toQuat(t){t||(t=new ce);const e=this.values[0],n=this.values[3],s=this.values[6],r=this.values[1],a=this.values[4],o=this.values[7],c=this.values[2],l=this.values[5],u=this.values[8],h=e-a-u,d=a-e-u,f=u-e-a,p=e+a+u;let g=0,m=p;h>m&&(m=h,g=1),d>m&&(m=d,g=2),f>m&&(m=f,g=3);const _=Math.sqrt(m+1)*.5,v=.25/_;switch(g){case 0:t.w=_,t.x=(o-l)*v,t.y=(c-s)*v,t.z=(n-r)*v;break;case 1:t.w=(o-l)*v,t.x=_,t.y=(n+r)*v,t.z=(c+s)*v;break;case 2:t.w=(c-s)*v,t.x=(n+r)*v,t.y=_,t.z=(o+l)*v;break;case 3:t.w=(n-r)*v,t.x=(c+s)*v,t.y=(o+l)*v,t.z=_;break}return t}rotate(t,e,n){n||(n=this);let s=e.x,r=e.y,a=e.z,o=Math.sqrt(s*s+r*r+a*a);o!==1&&(o=1/o,s*=o,r*=o,a*=o);const c=Math.sin(t),l=Math.cos(t),u=1-l,h=this.values[0],d=this.values[1],f=this.values[2],p=this.values[3],g=this.values[4],m=this.values[5],_=this.values[6],v=this.values[7],S=this.values[8],A=s*s*u+l,w=r*s*u-a*c,b=a*s*u+r*c,y=s*r*u+a*c,T=r*r*u+l,O=a*r*u-s*c,D=s*a*u-r*c,M=r*a*u+s*c,C=a*a*u+l;return n.values[0]=h*A+p*y+_*D,n.values[1]=d*A+g*y+v*D,n.values[2]=f*A+m*y+S*D,n.values[3]=h*w+p*T+_*M,n.values[4]=d*w+g*T+v*M,n.values[5]=f*w+m*T+S*M,n.values[6]=h*b+p*O+_*C,n.values[7]=d*b+g*O+v*C,n.values[8]=f*b+m*O+S*C,n}scale(t,e){e||(e=this);const n=t.x,s=t.y,r=t.z;return e.values[0]=this.values[0]*n,e.values[1]=this.values[1]*n,e.values[2]=this.values[2]*n,e.values[3]=this.values[3]*s,e.values[4]=this.values[4]*s,e.values[5]=this.values[5]*s,e.values[6]=this.values[6]*r,e.values[7]=this.values[7]*r,e.values[8]=this.values[8]*r,e}};let cn=Rn;E(cn,"identity",new Rn().setIdentity());const Pn=class{constructor(){E(this,"_position",x.zero.copy());E(this,"_scale",x.one.copy());E(this,"_rotation",ce.identity.copy());E(this,"_onChange",null)}bindOnChange(t){this._onChange=t}tryOnChange(){this._onChange!==null&&this._onChange()}getTransformMatrix(){const t=lt.identity.copy().translate(this._position),e=this._rotation.toMat4(),n=lt.identity.copy().scale(this._scale);return t.multiply(e).multiply(n)}get position(){return this._position.copy()}set position(t){this._position=t.copy(),this.tryOnChange()}get scale(){return this._scale.copy()}set scale(t){this._scale=t.copy(),this.tryOnChange()}get rotation(){return this._rotation.copy()}set rotation(t){this._rotation=t.copy(),this.tryOnChange()}translate(t){this._position.add(t),this.tryOnChange()}rotate(t){this.rotation=t.copy().multiply(this.rotation)}applyScale(t){this._scale.multiply(t),this.tryOnChange()}copy(){const t=new Pn;return t.position=this.position.copy(),t.scale=this.scale.copy(),t.rotation=this.rotation.copy(),t}static interpolate(t,e,n){const s=new Pn;return s.position=x.lerp(t.position,e.position,n),s.scale=x.lerp(t.scale,e.scale,n),s.rotation=ce.slerp(t.rotation,e.rotation,n),s}};let On=Pn;E(On,"identity",new Pn);class _e extends On{constructor(){super(...arguments);E(this,"_matrix",lt.identity.copy())}get matrix(){return this._matrix.copy()}set matrix(e){this._matrix=e.copy(),this.tryOnChange()}getTransformMatrix(){return this._matrix.copy()}get position(){throw new Error("uh oh1")}set position(e){throw new Error("uh oh2")}get scale(){throw new Error("uh oh3")}set scale(e){throw new Error("uh oh4")}get rotation(){throw new Error("uh oh5")}set rotation(e){throw new Error("uh oh6")}translate(e){this._matrix=lt.identity.copy().translate(e).multiply(this._matrix),this.tryOnChange()}rotate(e){this._matrix=e.toMat4().multiply(this._matrix),this.tryOnChange()}applyScale(e){this._matrix=lt.identity.copy().scale(e).multiply(this._matrix),this.tryOnChange()}applyTransform(e){this._matrix=e.copy().multiply(this._matrix)}copy(){const e=new _e;return e.matrix=this._matrix.copy(),e}}const Yi=class{constructor(){E(this,"id",Yi.entityIdCounter++);E(this,"parentEntity",null);E(this,"_globalTransform",lt.identity.copy());E(this,"_relativeTransform",new On);E(this,"_needToUpdateTransform",!1);E(this,"childEntities",[]);E(this,"entityData",new Map);this._relativeTransform.bindOnChange(()=>this._needToUpdateTransform=!0)}setup(t){this.childEntities.forEach(e=>e.setup(t))}updateEntity(t){this._needToUpdateTransform&&this.updateTransforms(),this.childEntities.forEach(e=>e.updateEntity(t))}render(){this.childEntities.forEach(t=>t.render())}getBaseEntity(){if(this.entityData.get("isBaseEntity"))return this;if(this.parentEntity)return this.parentEntity.getBaseEntity();throw new Error("No base entity found")}addChildEntity(t){this.childEntities.push(t),t.parentEntity=this}removeChildEntityById(t,e=!0){const n=this.childEntities.findIndex(r=>r.id===t);if(n===-1){if(e)throw new Error(`Entity with id ${t} not found`);return null}const s=this.childEntities[n];return this.childEntities.splice(n,1),s.parentEntity=null,s}removeChildEntity(t,e=!0){return this.removeChildEntityById(t.id,e)}updateTransforms(){const t=this.parentEntity?this.parentEntity.globalTransform.copy():lt.identity.copy();this._globalTransform=t.multiply(this._relativeTransform.getTransformMatrix()),this._needToUpdateTransform=!1,this.childEntities.forEach(e=>e.updateTransforms())}useMatrixTransform(){const t=new _e;return this.transform=t,t}get globalTransform(){return this._needToUpdateTransform&&this.updateTransforms(),this._globalTransform.copy()}get relativeTransform(){return this._relativeTransform}set relativeTransform(t){this._relativeTransform=t,this._relativeTransform.bindOnChange(()=>this._needToUpdateTransform=!0),this._needToUpdateTransform=!0}get transform(){return this.relativeTransform}set transform(t){this.relativeTransform=t}};let Q=Yi;E(Q,"extVAO"),E(Q,"projectionMatrix",new Float32Array(lt.identity.all())),E(Q,"viewMatrix",new Float32Array(lt.identity.all())),E(Q,"viewPos",new Float32Array([0,0,0])),E(Q,"entityIdCounter",0);const tt=i=>{if(i==null)throw new Error("Value is undefined or null");return i},mi=(i,t)=>{const e=new ce,n=x.cross(i,t);return e.xyz=n.xyz,e.w=Math.sqrt(Math.pow(i.length(),2)*Math.pow(t.length(),2))+x.dot(i,t),e.normalize()},Xe=()=>tt(window.scene);var Qa=`precision mediump float;

uniform mat4 projection;\r
uniform mat4 view;\r
uniform mat4 transform;\r
uniform mat3 normalTransform;

attribute vec3 a_vertex;\r
attribute vec3 a_normal;

varying vec3 v_position;\r
varying vec3 v_normal;

void main() {\r
    v_position = (transform * vec4(a_vertex, 1.0)).xyz;\r
    v_normal = normalize(normalTransform * a_normal);\r
    gl_Position = projection * view * transform * vec4(a_vertex, 1.0);\r
}`,to=`precision mediump float;

uniform vec3 viewPos;

uniform int flags[2];\r

varying vec3 v_position;\r
varying vec3 v_normal;

uniform vec4 albedo;

mediump vec4 mixAlbedo(mediump vec4 color) {\r
    return mix(color, albedo, 1.0 - color.a);\r
}\r
#define NUM_LIGHTS 5

uniform vec3 lightPositions[NUM_LIGHTS];\r
uniform vec3 lightColors[NUM_LIGHTS];\r
uniform vec4 lightInfos[NUM_LIGHTS];

vec3 lighting(vec3 viewPos, vec3 position, vec3 normal, vec3 color) {\r
    vec3 allLight = vec3(0);

    for (int i = 0; i < NUM_LIGHTS; i++) {\r
        vec3 lightPosition = lightPositions[i];\r
        vec3 lightColor = lightColors[i];\r
        vec4 lightInfo = lightInfos[i];

        if (lightInfo[0] == 1.0) {\r
            
            allLight += lightColor;\r
        } else if (lightInfo[0] == 2.0) {\r
            
            vec3 lightDir = normalize(lightInfo.yzw);\r
            float diff = max(-dot(normal, lightDir), 0.0);\r
            allLight += lightColor * diff;\r
            float spec = 0.2 * pow(max(dot(normalize(viewPos - position), reflect(lightDir, normal)), 0.0), 32.0);\r
            allLight += lightColor * spec;\r
        } else if (lightInfo[0] == 3.0) {\r
            
            float cf = lightInfo[1];\r
            float lf = lightInfo[2];\r
            float qf = lightInfo[3];\r
            vec3 lightDir = position - lightPosition;\r
            float dist = length(lightDir);\r
            lightDir = normalize(lightDir);\r
            float atten = min(1.0 / (cf + dist * (lf + qf * dist)), 1.0);\r
            float diff = max(-dot(normal, lightDir), 0.0);\r
            allLight += lightColor * diff * atten;\r
            float spec = 0.2 * pow(max(dot(normalize(viewPos - position), reflect(lightDir, normal)), 0.0), 32.0);\r
            allLight += lightColor * spec * atten;\r
        }\r
    }

    return color * allLight;\r
}

void main() {\r
    vec4 color = vec4(0);\r
    vec3 normal = normalize(v_normal);

    if (flags[0] != 0)\r
        color = mixAlbedo(color);\r
    if (flags[1] != 0) {\r
        float a = color.a;\r
        color = vec4(lighting(viewPos, v_position, normal, color.xyz), a);\r
    }

    gl_FragColor = color;\r
}`;class Pe{static requestIntIndicesExt(t){if(!t.getExtension("OES_element_index_uint"))throw new Error("Your browser does not support 32 bit indices")}static requestVAOExt(t){const e=t.getExtension("OES_vertex_array_object");if(!e)throw new Error("Your browser does not support the VAO extension.");return e}static requestDepthTextureExt(t){if(!t.getExtension("WEBGL_depth_texture"))throw new Error("Your browser does not support the depth texture extension.")}static createShader(t,e,n){const s=tt(t.createShader(e==="vertex"?t.VERTEX_SHADER:t.FRAGMENT_SHADER));return t.shaderSource(s,n),t.compileShader(s),t.getShaderParameter(s,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(s)),s}static createShaderProgram(t,e,n){const s=Pe.createShader(t,"vertex",e),r=Pe.createShader(t,"fragment",n),a=tt(t.createProgram());return t.attachShader(a,s),t.attachShader(a,r),t.linkProgram(a),t.getProgramParameter(a,t.LINK_STATUS)||console.log(t.getProgramInfoLog(a)),a}}class eo{constructor(t,e,n,s){E(this,"ctx");E(this,"extVAO");E(this,"vShader");E(this,"fShader");E(this,"shaderProgram");E(this,"VAO");E(this,"indexBuffer");E(this,"indexBufferData");E(this,"attributeBuffers");E(this,"attributes");E(this,"uniforms");E(this,"drawMode");E(this,"drawCount");E(this,"drawType");E(this,"drawOffset");E(this,"textureMap");E(this,"textureMapped");E(this,"textureLoaded");E(this,"texture");this.extVAO=t,this.ctx=e,this.vShader=n.slice(),this.fShader=s.slice(),this.shaderProgram=0,this.VAO=0,this.indexBuffer=0,this.indexBufferData=new Uint32Array(0),this.attributeBuffers=new Map,this.attributes=[],this.uniforms=new Map,this.drawMode=0,this.drawCount=0,this.drawType=0,this.drawOffset=0,this.textureMapped=!1,this.textureLoaded=!1,this.textureMap="",this.texture=0}setup(){const t=this.ctx;this.shaderProgram=Pe.createShaderProgram(t,this.vShader,this.fShader),t.useProgram(this.shaderProgram),this.VAO=this.extVAO.createVertexArrayOES(),this.extVAO.bindVertexArrayOES(this.VAO),this.indexBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,this.indexBufferData,t.STATIC_DRAW),this.attributes.forEach(e=>{const n=t.getAttribLocation(this.shaderProgram,e.name),s=this.attributeBuffers.get(e.bufferName);s?(s.bufferId=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,s.bufferId),t.bufferData(t.ARRAY_BUFFER,s.data,t.STATIC_DRAW),t.vertexAttribPointer(n,e.size,e.type,e.normalized,e.stride,e.offset),t.enableVertexAttribArray(n)):console.error("Attribute's buffer name not found",this)});for(const[e,n]of this.uniforms)n.location=t.getUniformLocation(this.shaderProgram,e);if(this.textureMapped&&!this.textureLoaded){const e=t.createTexture();e===null?console.error("Error creating texture"):this.texture=e,t.bindTexture(t.TEXTURE_2D,this.texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,new Uint8Array([0,0,255,255]));const n=new Image;n.onload=()=>{console.log("Loaded texturemap: "+this.textureMap),t.useProgram(this.shaderProgram),this.extVAO.bindVertexArrayOES(this.VAO),t.bindTexture(t.TEXTURE_2D,this.texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.useProgram(null),this.extVAO.bindVertexArrayOES(null)},n.src="/static/assets/skinning/"+this.textureMap}t.useProgram(null),this.extVAO.bindVertexArrayOES(null)}draw(){const t=this.ctx;t.useProgram(this.shaderProgram),this.extVAO.bindVertexArrayOES(this.VAO),this.uniforms.forEach(e=>{e.bindFunction(t,e.location)}),this.textureMapped&&t.bindTexture(t.TEXTURE_2D,this.texture),t.drawElements(this.drawMode,this.drawCount,this.drawType,this.drawOffset),t.useProgram(null),this.extVAO.bindVertexArrayOES(null)}setDrawData(t,e,n,s){this.drawMode=t,this.drawCount=e,this.drawType=n,this.drawOffset=s}addUniform(t,e){this.uniforms.set(t,new no(0,e))}setIndexBufferData(t){this.indexBufferData=t}addAttribute(t,e,n,s,r,a,o,c){o?this.attributeBuffers.has(o)||(c?this.attributeBuffers.set(o,new Ji(0,c)):console.error("Impossible to determine data for buffer")):(o=t,c?this.attributeBuffers.set(o,new Ji(0,c)):console.error("Impossible to determine data for buffer")),this.attributes.push(new so(t,e,n,s,r,a,o))}addTextureMap(t,e,n){e&&(this.vShader=e),n&&(this.fShader=n),this.textureMapped=!0,this.textureMap=t}addTexture(t){this.textureMapped=!0,this.textureLoaded=!0,this.texture=t}setVertexShader(t){this.vShader=t}setFragmentShader(t){this.fShader=t}setShaders(t,e){this.vShader=t,this.fShader=e}}class no{constructor(t,e){E(this,"location");E(this,"bindFunction");this.location=t,this.bindFunction=e}}class so{constructor(t,e,n,s,r,a,o){E(this,"name");E(this,"size");E(this,"type");E(this,"normalized");E(this,"stride");E(this,"offset");E(this,"bufferName");this.name=t,this.size=e,this.type=n,this.normalized=s,this.stride=r,this.offset=a,this.bufferName=o}}class Ji{constructor(t,e){E(this,"bufferId");E(this,"data");this.bufferId=t,this.data=e}}class gi extends Q{constructor(){super(...arguments);E(this,"rp",null);E(this,"options",{vShader:Qa,fShader:to})}setRenderOptions(e){this.options=k(k({},this.options),e)}setup(e){super.setup(e);const n=tt(this.options.vShader),s=tt(this.options.fShader);this.rp=new eo(Q.extVAO,e,n,s);const r=tt(this.entityData.get("indices")),a=tt(this.entityData.get("vertices"));if(this.rp.setIndexBufferData(r),this.rp.addAttribute("a_vertex",3,e.FLOAT,!1,3*Float32Array.BYTES_PER_ELEMENT,0,void 0,a),this.entityData.has("normals")){const o=tt(this.entityData.get("normals"));this.rp.addAttribute("a_normal",3,e.FLOAT,!1,3*Float32Array.BYTES_PER_ELEMENT,0,void 0,o)}this.rp.addUniform("projection",(o,c)=>{o.uniformMatrix4fv(c,!1,Q.projectionMatrix)}),this.rp.addUniform("view",(o,c)=>{o.uniformMatrix4fv(c,!1,Q.viewMatrix)}),this.rp.addUniform("viewPos",(o,c)=>{o.uniform3fv(c,Q.viewPos)}),this.rp.addUniform("transform",(o,c)=>{o.uniformMatrix4fv(c,!1,this.globalTransform.all())}),this.rp.addUniform("normalTransform",(o,c)=>{o.uniformMatrix3fv(c,!1,this.globalTransform.copy().inverse().transpose().toMat3().all())}),this.entityData.has("flags")&&this.rp.addUniform("flags",(o,c)=>{o.uniform1iv(c,new Int32Array(this.entityData.get("flags")))}),this.entityData.has("albedo")&&Qi(this,"albedo")&&this.rp.addUniform("albedo",(o,c)=>{o.uniform4fv(c,new Float32Array(this.entityData.get("albedo")))}),Qi(this,"lighting")&&(this.rp.addUniform("lightPositions",(o,c)=>{o.uniform3fv(c,this.getBaseEntity().getLightPositions())}),this.rp.addUniform("lightColors",(o,c)=>{o.uniform3fv(c,this.getBaseEntity().getLightColors())}),this.rp.addUniform("lightInfos",(o,c)=>{o.uniform4fv(c,this.getBaseEntity().getLightInfos())})),this.rp.setDrawData(e.TRIANGLES,r.length,e.UNSIGNED_INT,0),this.rp.setup()}render(){if(this.rp===null)throw new Error("Entity not setup");this.rp.draw(),super.render()}get renderPass(){return tt(this.rp)}}const ni=["albedo","lighting"],Mt=(i,t,e=!0)=>{i.entityData.has("flags")||i.entityData.set("flags",new Array(ni.length).fill(0));const n=ni.indexOf(t);if(n===-1)throw new Error(`Invalid RenderEntity flag ${t}`);i.entityData.get("flags")[n]=e?1:0},Qi=(i,t)=>{const e=i.entityData.get("flags");if(!e)return!1;const n=ni.indexOf(t);if(n===-1)throw new Error(`Invalid RenderEntity flag ${t}`);return e[n]===1},st=(i,t)=>{Mt(i,"albedo"),i.entityData.set("albedo",t)},io="cube",ro=[[0,1,2],[2,3,0],[6,5,4],[4,7,6],[10,9,8],[8,11,10],[12,13,14],[14,15,12],[18,17,16],[16,19,18],[22,21,20],[20,23,22]],ao=[[-.5,-.5,-.5],[.5,-.5,-.5],[.5,-.5,.5],[-.5,-.5,.5],[-.5,.5,-.5],[.5,.5,-.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5],[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,.5],[-.5,-.5,-.5],[-.5,.5,-.5],[-.5,.5,.5],[.5,-.5,-.5],[.5,-.5,.5],[.5,.5,.5],[.5,.5,-.5]],oo=[[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0]];var co={name:io,indices:ro,vertices:ao,normals:oo};const lo=i=>{tt(i);const t=tt(i.radius),e=tt(i.height),n=tt(i.segments),s=[],r=[],a=[];for(let u=0;u<n;u++){const h=u/n*Math.PI*2,d=t*Math.cos(h),f=t*Math.sin(h);r.push([d,-e/2,f]),a.push([0,-1,0])}for(let u=0;u<n;u++){const h=u/n*Math.PI*2,d=t*Math.cos(h),f=t*Math.sin(h);r.push([d,e/2,f]),a.push([0,1,0])}const o=r.length;r.push([0,-e/2,0]),a.push([0,-1,0]);const c=r.length;r.push([0,e/2,0]),a.push([0,1,0]);for(let u=0;u<n;u++){const h=u/n*Math.PI*2,d=t*Math.cos(h),f=t*Math.sin(h);r.push([d,-e/2,f]),a.push([d,0,f])}for(let u=0;u<n;u++){const h=u/n*Math.PI*2,d=t*Math.cos(h),f=t*Math.sin(h);r.push([d,e/2,f]),a.push([d,0,f])}for(let u=0;u<n;u++){const h=(u+1)%n;s.push([u,h,o])}for(let u=0;u<n;u++){const h=(u+1)%n;s.push([u+n,c,h+n])}for(let u=0;u<n;u++){const h=(u+1)%n;s.push([u+2*(n+1),u+n+2*(n+1),h+2*(n+1)]),s.push([h+n+2*(n+1),h+2*(n+1),u+n+2*(n+1)])}const l=new gi;return l.entityData.set("indices",new Uint32Array(s.flat())),l.entityData.set("vertices",new Float32Array(r.flat())),l.entityData.set("normals",new Float32Array(a.flat())),l},uo=i=>{i||(i={segments:5}),tt(i);const t=tt(i.segments),e=[],n=[],s=[];[(o,c,l)=>[c,o,l],(o,c,l)=>[-c,-o,l],(o,c,l)=>[o,-c,l],(o,c,l)=>[-o,c,l],(o,c,l)=>[-c,l,o],(o,c,l)=>[c,l,-o]].forEach(o=>{const c=n.length;for(let l=-t;l<=t;l++)for(let u=-t;u<=t;u++){const h=o(t,l,u),d=new x([h[0],h[1],h[2]]);d.normalize();const f=d.copy().scale(.5);n.push(f.xyz),s.push(d.xyz)}for(let l=-t;l<t;l++)for(let u=-t;u<t;u++){const h=c+(l+t)*(2*t+1)+(u+t),d=c+(l+t)*(2*t+1)+(u+1+t),f=c+(l+1+t)*(2*t+1)+(u+t),p=c+(l+1+t)*(2*t+1)+(u+1+t);e.push([h,d,f]),e.push([p,f,d])}});const a=new gi;return a.entityData.set("indices",new Uint32Array(e.flat())),a.entityData.set("vertices",new Float32Array(n.flat())),a.entityData.set("normals",new Float32Array(s.flat())),a},ho=[co],tr=new Map(ho.map(i=>[i.name.toLowerCase(),i])),_t=(i,t)=>{if(tr.has(i)){const e=tt(tr.get(i)),n=new gi;return n.entityData.set("indices",new Uint32Array(e.indices.flat())),n.entityData.set("vertices",new Float32Array(e.vertices.flat())),n.entityData.set("normals",new Float32Array(e.normals.flat())),n}else{if(i==="cylinder")return lo(t);if(i==="sphere")return uo(t);throw new Error(`Solid ${i} not found`)}},Jt=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"],$i=class extends Q{constructor(e=!0){super();E(this,"handNames",["left","right"]);E(this,"handPoses",[new Float32Array(16*25),new Float32Array(16*25)]);E(this,"handRadii",[new Float32Array(25),new Float32Array(25)]);E(this,"handJoints",[[],[]]);E(this,"handBones",[[],[]]);E(this,"complain");this.complain=e;for(let n=0;n<2;n++){for(let s=0;s<25;s++){const r=_t("sphere",{segments:1});r.entityData.set("hand",this.handNames[n]),r.entityData.set("joint",Jt[s]),r.transform.scale=x.zero.copy(),st(r,[1,.7,.7,1]),Mt(r,"lighting"),this.handJoints[n][s]=r,this.addChildEntity(r)}for(let s=0;s<24;s++){const r=_t("cylinder",{radius:.7,height:1,segments:10});r.transform.scale=x.zero.copy(),st(r,[.7,.7,1,1]),Mt(r,"lighting"),this.handBones[n][s]=r,this.addChildEntity(r)}}$i.globalHandsEntity=this}updateEntity(e){this.updateHands(),super.updateEntity(e)}updateHands(){const e=Xe(),n=tt(e.frame);for(const s of e.xrsession.inputSources)if(s.hand){const r=s.hand,a=this.handNames.indexOf(s.handedness);if(a===-1)throw new Error(`Unrecognized handedness: ${s.handedness}`);n.fillPoses(r.values(),e.referenceSpace,this.handPoses[a]),n.fillJointRadii(r.values(),this.handRadii[a]);for(let c=0;c<25;c++){const l=this.handJoints[a][c],u=new _e;l.transform=u,u.applyScale(x.one.copy().scale(1.2*this.handRadii[a][c])),u.applyTransform(new lt(Array.from(this.handPoses[a].subarray(c*16,c*16+16))))}const o=[];for(let c=0;c<5;c++)for(let l=0;l<4;l++)o.push([c*5+l,c*5+l+1]);for(let c=1;c<=4;c++)o.push([0,c*5]);o.forEach((c,l)=>{const u=c[0],h=c[1],d=this.handBones[a][l],f=Array.from(this.handPoses[a].subarray(u*16,u*16+16)),p=Array.from(this.handPoses[a].subarray(h*16,h*16+16)),g=new lt(f),m=new lt(p),_=g.multiplyPt3(x.zero),v=m.multiplyPt3(x.zero),S=mi(x.up,v.copy().subtract(_)),A=_.copy().add(v).scale(.5),w=new _e;d.transform=w;const b=x.distance(_,v);let y=this.handRadii[a][u];Jt[u].includes("metacarpal")||Jt[u].includes("wrist")||(y*=1.2),w.applyScale(new x([y,b,y])),w.rotate(S),w.translate(A)})}else if(this.complain)throw new Error("No hands :(")}getJointPosition(e,n){const s=Jt.indexOf(n);if(s===-1)throw new Error(`Unknown joint: ${n}`);const r=this.handNames.indexOf(e);return new lt(Array.from(this.handPoses[r].subarray(s*16,s*16+16))).multiplyPt3(x.zero)}};let Le=$i;E(Le,"globalHandsEntity");class Kt extends Q{constructor(){super();E(this,"lowOctave",1);E(this,"highOctave",6);E(this,"numKeysPerOctave",7);E(this,"keysContainer",new Q);E(this,"whiteKeys",[]);E(this,"blackKeys",[]);E(this,"keyX",.033);E(this,"keyZ",.15);E(this,"keyY",.02);E(this,"bodyXOffset",.033);E(this,"bottomY",.04);E(this,"bottomZOffset",.05);E(this,"backY",.1);E(this,"backZ",.033);E(this,"sideX",.033);E(this,"sideY",.07);this.keysContainer.transform.translate(new x([0,0,-5*.03/2]));const e=["C","D","E","F","G","A","B"],n=[0,1,3,4,5],s=this.highOctave-this.lowOctave+1;for(let u=this.lowOctave,h=0;u<=this.highOctave;u++)for(let d=0;d<this.numKeysPerOctave;d++,h++){const f=((h+.5)/(s*this.numKeysPerOctave)-.5)*(this.keyX*s*this.numKeysPerOctave),p=new fo(e[d]+u);if(p.transform.applyScale(x.one.copy().scale(.03)),p.transform.translate(new x([f,0,0])),this.whiteKeys.push(p),this.keysContainer.addChildEntity(p),n.includes(d)){const g=new po(e[d]+"#"+u);g.transform.applyScale(new x([.02,.02,.025])),g.transform.translate(new x([f+.015,.015,0])),this.blackKeys.push(g),this.keysContainer.addChildEntity(g)}}this.addChildEntity(this.keysContainer);const r=this.sideX*2+this.keyX*s*this.numKeysPerOctave,a=_t("cube");st(a,[0,0,0,1]),a.transform.applyScale(new x([r,this.bottomY,this.keyZ+this.bottomZOffset])),a.transform.translate(new x([0,(-this.keyY-this.bottomY)/2,0])),this.addChildEntity(a);const o=_t("cube");st(o,[0,0,0,1]),o.transform.applyScale(new x([r,this.backY,this.backZ])),o.transform.translate(new x([0,-this.keyY/2-this.bottomY+this.backY/2,-this.keyZ/2-this.backZ/2])),this.addChildEntity(o);const c=_t("cube");st(c,[0,0,0,1]),c.transform.applyScale(new x([this.sideX,this.sideY,this.keyZ+this.bottomZOffset])),c.transform.translate(new x([-r/2+this.sideX/2,-this.keyY/2-this.bottomY+this.sideY/2,0])),this.addChildEntity(c);const l=_t("cube");st(l,[0,0,0,1]),l.transform.applyScale(new x([this.sideX,this.sideY,this.keyZ+this.bottomZOffset])),l.transform.translate(new x([r/2-this.sideX/2,-this.keyY/2-this.bottomY+this.sideY/2,0])),this.addChildEntity(l)}}E(Kt,"tonejsPiano",null),E(Kt,"currentKeys",new Set);class xr extends Q{constructor(e){super();E(this,"keyName");E(this,"keyBase");E(this,"minX",0);E(this,"maxX",0);E(this,"minY",0);E(this,"maxY",0);E(this,"minZ",0);E(this,"maxZ",0);E(this,"computedBounds",!1);E(this,"currentAngle",0);E(this,"maxAngle",5);E(this,"speed",100);this.keyName=e}updateEntity(e){if(super.updateEntity(e),!this.computedBounds){this.computedBounds=!0;const n=this.keyBase.entityData.get("vertices");for(let s=0;s<n.length/3;s++){const r=n[s*3],a=n[s*3+1],o=n[s*3+2],c=this.keyBase.globalTransform.multiplyPt3(new x([r,a,o]));s==0&&(this.minX=this.maxX=c.x,this.minY=this.maxY=c.y,this.minZ=this.maxZ=c.z),this.minX=Math.min(this.minX,c.x),this.maxX=Math.max(this.maxX,c.x),this.minY=Math.min(this.minY,c.y),this.maxY=Math.max(this.maxY,c.y),this.minZ=Math.min(this.minZ,c.z),this.maxZ=Math.max(this.maxZ,c.z)}}if(Le.globalHandsEntity){const n=tt(Kt.tonejsPiano),s=Le.globalHandsEntity;let r=!1;for(const a of["left","right"])for(const o of Jt){if(!o.endsWith("tip"))continue;const c=s.getJointPosition(a,o),[l,u,h]=c.xyz;l>=this.minX&&l<=this.maxX&&u>=this.minY&&u<=this.maxY&&h>=this.minZ&&h<=this.maxZ&&(r=!0)}r!==Kt.currentKeys.has(this.keyName)&&(r?(Kt.currentKeys.add(this.keyName),n.keyDown({note:this.keyName}),this._onKeyDown()):(Kt.currentKeys.delete(this.keyName),n.keyUp({note:this.keyName,time:"+1"}),this._onKeyUp()))}this.updateAngle(e)}updateAngle(e){if(Kt.currentKeys.has(this.keyName)){const n=Math.min(this.currentAngle+this.speed*e,this.maxAngle);n!==this.currentAngle&&(this.currentAngle=n,this.transform.rotation=ce.fromAxisAngle(x.right,this.currentAngle/180*Math.PI))}else{const n=Math.max(this.currentAngle-this.speed*e,0);n!==this.currentAngle&&(this.currentAngle=n,this.transform.rotation=ce.fromAxisAngle(x.right,this.currentAngle/180*Math.PI))}}_onKeyDown(){}_onKeyUp(){}}class fo extends xr{constructor(e){super(e);E(this,"keyTop");this.keyBase=_t("cube"),this.keyTop=_t("cube");const n=this.keyBase,s=this.keyTop;n.useMatrixTransform(),s.useMatrixTransform();const r=5;n.transform.applyScale(new x([1,1,r])),n.transform.translate(new x([0,0,r/2])),s.transform.applyScale(new x([1.05,.02,r+.05])),s.transform.translate(new x([0,.5,r/2])),st(s,[1,1,1,1]),this.addChildEntity(s),st(n,[.3,.3,.3,1]),this.addChildEntity(n)}_onKeyDown(){super._onKeyDown(),st(this.keyBase,[.3,.3,.7,1]),st(this.keyTop,[.7,.7,1,1])}_onKeyUp(){super._onKeyUp(),st(this.keyBase,[.3,.3,.3,1]),st(this.keyTop,[1,1,1,1])}}class po extends xr{constructor(t){super(t),this.keyBase=_t("cube");const e=this.keyBase;e.useMatrixTransform();const n=4;e.transform.applyScale(new x([1,.8,n])),e.transform.translate(new x([0,0,n/2])),st(e,[.1,.1,.1,1]),this.addChildEntity(e)}_onKeyDown(){super._onKeyDown(),st(this.keyBase,[.3,.3,.7,1])}_onKeyUp(){super._onKeyUp(),st(this.keyBase,[.1,.1,.1,1])}}const Ar="14.7.77",er=(i,t,e)=>({endTime:t,insertTime:e,type:"exponentialRampToValue",value:i}),nr=(i,t,e)=>({endTime:t,insertTime:e,type:"linearRampToValue",value:i}),si=(i,t)=>({startTime:t,type:"setValue",value:i}),Cr=(i,t,e)=>({duration:e,startTime:t,type:"setValueCurve",values:i}),Mr=(i,t,{startTime:e,target:n,timeConstant:s})=>n+(t-n)*Math.exp((e-i)/s),rn=i=>i.type==="exponentialRampToValue",ys=i=>i.type==="linearRampToValue",Se=i=>rn(i)||ys(i),_i=i=>i.type==="setValue",pe=i=>i.type==="setValueCurve",vs=(i,t,e,n)=>{const s=i[t];return s===void 0?n:Se(s)||_i(s)?s.value:pe(s)?s.values[s.values.length-1]:Mr(e,vs(i,t-1,s.startTime,n),s)},sr=(i,t,e,n,s)=>e===void 0?[n.insertTime,s]:Se(e)?[e.endTime,e.value]:_i(e)?[e.startTime,e.value]:pe(e)?[e.startTime+e.duration,e.values[e.values.length-1]]:[e.startTime,vs(i,t-1,e.startTime,s)],ii=i=>i.type==="cancelAndHold",ri=i=>i.type==="cancelScheduledValues",Ee=i=>ii(i)||ri(i)?i.cancelTime:rn(i)||ys(i)?i.endTime:i.startTime,ir=(i,t,e,{endTime:n,value:s})=>e===s?s:0<e&&0<s||e<0&&s<0?e*(s/e)**((i-t)/(n-t)):0,rr=(i,t,e,{endTime:n,value:s})=>e+(i-t)/(n-t)*(s-e),mo=(i,t)=>{const e=Math.floor(t),n=Math.ceil(t);return e===n?i[e]:(1-(t-e))*i[e]+(1-(n-t))*i[n]},go=(i,{duration:t,startTime:e,values:n})=>{const s=(i-e)/t*(n.length-1);return mo(n,s)},ls=i=>i.type==="setTarget";class _o{constructor(t){this._automationEvents=[],this._currenTime=0,this._defaultValue=t}[Symbol.iterator](){return this._automationEvents[Symbol.iterator]()}add(t){const e=Ee(t);if(ii(t)||ri(t)){const n=this._automationEvents.findIndex(r=>ri(t)&&pe(r)?r.startTime+r.duration>=e:Ee(r)>=e),s=this._automationEvents[n];if(n!==-1&&(this._automationEvents=this._automationEvents.slice(0,n)),ii(t)){const r=this._automationEvents[this._automationEvents.length-1];if(s!==void 0&&Se(s)){if(ls(r))throw new Error("The internal list is malformed.");const a=pe(r)?r.startTime+r.duration:Ee(r),o=pe(r)?r.values[r.values.length-1]:r.value,c=rn(s)?ir(e,a,o,s):rr(e,a,o,s),l=rn(s)?er(c,e,this._currenTime):nr(c,e,this._currenTime);this._automationEvents.push(l)}r!==void 0&&ls(r)&&this._automationEvents.push(si(this.getValue(e),e)),r!==void 0&&pe(r)&&r.startTime+r.duration>e&&(this._automationEvents[this._automationEvents.length-1]=Cr(new Float32Array([6,7]),r.startTime,e-r.startTime))}}else{const n=this._automationEvents.findIndex(a=>Ee(a)>e),s=n===-1?this._automationEvents[this._automationEvents.length-1]:this._automationEvents[n-1];if(s!==void 0&&pe(s)&&Ee(s)+s.duration>e)return!1;const r=rn(t)?er(t.value,t.endTime,this._currenTime):ys(t)?nr(t.value,e,this._currenTime):t;if(n===-1)this._automationEvents.push(r);else{if(pe(t)&&e+t.duration>Ee(this._automationEvents[n]))return!1;this._automationEvents.splice(n,0,r)}}return!0}flush(t){const e=this._automationEvents.findIndex(n=>Ee(n)>t);if(e>1){const n=this._automationEvents.slice(e-1),s=n[0];ls(s)&&n.unshift(si(vs(this._automationEvents,e-2,s.startTime,this._defaultValue),s.startTime)),this._automationEvents=n}}getValue(t){if(this._automationEvents.length===0)return this._defaultValue;const e=this._automationEvents.findIndex(a=>Ee(a)>t),n=this._automationEvents[e],s=(e===-1?this._automationEvents.length:e)-1,r=this._automationEvents[s];if(r!==void 0&&ls(r)&&(n===void 0||!Se(n)||n.insertTime>t))return Mr(t,vs(this._automationEvents,s-1,r.startTime,this._defaultValue),r);if(r!==void 0&&_i(r)&&(n===void 0||!Se(n)))return r.value;if(r!==void 0&&pe(r)&&(n===void 0||!Se(n)||r.startTime+r.duration>t))return t<r.startTime+r.duration?go(t,r):r.values[r.values.length-1];if(r!==void 0&&Se(r)&&(n===void 0||!Se(n)))return r.value;if(n!==void 0&&rn(n)){const[a,o]=sr(this._automationEvents,s,r,n,this._defaultValue);return ir(t,a,o,n)}if(n!==void 0&&ys(n)){const[a,o]=sr(this._automationEvents,s,r,n,this._defaultValue);return rr(t,a,o,n)}return this._defaultValue}}const yo=i=>({cancelTime:i,type:"cancelAndHold"}),vo=i=>({cancelTime:i,type:"cancelScheduledValues"}),wo=(i,t)=>({endTime:t,type:"exponentialRampToValue",value:i}),bo=(i,t)=>({endTime:t,type:"linearRampToValue",value:i}),To=(i,t,e)=>({startTime:t,target:i,timeConstant:e,type:"setTarget"}),Eo=()=>new DOMException("","AbortError"),So=i=>(t,e,[n,s,r],a)=>{i(t[s],[e,n,r],o=>o[0]===e&&o[1]===n,a)},No=i=>(t,e,n)=>{const s=[];for(let r=0;r<n.numberOfInputs;r+=1)s.push(new Set);i.set(t,{activeInputs:s,outputs:new Set,passiveInputs:new WeakMap,renderer:e})},xo=i=>(t,e)=>{i.set(t,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:e})},pn=new WeakSet,Ir=new WeakMap,yi=new WeakMap,Or=new WeakMap,vi=new WeakMap,Bs=new WeakMap,kr=new WeakMap,ai=new WeakMap,oi=new WeakMap,ci=new WeakMap,Dr={construct(){return Dr}},Ao=i=>{try{const t=new Proxy(i,Dr);new t}catch{return!1}return!0},ar=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,or=(i,t)=>{const e=[];let n=i.replace(/^[\s]+/,""),s=n.match(ar);for(;s!==null;){const r=s[1].slice(1,-1),a=s[0].replace(/([\s]+)?;?$/,"").replace(r,new URL(r,t).toString());e.push(a),n=n.slice(s[0].length).replace(/^[\s]+/,""),s=n.match(ar)}return[e.join(";"),n]},cr=i=>{if(i!==void 0&&!Array.isArray(i))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")},lr=i=>{if(!Ao(i))throw new TypeError("The given value for processorCtor should be a constructor.");if(i.prototype===null||typeof i.prototype!="object")throw new TypeError("The given value for processorCtor should have a prototype.")},Co=(i,t,e,n,s,r,a,o,c,l,u,h,d)=>{let f=0;return(p,g,m={credentials:"omit"})=>{const _=u.get(p);if(_!==void 0&&_.has(g))return Promise.resolve();const v=l.get(p);if(v!==void 0){const w=v.get(g);if(w!==void 0)return w}const S=r(p),A=S.audioWorklet===void 0?s(g).then(([w,b])=>{const[y,T]=or(w,b),O=`${y};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${T}
})})(window,'_AWGS')`;return e(O)}).then(()=>{const w=d._AWGS.pop();if(w===void 0)throw new SyntaxError;n(S.currentTime,S.sampleRate,()=>w(class{},void 0,(b,y)=>{if(b.trim()==="")throw t();const T=oi.get(S);if(T!==void 0){if(T.has(b))throw t();lr(y),cr(y.parameterDescriptors),T.set(b,y)}else lr(y),cr(y.parameterDescriptors),oi.set(S,new Map([[b,y]]))},S.sampleRate,void 0,void 0))}):Promise.all([s(g),Promise.resolve(i(h,h))]).then(([[w,b],y])=>{const T=f+1;f=T;const[O,D]=or(w,b),N=`${O};((AudioWorkletProcessor,registerProcessor)=>{${D}
})(${y?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${y?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${y?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${T}',class extends AudioWorkletProcessor{process(){return !1}})`,V=new Blob([N],{type:"application/javascript; charset=utf-8"}),F=URL.createObjectURL(V);return S.audioWorklet.addModule(F,m).then(()=>{if(o(S))return S;const U=a(S);return U.audioWorklet.addModule(F,m).then(()=>U)}).then(U=>{if(c===null)throw new SyntaxError;try{new c(U,`__sac${T}`)}catch{throw new SyntaxError}}).finally(()=>URL.revokeObjectURL(F))});return v===void 0?l.set(p,new Map([[g,A]])):v.set(g,A),A.then(()=>{const w=u.get(p);w===void 0?u.set(p,new Set([g])):w.add(g)}).finally(()=>{const w=l.get(p);w!==void 0&&w.delete(g)}),A}},ne=(i,t)=>{const e=i.get(t);if(e===void 0)throw new Error("A value with the given key could not be found.");return e},zs=(i,t)=>{const e=Array.from(i).filter(t);if(e.length>1)throw Error("More than one element was found.");if(e.length===0)throw Error("No element was found.");const[n]=e;return i.delete(n),n},Rr=(i,t,e,n)=>{const s=ne(i,t),r=zs(s,a=>a[0]===e&&a[1]===n);return s.size===0&&i.delete(t),r},Kn=i=>ne(kr,i),mn=i=>{if(pn.has(i))throw new Error("The AudioNode is already stored.");pn.add(i),Kn(i).forEach(t=>t(!0))},Pr=i=>"port"in i,Jn=i=>{if(!pn.has(i))throw new Error("The AudioNode is not stored.");pn.delete(i),Kn(i).forEach(t=>t(!1))},li=(i,t)=>{!Pr(i)&&t.every(e=>e.size===0)&&Jn(i)},Mo=(i,t,e,n,s,r,a,o,c,l,u,h,d)=>{const f=new WeakMap;return(p,g,m,_,v)=>{const{activeInputs:S,passiveInputs:A}=r(g),{outputs:w}=r(p),b=o(p),y=T=>{const O=c(g),D=c(p);if(T){const M=Rr(A,p,m,_);i(S,p,M,!1),!v&&!h(p)&&e(D,O,m,_),d(g)&&mn(g)}else{const M=n(S,p,m,_);t(A,_,M,!1),!v&&!h(p)&&s(D,O,m,_);const C=a(g);if(C===0)u(g)&&li(g,S);else{const P=f.get(g);P!==void 0&&clearTimeout(P),f.set(g,setTimeout(()=>{u(g)&&li(g,S)},C*1e3))}}};return l(w,[g,m,_],T=>T[0]===g&&T[1]===m&&T[2]===_,!0)?(b.add(y),u(p)?i(S,p,[m,_,y],!0):t(A,_,[p,m,y],!0),!0):!1}},Io=i=>(t,e,[n,s,r],a)=>{const o=t.get(n);o===void 0?t.set(n,new Set([[s,e,r]])):i(o,[s,e,r],c=>c[0]===s&&c[1]===e,a)},Oo=i=>(t,e)=>{const n=i(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});e.connect(n).connect(t.destination);const s=()=>{e.removeEventListener("ended",s),e.disconnect(n),n.disconnect()};e.addEventListener("ended",s)},ko=i=>(t,e)=>{i(t).add(e)},Do={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",fftSize:2048,maxDecibels:-30,minDecibels:-100,smoothingTimeConstant:.8},Ro=(i,t,e,n,s,r)=>class extends i{constructor(o,c){const l=s(o),u=k(k({},Do),c),h=n(l,u),d=r(l)?t():null;super(o,!1,h,d),this._nativeAnalyserNode=h}get fftSize(){return this._nativeAnalyserNode.fftSize}set fftSize(o){this._nativeAnalyserNode.fftSize=o}get frequencyBinCount(){return this._nativeAnalyserNode.frequencyBinCount}get maxDecibels(){return this._nativeAnalyserNode.maxDecibels}set maxDecibels(o){const c=this._nativeAnalyserNode.maxDecibels;if(this._nativeAnalyserNode.maxDecibels=o,!(o>this._nativeAnalyserNode.minDecibels))throw this._nativeAnalyserNode.maxDecibels=c,e()}get minDecibels(){return this._nativeAnalyserNode.minDecibels}set minDecibels(o){const c=this._nativeAnalyserNode.minDecibels;if(this._nativeAnalyserNode.minDecibels=o,!(this._nativeAnalyserNode.maxDecibels>o))throw this._nativeAnalyserNode.minDecibels=c,e()}get smoothingTimeConstant(){return this._nativeAnalyserNode.smoothingTimeConstant}set smoothingTimeConstant(o){this._nativeAnalyserNode.smoothingTimeConstant=o}getByteFrequencyData(o){this._nativeAnalyserNode.getByteFrequencyData(o)}getByteTimeDomainData(o){this._nativeAnalyserNode.getByteTimeDomainData(o)}getFloatFrequencyData(o){this._nativeAnalyserNode.getFloatFrequencyData(o)}getFloatTimeDomainData(o){this._nativeAnalyserNode.getFloatTimeDomainData(o)}},Ot=(i,t)=>i.context===t,Po=(i,t,e)=>()=>{const n=new WeakMap,s=async(r,a)=>{let o=t(r);if(!Ot(o,a)){const l={channelCount:o.channelCount,channelCountMode:o.channelCountMode,channelInterpretation:o.channelInterpretation,fftSize:o.fftSize,maxDecibels:o.maxDecibels,minDecibels:o.minDecibels,smoothingTimeConstant:o.smoothingTimeConstant};o=i(a,l)}return n.set(a,o),await e(r,a,o),o};return{render(r,a){const o=n.get(a);return o!==void 0?Promise.resolve(o):s(r,a)}}},ws=i=>{try{i.copyToChannel(new Float32Array(1),0,-1)}catch{return!1}return!0},ue=()=>new DOMException("","IndexSizeError"),wi=i=>{i.getChannelData=(t=>e=>{try{return t.call(i,e)}catch(n){throw n.code===12?ue():n}})(i.getChannelData)},Lo={numberOfChannels:1},Fo=(i,t,e,n,s,r,a,o)=>{let c=null;return class Lr{constructor(u){if(s===null)throw new Error("Missing the native OfflineAudioContext constructor.");const{length:h,numberOfChannels:d,sampleRate:f}=k(k({},Lo),u);c===null&&(c=new s(1,1,44100));const p=n!==null&&t(r,r)?new n({length:h,numberOfChannels:d,sampleRate:f}):c.createBuffer(d,h,f);if(p.numberOfChannels===0)throw e();return typeof p.copyFromChannel!="function"?(a(p),wi(p)):t(ws,()=>ws(p))||o(p),i.add(p),p}static[Symbol.hasInstance](u){return u!==null&&typeof u=="object"&&Object.getPrototypeOf(u)===Lr.prototype||i.has(u)}}},Lt=-34028234663852886e22,Dt=-Lt,ge=i=>pn.has(i),Vo={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1},Bo=(i,t,e,n,s,r,a,o)=>class extends i{constructor(l,u){const h=r(l),d=k(k({},Vo),u),f=s(h,d),p=a(h),g=p?t():null;super(l,!1,f,g),this._audioBufferSourceNodeRenderer=g,this._isBufferNullified=!1,this._isBufferSet=d.buffer!==null,this._nativeAudioBufferSourceNode=f,this._onended=null,this._playbackRate=e(this,p,f.playbackRate,Dt,Lt)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(l){if(this._nativeAudioBufferSourceNode.buffer=l,l!==null){if(this._isBufferSet)throw n();this._isBufferSet=!0}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(l){this._nativeAudioBufferSourceNode.loop=l}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(l){this._nativeAudioBufferSourceNode.loopEnd=l}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(l){this._nativeAudioBufferSourceNode.loopStart=l}get onended(){return this._onended}set onended(l){const u=typeof l=="function"?o(this,l):null;this._nativeAudioBufferSourceNode.onended=u;const h=this._nativeAudioBufferSourceNode.onended;this._onended=h!==null&&h===u?l:h}get playbackRate(){return this._playbackRate}start(l=0,u=0,h){if(this._nativeAudioBufferSourceNode.start(l,u,h),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.start=h===void 0?[l,u]:[l,u,h]),this.context.state!=="closed"){mn(this);const d=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",d),ge(this)&&Jn(this)};this._nativeAudioBufferSourceNode.addEventListener("ended",d)}}stop(l=0){this._nativeAudioBufferSourceNode.stop(l),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.stop=l)}},zo=(i,t,e,n,s)=>()=>{const r=new WeakMap;let a=null,o=null;const c=async(l,u)=>{let h=e(l);const d=Ot(h,u);if(!d){const f={buffer:h.buffer,channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,loop:h.loop,loopEnd:h.loopEnd,loopStart:h.loopStart,playbackRate:h.playbackRate.value};h=t(u,f),a!==null&&h.start(...a),o!==null&&h.stop(o)}return r.set(u,h),d?await i(u,l.playbackRate,h.playbackRate):await n(u,l.playbackRate,h.playbackRate),await s(l,u,h),h};return{set start(l){a=l},set stop(l){o=l},render(l,u){const h=r.get(u);return h!==void 0?Promise.resolve(h):c(l,u)}}},Uo=i=>"playbackRate"in i,qo=i=>"frequency"in i&&"gain"in i,Wo=i=>"offset"in i,jo=i=>!("frequency"in i)&&"gain"in i,Go=i=>"detune"in i&&"frequency"in i,Ho=i=>"pan"in i,Rt=i=>ne(Ir,i),Qn=i=>ne(Or,i),ui=(i,t)=>{const{activeInputs:e}=Rt(i);e.forEach(s=>s.forEach(([r])=>{t.includes(i)||ui(r,[...t,i])}));const n=Uo(i)?[i.playbackRate]:Pr(i)?Array.from(i.parameters.values()):qo(i)?[i.Q,i.detune,i.frequency,i.gain]:Wo(i)?[i.offset]:jo(i)?[i.gain]:Go(i)?[i.detune,i.frequency]:Ho(i)?[i.pan]:[];for(const s of n){const r=Qn(s);r!==void 0&&r.activeInputs.forEach(([a])=>ui(a,t))}ge(i)&&Jn(i)},Fr=i=>{ui(i.destination,[])},Yo=i=>i===void 0||typeof i=="number"||typeof i=="string"&&(i==="balanced"||i==="interactive"||i==="playback"),$o=(i,t,e,n,s,r,a,o,c)=>class extends i{constructor(u={}){if(c===null)throw new Error("Missing the native AudioContext constructor.");let h;try{h=new c(u)}catch(p){throw p.code===12&&p.message==="sampleRate is not in range"?e():p}if(h===null)throw n();if(!Yo(u.latencyHint))throw new TypeError(`The provided value '${u.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(u.sampleRate!==void 0&&h.sampleRate!==u.sampleRate)throw e();super(h,2);const{latencyHint:d}=u,{sampleRate:f}=h;if(this._baseLatency=typeof h.baseLatency=="number"?h.baseLatency:d==="balanced"?512/f:d==="interactive"||d===void 0?256/f:d==="playback"?1024/f:Math.max(2,Math.min(128,Math.round(d*f/128)))*128/f,this._nativeAudioContext=h,c.name==="webkitAudioContext"?(this._nativeGainNode=h.createGain(),this._nativeOscillatorNode=h.createOscillator(),this._nativeGainNode.gain.value=1e-37,this._nativeOscillatorNode.connect(this._nativeGainNode).connect(h.destination),this._nativeOscillatorNode.start()):(this._nativeGainNode=null,this._nativeOscillatorNode=null),this._state=null,h.state==="running"){this._state="suspended";const p=()=>{this._state==="suspended"&&(this._state=null),h.removeEventListener("statechange",p)};h.addEventListener("statechange",p)}}get baseLatency(){return this._baseLatency}get state(){return this._state!==null?this._state:this._nativeAudioContext.state}close(){return this.state==="closed"?this._nativeAudioContext.close().then(()=>{throw t()}):(this._state==="suspended"&&(this._state=null),this._nativeAudioContext.close().then(()=>{this._nativeGainNode!==null&&this._nativeOscillatorNode!==null&&(this._nativeOscillatorNode.stop(),this._nativeGainNode.disconnect(),this._nativeOscillatorNode.disconnect()),Fr(this)}))}createMediaElementSource(u){return new s(this,{mediaElement:u})}createMediaStreamDestination(){return new r(this)}createMediaStreamSource(u){return new a(this,{mediaStream:u})}createMediaStreamTrackSource(u){return new o(this,{mediaStreamTrack:u})}resume(){return this._state==="suspended"?new Promise((u,h)=>{const d=()=>{this._nativeAudioContext.removeEventListener("statechange",d),this._nativeAudioContext.state==="running"?u():this.resume().then(u,h)};this._nativeAudioContext.addEventListener("statechange",d)}):this._nativeAudioContext.resume().catch(u=>{throw u===void 0||u.code===15?t():u})}suspend(){return this._nativeAudioContext.suspend().catch(u=>{throw u===void 0?t():u})}},Xo=(i,t,e,n,s,r,a,o)=>class extends i{constructor(l,u){const h=r(l),d=a(h),f=s(h,u,d),p=d?t(o):null;super(l,!1,f,p),this._isNodeOfNativeOfflineAudioContext=d,this._nativeAudioDestinationNode=f}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(l){if(this._isNodeOfNativeOfflineAudioContext)throw n();if(l>this._nativeAudioDestinationNode.maxChannelCount)throw e();this._nativeAudioDestinationNode.channelCount=l}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(l){if(this._isNodeOfNativeOfflineAudioContext)throw n();this._nativeAudioDestinationNode.channelCountMode=l}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}},Zo=i=>{const t=new WeakMap,e=async(n,s)=>{const r=s.destination;return t.set(s,r),await i(n,s,r),r};return{render(n,s){const r=t.get(s);return r!==void 0?Promise.resolve(r):e(n,s)}}},Ko=(i,t,e,n,s,r,a,o)=>(c,l)=>{const u=l.listener,h=()=>{const w=new Float32Array(1),b=t(l,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9}),y=a(l);let T=!1,O=[0,0,-1,0,1,0],D=[0,0,0];const M=()=>{if(T)return;T=!0;const V=n(l,256,9,0);V.onaudioprocess=({inputBuffer:F})=>{const U=[r(F,w,0),r(F,w,1),r(F,w,2),r(F,w,3),r(F,w,4),r(F,w,5)];U.some((q,X)=>q!==O[X])&&(u.setOrientation(...U),O=U);const G=[r(F,w,6),r(F,w,7),r(F,w,8)];G.some((q,X)=>q!==D[X])&&(u.setPosition(...G),D=G)},b.connect(V)},C=V=>F=>{F!==O[V]&&(O[V]=F,u.setOrientation(...O))},P=V=>F=>{F!==D[V]&&(D[V]=F,u.setPosition(...D))},N=(V,F,U)=>{const G=e(l,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:F});G.connect(b,0,V),G.start(),Object.defineProperty(G.offset,"defaultValue",{get(){return F}});const q=i({context:c},y,G.offset,Dt,Lt);return o(q,"value",X=>()=>X.call(q),X=>J=>{try{X.call(q,J)}catch(ot){if(ot.code!==9)throw ot}M(),y&&U(J)}),q.cancelAndHoldAtTime=(X=>y?()=>{throw s()}:(...J)=>{const ot=X.apply(q,J);return M(),ot})(q.cancelAndHoldAtTime),q.cancelScheduledValues=(X=>y?()=>{throw s()}:(...J)=>{const ot=X.apply(q,J);return M(),ot})(q.cancelScheduledValues),q.exponentialRampToValueAtTime=(X=>y?()=>{throw s()}:(...J)=>{const ot=X.apply(q,J);return M(),ot})(q.exponentialRampToValueAtTime),q.linearRampToValueAtTime=(X=>y?()=>{throw s()}:(...J)=>{const ot=X.apply(q,J);return M(),ot})(q.linearRampToValueAtTime),q.setTargetAtTime=(X=>y?()=>{throw s()}:(...J)=>{const ot=X.apply(q,J);return M(),ot})(q.setTargetAtTime),q.setValueAtTime=(X=>y?()=>{throw s()}:(...J)=>{const ot=X.apply(q,J);return M(),ot})(q.setValueAtTime),q.setValueCurveAtTime=(X=>y?()=>{throw s()}:(...J)=>{const ot=X.apply(q,J);return M(),ot})(q.setValueCurveAtTime),q};return{forwardX:N(0,0,C(0)),forwardY:N(1,0,C(1)),forwardZ:N(2,-1,C(2)),positionX:N(6,0,P(0)),positionY:N(7,0,P(1)),positionZ:N(8,0,P(2)),upX:N(3,0,C(3)),upY:N(4,1,C(4)),upZ:N(5,0,C(5))}},{forwardX:d,forwardY:f,forwardZ:p,positionX:g,positionY:m,positionZ:_,upX:v,upY:S,upZ:A}=u.forwardX===void 0?h():u;return{get forwardX(){return d},get forwardY(){return f},get forwardZ(){return p},get positionX(){return g},get positionY(){return m},get positionZ(){return _},get upX(){return v},get upY(){return S},get upZ(){return A}}},bs=i=>"context"in i,ts=i=>bs(i[0]),Ze=(i,t,e,n)=>{for(const s of i)if(e(s)){if(n)return!1;throw Error("The set contains at least one similar element.")}return i.add(t),!0},ur=(i,t,[e,n],s)=>{Ze(i,[t,e,n],r=>r[0]===t&&r[1]===e,s)},hr=(i,[t,e,n],s)=>{const r=i.get(t);r===void 0?i.set(t,new Set([[e,n]])):Ze(r,[e,n],a=>a[0]===e,s)},yn=i=>"inputs"in i,Ts=(i,t,e,n)=>{if(yn(t)){const s=t.inputs[n];return i.connect(s,e,0),[s,e,0]}return i.connect(t,e,n),[t,e,n]},Vr=(i,t,e)=>{for(const n of i)if(n[0]===t&&n[1]===e)return i.delete(n),n;return null},Jo=(i,t,e)=>zs(i,n=>n[0]===t&&n[1]===e),Br=(i,t)=>{if(!Kn(i).delete(t))throw new Error("Missing the expected event listener.")},zr=(i,t,e)=>{const n=ne(i,t),s=zs(n,r=>r[0]===e);return n.size===0&&i.delete(t),s},Es=(i,t,e,n)=>{yn(t)?i.disconnect(t.inputs[n],e,0):i.disconnect(t,e,n)},ht=i=>ne(yi,i),Ln=i=>ne(vi,i),ze=i=>ai.has(i),ps=i=>!pn.has(i),dr=(i,t)=>new Promise(e=>{if(t!==null)e(!0);else{const n=i.createScriptProcessor(256,1,1),s=i.createGain(),r=i.createBuffer(1,2,44100),a=r.getChannelData(0);a[0]=1,a[1]=1;const o=i.createBufferSource();o.buffer=r,o.loop=!0,o.connect(n).connect(i.destination),o.connect(s),o.disconnect(s),n.onaudioprocess=c=>{const l=c.inputBuffer.getChannelData(0);Array.prototype.some.call(l,u=>u===1)?e(!0):e(!1),o.stop(),n.onaudioprocess=null,o.disconnect(n),n.disconnect(i.destination)},o.start()}}),ei=(i,t)=>{const e=new Map;for(const n of i)for(const s of n){const r=e.get(s);e.set(s,r===void 0?1:r+1)}e.forEach((n,s)=>t(s,n))},Ss=i=>"context"in i,Qo=i=>{const t=new Map;i.connect=(e=>(n,s=0,r=0)=>{const a=Ss(n)?e(n,s,r):e(n,s),o=t.get(n);return o===void 0?t.set(n,[{input:r,output:s}]):o.every(c=>c.input!==r||c.output!==s)&&o.push({input:r,output:s}),a})(i.connect.bind(i)),i.disconnect=(e=>(n,s,r)=>{if(e.apply(i),n===void 0)t.clear();else if(typeof n=="number")for(const[a,o]of t){const c=o.filter(l=>l.output!==n);c.length===0?t.delete(a):t.set(a,c)}else if(t.has(n))if(s===void 0)t.delete(n);else{const a=t.get(n);if(a!==void 0){const o=a.filter(c=>c.output!==s&&(c.input!==r||r===void 0));o.length===0?t.delete(n):t.set(n,o)}}for(const[a,o]of t)o.forEach(c=>{Ss(a)?i.connect(a,c.output,c.input):i.connect(a,c.output)})})(i.disconnect)},tc=(i,t,e,n)=>{const{activeInputs:s,passiveInputs:r}=Qn(t),{outputs:a}=Rt(i),o=Kn(i),c=l=>{const u=ht(i),h=Ln(t);if(l){const d=zr(r,i,e);ur(s,i,d,!1),!n&&!ze(i)&&u.connect(h,e)}else{const d=Jo(s,i,e);hr(r,d,!1),!n&&!ze(i)&&u.disconnect(h,e)}};return Ze(a,[t,e],l=>l[0]===t&&l[1]===e,!0)?(o.add(c),ge(i)?ur(s,i,[e,c],!0):hr(r,[i,e,c],!0),!0):!1},ec=(i,t,e,n)=>{const{activeInputs:s,passiveInputs:r}=Rt(t),a=Vr(s[n],i,e);return a===null?[Rr(r,i,e,n)[2],!1]:[a[2],!0]},nc=(i,t,e)=>{const{activeInputs:n,passiveInputs:s}=Qn(t),r=Vr(n,i,e);return r===null?[zr(s,i,e)[1],!1]:[r[2],!0]},bi=(i,t,e,n,s)=>{const[r,a]=ec(i,e,n,s);if(r!==null&&(Br(i,r),a&&!t&&!ze(i)&&Es(ht(i),ht(e),n,s)),ge(e)){const{activeInputs:o}=Rt(e);li(e,o)}},Ti=(i,t,e,n)=>{const[s,r]=nc(i,e,n);s!==null&&(Br(i,s),r&&!t&&!ze(i)&&ht(i).disconnect(Ln(e),n))},sc=(i,t)=>{const e=Rt(i),n=[];for(const s of e.outputs)ts(s)?bi(i,t,...s):Ti(i,t,...s),n.push(s[0]);return e.outputs.clear(),n},ic=(i,t,e)=>{const n=Rt(i),s=[];for(const r of n.outputs)r[1]===e&&(ts(r)?bi(i,t,...r):Ti(i,t,...r),s.push(r[0]),n.outputs.delete(r));return s},rc=(i,t,e,n,s)=>{const r=Rt(i);return Array.from(r.outputs).filter(a=>a[0]===e&&(n===void 0||a[1]===n)&&(s===void 0||a[2]===s)).map(a=>(ts(a)?bi(i,t,...a):Ti(i,t,...a),r.outputs.delete(a),a[0]))},ac=(i,t,e,n,s,r,a,o,c,l,u,h,d,f,p,g)=>class extends l{constructor(_,v,S,A){super(S),this._context=_,this._nativeAudioNode=S;const w=u(_);h(w)&&e(dr,()=>dr(w,g))!==!0&&Qo(S),yi.set(this,S),kr.set(this,new Set),_.state!=="closed"&&v&&mn(this),i(this,A,S)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(_){this._nativeAudioNode.channelCount=_}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(_){this._nativeAudioNode.channelCountMode=_}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(_){this._nativeAudioNode.channelInterpretation=_}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(_,v=0,S=0){if(v<0||v>=this._nativeAudioNode.numberOfOutputs)throw s();const A=u(this._context),w=p(A);if(d(_)||f(_))throw r();if(bs(_)){const T=ht(_);try{const D=Ts(this._nativeAudioNode,T,v,S),M=ps(this);(w||M)&&this._nativeAudioNode.disconnect(...D),this.context.state!=="closed"&&!M&&ps(_)&&mn(_)}catch(D){throw D.code===12?r():D}if(t(this,_,v,S,w)){const D=c([this],_);ei(D,n(w))}return _}const b=Ln(_);if(b.name==="playbackRate"&&b.maxValue===1024)throw a();try{this._nativeAudioNode.connect(b,v),(w||ps(this))&&this._nativeAudioNode.disconnect(b,v)}catch(T){throw T.code===12?r():T}if(tc(this,_,v,w)){const T=c([this],_);ei(T,n(w))}}disconnect(_,v,S){let A;const w=u(this._context),b=p(w);if(_===void 0)A=sc(this,b);else if(typeof _=="number"){if(_<0||_>=this.numberOfOutputs)throw s();A=ic(this,b,_)}else{if(v!==void 0&&(v<0||v>=this.numberOfOutputs)||bs(_)&&S!==void 0&&(S<0||S>=_.numberOfInputs))throw s();if(A=rc(this,b,_,v,S),A.length===0)throw r()}for(const y of A){const T=c([this],y);ei(T,o)}}},oc=(i,t,e,n,s,r,a,o,c,l,u,h,d)=>(f,p,g,m=null,_=null)=>{const v=new _o(g.defaultValue),S=p?n(v):null,A={get defaultValue(){return g.defaultValue},get maxValue(){return m===null?g.maxValue:m},get minValue(){return _===null?g.minValue:_},get value(){return g.value},set value(w){g.value=w,A.setValueAtTime(w,f.context.currentTime)},cancelAndHoldAtTime(w){if(typeof g.cancelAndHoldAtTime=="function")S===null&&v.flush(f.context.currentTime),v.add(s(w)),g.cancelAndHoldAtTime(w);else{const b=Array.from(v).pop();S===null&&v.flush(f.context.currentTime),v.add(s(w));const y=Array.from(v).pop();g.cancelScheduledValues(w),b!==y&&y!==void 0&&(y.type==="exponentialRampToValue"?g.exponentialRampToValueAtTime(y.value,y.endTime):y.type==="linearRampToValue"?g.linearRampToValueAtTime(y.value,y.endTime):y.type==="setValue"?g.setValueAtTime(y.value,y.startTime):y.type==="setValueCurve"&&g.setValueCurveAtTime(y.values,y.startTime,y.duration))}return A},cancelScheduledValues(w){return S===null&&v.flush(f.context.currentTime),v.add(r(w)),g.cancelScheduledValues(w),A},exponentialRampToValueAtTime(w,b){if(w===0)throw new RangeError;if(!Number.isFinite(b)||b<0)throw new RangeError;return S===null&&v.flush(f.context.currentTime),v.add(a(w,b)),g.exponentialRampToValueAtTime(w,b),A},linearRampToValueAtTime(w,b){return S===null&&v.flush(f.context.currentTime),v.add(o(w,b)),g.linearRampToValueAtTime(w,b),A},setTargetAtTime(w,b,y){return S===null&&v.flush(f.context.currentTime),v.add(c(w,b,y)),g.setTargetAtTime(w,b,y),A},setValueAtTime(w,b){return S===null&&v.flush(f.context.currentTime),v.add(l(w,b)),g.setValueAtTime(w,b),A},setValueCurveAtTime(w,b,y){const T=w instanceof Float32Array?w:new Float32Array(w);if(h!==null&&h.name==="webkitAudioContext"){const O=b+y,D=f.context.sampleRate,M=Math.ceil(b*D),C=Math.floor(O*D),P=C-M,N=new Float32Array(P);for(let F=0;F<P;F+=1){const U=(T.length-1)/y*((M+F)/D-b),G=Math.floor(U),q=Math.ceil(U);N[F]=G===q?T[G]:(1-(U-G))*T[G]+(1-(q-U))*T[q]}S===null&&v.flush(f.context.currentTime),v.add(u(N,b,y)),g.setValueCurveAtTime(N,b,y);const V=C/D;V<O&&d(A,N[N.length-1],V),d(A,T[T.length-1],O)}else S===null&&v.flush(f.context.currentTime),v.add(u(T,b,y)),g.setValueCurveAtTime(T,b,y);return A}};return e.set(A,g),t.set(A,f),i(A,S),A},cc=i=>({replay(t){for(const e of i)if(e.type==="exponentialRampToValue"){const{endTime:n,value:s}=e;t.exponentialRampToValueAtTime(s,n)}else if(e.type==="linearRampToValue"){const{endTime:n,value:s}=e;t.linearRampToValueAtTime(s,n)}else if(e.type==="setTarget"){const{startTime:n,target:s,timeConstant:r}=e;t.setTargetAtTime(s,n,r)}else if(e.type==="setValue"){const{startTime:n,value:s}=e;t.setValueAtTime(s,n)}else if(e.type==="setValueCurve"){const{duration:n,startTime:s,values:r}=e;t.setValueCurveAtTime(r,s,n)}else throw new Error("Can't apply an unknown automation.")}});class Ur{constructor(t){this._map=new Map(t)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(t,e=null){return this._map.forEach((n,s)=>t.call(e,n,s,this))}get(t){return this._map.get(t)}has(t){return this._map.has(t)}keys(){return this._map.keys()}values(){return this._map.values()}}const lc={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,parameterData:{},processorOptions:{}},uc=(i,t,e,n,s,r,a,o,c,l,u,h,d,f)=>class extends t{constructor(g,m,_){var v;const S=o(g),A=c(S),w=u(k(k({},lc),_));d(w);const b=oi.get(S),y=b==null?void 0:b.get(m),T=A||S.state!=="closed"?S:(v=a(S))!==null&&v!==void 0?v:S,O=s(T,A?null:g.baseLatency,l,m,y,w),D=A?n(m,w,y):null;super(g,!0,O,D);const M=[];O.parameters.forEach((P,N)=>{const V=e(this,A,P);M.push([N,V])}),this._nativeAudioWorkletNode=O,this._onprocessorerror=null,this._parameters=new Ur(M),A&&i(S,this);const{activeInputs:C}=r(this);h(O,C)}get onprocessorerror(){return this._onprocessorerror}set onprocessorerror(g){const m=typeof g=="function"?f(this,g):null;this._nativeAudioWorkletNode.onprocessorerror=m;const _=this._nativeAudioWorkletNode.onprocessorerror;this._onprocessorerror=_!==null&&_===m?g:_}get parameters(){return this._parameters===null?this._nativeAudioWorkletNode.parameters:this._parameters}get port(){return this._nativeAudioWorkletNode.port}};function Ns(i,t,e,n,s){if(typeof i.copyFromChannel=="function")t[e].byteLength===0&&(t[e]=new Float32Array(128)),i.copyFromChannel(t[e],n,s);else{const r=i.getChannelData(n);if(t[e].byteLength===0)t[e]=r.slice(s,s+128);else{const a=new Float32Array(r.buffer,s*Float32Array.BYTES_PER_ELEMENT,128);t[e].set(a)}}}const qr=(i,t,e,n,s)=>{typeof i.copyToChannel=="function"?t[e].byteLength!==0&&i.copyToChannel(t[e],n,s):t[e].byteLength!==0&&i.getChannelData(n).set(t[e],s)},xs=(i,t)=>{const e=[];for(let n=0;n<i;n+=1){const s=[],r=typeof t=="number"?t:t[n];for(let a=0;a<r;a+=1)s.push(new Float32Array(128));e.push(s)}return e},hc=(i,t)=>{const e=ne(ci,i),n=ht(t);return ne(e,n)},dc=async(i,t,e,n,s,r,a)=>{const o=t===null?Math.ceil(i.context.length/128)*128:t.length,c=n.channelCount*n.numberOfInputs,l=s.reduce((m,_)=>m+_,0),u=l===0?null:e.createBuffer(l,o,e.sampleRate);if(r===void 0)throw new Error("Missing the processor constructor.");const h=Rt(i),d=await hc(e,i),f=xs(n.numberOfInputs,n.channelCount),p=xs(n.numberOfOutputs,s),g=Array.from(i.parameters.keys()).reduce((m,_)=>j(k({},m),{[_]:new Float32Array(128)}),{});for(let m=0;m<o;m+=128){if(n.numberOfInputs>0&&t!==null)for(let _=0;_<n.numberOfInputs;_+=1)for(let v=0;v<n.channelCount;v+=1)Ns(t,f[_],v,v,m);r.parameterDescriptors!==void 0&&t!==null&&r.parameterDescriptors.forEach(({name:_},v)=>{Ns(t,g,_,c+v,m)});for(let _=0;_<n.numberOfInputs;_+=1)for(let v=0;v<s[_];v+=1)p[_][v].byteLength===0&&(p[_][v]=new Float32Array(128));try{const _=f.map((S,A)=>h.activeInputs[A].size===0?[]:S),v=a(m/e.sampleRate,e.sampleRate,()=>d.process(_,p,g));if(u!==null)for(let S=0,A=0;S<n.numberOfOutputs;S+=1){for(let w=0;w<s[S];w+=1)qr(u,p[S],w,A+w,m);A+=s[S]}if(!v)break}catch(_){i.dispatchEvent(new ErrorEvent("processorerror",{colno:_.colno,filename:_.filename,lineno:_.lineno,message:_.message}));break}}return u},fc=(i,t,e,n,s,r,a,o,c,l,u,h,d,f,p,g)=>(m,_,v)=>{const S=new WeakMap;let A=null;const w=async(b,y)=>{let T=u(b),O=null;const D=Ot(T,y),M=Array.isArray(_.outputChannelCount)?_.outputChannelCount:Array.from(_.outputChannelCount);if(h===null){const C=M.reduce((F,U)=>F+U,0),P=s(y,{channelCount:Math.max(1,C),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,C)}),N=[];for(let F=0;F<b.numberOfOutputs;F+=1)N.push(n(y,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:M[F]}));const V=a(y,{channelCount:_.channelCount,channelCountMode:_.channelCountMode,channelInterpretation:_.channelInterpretation,gain:1});V.connect=t.bind(null,N),V.disconnect=c.bind(null,N),O=[P,N,V]}else D||(T=new h(y,m));if(S.set(y,O===null?T:O[2]),O!==null){if(A===null){if(v===void 0)throw new Error("Missing the processor constructor.");if(d===null)throw new Error("Missing the native OfflineAudioContext constructor.");const U=b.channelCount*b.numberOfInputs,G=v.parameterDescriptors===void 0?0:v.parameterDescriptors.length,q=U+G;A=dc(b,q===0?null:await(async()=>{const J=new d(q,Math.ceil(b.context.length/128)*128,y.sampleRate),ot=[],vt=[];for(let nt=0;nt<_.numberOfInputs;nt+=1)ot.push(a(J,{channelCount:_.channelCount,channelCountMode:_.channelCountMode,channelInterpretation:_.channelInterpretation,gain:1})),vt.push(s(J,{channelCount:_.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:_.channelCount}));const zt=await Promise.all(Array.from(b.parameters.values()).map(async nt=>{const Y=r(J,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:nt.value});return await f(J,nt,Y.offset),Y})),Ut=n(J,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,U+G)});for(let nt=0;nt<_.numberOfInputs;nt+=1){ot[nt].connect(vt[nt]);for(let Y=0;Y<_.channelCount;Y+=1)vt[nt].connect(Ut,Y,nt*_.channelCount+Y)}for(const[nt,Y]of zt.entries())Y.connect(Ut,0,U+nt),Y.start(0);return Ut.connect(J.destination),await Promise.all(ot.map(nt=>p(b,J,nt))),g(J)})(),y,_,M,v,l)}const C=await A,P=e(y,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),[N,V,F]=O;C!==null&&(P.buffer=C,P.start(0)),P.connect(N);for(let U=0,G=0;U<b.numberOfOutputs;U+=1){const q=V[U];for(let X=0;X<M[U];X+=1)N.connect(q,G+X,X);G+=M[U]}return F}if(D)for(const[C,P]of b.parameters.entries())await i(y,P,T.parameters.get(C));else for(const[C,P]of b.parameters.entries())await f(y,P,T.parameters.get(C));return await p(b,y,T),T};return{render(b,y){o(y,b);const T=S.get(y);return T!==void 0?Promise.resolve(T):w(b,y)}}},pc=(i,t,e,n,s,r,a,o,c,l,u,h,d,f,p,g,m,_,v,S)=>class extends p{constructor(w,b){super(w,b),this._nativeContext=w,this._audioWorklet=i===void 0?void 0:{addModule:(y,T)=>i(this,y,T)}}get audioWorklet(){return this._audioWorklet}createAnalyser(){return new t(this)}createBiquadFilter(){return new s(this)}createBuffer(w,b,y){return new e({length:b,numberOfChannels:w,sampleRate:y})}createBufferSource(){return new n(this)}createChannelMerger(w=6){return new r(this,{numberOfInputs:w})}createChannelSplitter(w=6){return new a(this,{numberOfOutputs:w})}createConstantSource(){return new o(this)}createConvolver(){return new c(this)}createDelay(w=1){return new u(this,{maxDelayTime:w})}createDynamicsCompressor(){return new h(this)}createGain(){return new d(this)}createIIRFilter(w,b){return new f(this,{feedback:b,feedforward:w})}createOscillator(){return new g(this)}createPanner(){return new m(this)}createPeriodicWave(w,b,y={disableNormalization:!1}){return new _(this,j(k({},y),{imag:b,real:w}))}createStereoPanner(){return new v(this)}createWaveShaper(){return new S(this)}decodeAudioData(w,b,y){return l(this._nativeContext,w).then(T=>(typeof b=="function"&&b(T),T),T=>{throw typeof y=="function"&&y(T),T})}},mc={Q:1,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:350,gain:0,type:"lowpass"},gc=(i,t,e,n,s,r,a,o)=>class extends i{constructor(l,u){const h=r(l),d=k(k({},mc),u),f=s(h,d),p=a(h),g=p?e():null;super(l,!1,f,g),this._Q=t(this,p,f.Q,Dt,Lt),this._detune=t(this,p,f.detune,1200*Math.log2(Dt),-1200*Math.log2(Dt)),this._frequency=t(this,p,f.frequency,l.sampleRate/2,0),this._gain=t(this,p,f.gain,40*Math.log10(Dt),Lt),this._nativeBiquadFilterNode=f,o(this,1)}get detune(){return this._detune}get frequency(){return this._frequency}get gain(){return this._gain}get Q(){return this._Q}get type(){return this._nativeBiquadFilterNode.type}set type(l){this._nativeBiquadFilterNode.type=l}getFrequencyResponse(l,u,h){try{this._nativeBiquadFilterNode.getFrequencyResponse(l,u,h)}catch(d){throw d.code===11?n():d}if(l.length!==u.length||u.length!==h.length)throw n()}},_c=(i,t,e,n,s)=>()=>{const r=new WeakMap,a=async(o,c)=>{let l=e(o);const u=Ot(l,c);if(!u){const h={Q:l.Q.value,channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,detune:l.detune.value,frequency:l.frequency.value,gain:l.gain.value,type:l.type};l=t(c,h)}return r.set(c,l),u?(await i(c,o.Q,l.Q),await i(c,o.detune,l.detune),await i(c,o.frequency,l.frequency),await i(c,o.gain,l.gain)):(await n(c,o.Q,l.Q),await n(c,o.detune,l.detune),await n(c,o.frequency,l.frequency),await n(c,o.gain,l.gain)),await s(o,c,l),l};return{render(o,c){const l=r.get(c);return l!==void 0?Promise.resolve(l):a(o,c)}}},yc=(i,t)=>(e,n)=>{const s=t.get(e);if(s!==void 0)return s;const r=i.get(e);if(r!==void 0)return r;try{const a=n();return a instanceof Promise?(i.set(e,a),a.catch(()=>!1).then(o=>(i.delete(e),t.set(e,o),o))):(t.set(e,a),a)}catch{return t.set(e,!1),!1}},vc={channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6},wc=(i,t,e,n,s)=>class extends i{constructor(a,o){const c=n(a),l=k(k({},vc),o),u=e(c,l),h=s(c)?t():null;super(a,!1,u,h)}},bc=(i,t,e)=>()=>{const n=new WeakMap,s=async(r,a)=>{let o=t(r);if(!Ot(o,a)){const l={channelCount:o.channelCount,channelCountMode:o.channelCountMode,channelInterpretation:o.channelInterpretation,numberOfInputs:o.numberOfInputs};o=i(a,l)}return n.set(a,o),await e(r,a,o),o};return{render(r,a){const o=n.get(a);return o!==void 0?Promise.resolve(o):s(r,a)}}},Tc={channelCount:6,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:6},Ec=(i,t,e,n,s,r)=>class extends i{constructor(o,c){const l=n(o),u=r(k(k({},Tc),c)),h=e(l,u),d=s(l)?t():null;super(o,!1,h,d)}},Sc=(i,t,e)=>()=>{const n=new WeakMap,s=async(r,a)=>{let o=t(r);if(!Ot(o,a)){const l={channelCount:o.channelCount,channelCountMode:o.channelCountMode,channelInterpretation:o.channelInterpretation,numberOfOutputs:o.numberOfOutputs};o=i(a,l)}return n.set(a,o),await e(r,a,o),o};return{render(r,a){const o=n.get(a);return o!==void 0?Promise.resolve(o):s(r,a)}}},Nc=i=>(t,e,n)=>i(e,t,n),xc=i=>(t,e,n=0,s=0)=>{const r=t[n];if(r===void 0)throw i();return Ss(e)?r.connect(e,0,s):r.connect(e,0)},Ac=i=>(t,e)=>{const n=i(t,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),s=t.createBuffer(1,2,44100);return n.buffer=s,n.loop=!0,n.connect(e),n.start(),()=>{n.stop(),n.disconnect(e)}},Cc={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",offset:1},Mc=(i,t,e,n,s,r,a)=>class extends i{constructor(c,l){const u=s(c),h=k(k({},Cc),l),d=n(u,h),f=r(u),p=f?e():null;super(c,!1,d,p),this._constantSourceNodeRenderer=p,this._nativeConstantSourceNode=d,this._offset=t(this,f,d.offset,Dt,Lt),this._onended=null}get offset(){return this._offset}get onended(){return this._onended}set onended(c){const l=typeof c=="function"?a(this,c):null;this._nativeConstantSourceNode.onended=l;const u=this._nativeConstantSourceNode.onended;this._onended=u!==null&&u===l?c:u}start(c=0){if(this._nativeConstantSourceNode.start(c),this._constantSourceNodeRenderer!==null&&(this._constantSourceNodeRenderer.start=c),this.context.state!=="closed"){mn(this);const l=()=>{this._nativeConstantSourceNode.removeEventListener("ended",l),ge(this)&&Jn(this)};this._nativeConstantSourceNode.addEventListener("ended",l)}}stop(c=0){this._nativeConstantSourceNode.stop(c),this._constantSourceNodeRenderer!==null&&(this._constantSourceNodeRenderer.stop=c)}},Ic=(i,t,e,n,s)=>()=>{const r=new WeakMap;let a=null,o=null;const c=async(l,u)=>{let h=e(l);const d=Ot(h,u);if(!d){const f={channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,offset:h.offset.value};h=t(u,f),a!==null&&h.start(a),o!==null&&h.stop(o)}return r.set(u,h),d?await i(u,l.offset,h.offset):await n(u,l.offset,h.offset),await s(l,u,h),h};return{set start(l){a=l},set stop(l){o=l},render(l,u){const h=r.get(u);return h!==void 0?Promise.resolve(h):c(l,u)}}},Oc=i=>t=>(i[0]=t,i[0]),kc={buffer:null,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",disableNormalization:!1},Dc=(i,t,e,n,s,r)=>class extends i{constructor(o,c){const l=n(o),u=k(k({},kc),c),h=e(l,u),f=s(l)?t():null;super(o,!1,h,f),this._isBufferNullified=!1,this._nativeConvolverNode=h,u.buffer!==null&&r(this,u.buffer.duration)}get buffer(){return this._isBufferNullified?null:this._nativeConvolverNode.buffer}set buffer(o){if(this._nativeConvolverNode.buffer=o,o===null&&this._nativeConvolverNode.buffer!==null){const c=this._nativeConvolverNode.context;this._nativeConvolverNode.buffer=c.createBuffer(1,1,44100),this._isBufferNullified=!0,r(this,0)}else this._isBufferNullified=!1,r(this,this._nativeConvolverNode.buffer===null?0:this._nativeConvolverNode.buffer.duration)}get normalize(){return this._nativeConvolverNode.normalize}set normalize(o){this._nativeConvolverNode.normalize=o}},Rc=(i,t,e)=>()=>{const n=new WeakMap,s=async(r,a)=>{let o=t(r);if(!Ot(o,a)){const l={buffer:o.buffer,channelCount:o.channelCount,channelCountMode:o.channelCountMode,channelInterpretation:o.channelInterpretation,disableNormalization:!o.normalize};o=i(a,l)}return n.set(a,o),yn(o)?await e(r,a,o.inputs[0]):await e(r,a,o),o};return{render(r,a){const o=n.get(a);return o!==void 0?Promise.resolve(o):s(r,a)}}},Pc=(i,t)=>(e,n,s)=>{if(t===null)throw new Error("Missing the native OfflineAudioContext constructor.");try{return new t(e,n,s)}catch(r){throw r.name==="SyntaxError"?i():r}},Lc=()=>new DOMException("","DataCloneError"),fr=i=>{const{port1:t,port2:e}=new MessageChannel;return new Promise(n=>{const s=()=>{e.onmessage=null,t.close(),e.close(),n()};e.onmessage=()=>s();try{t.postMessage(i,[i])}finally{s()}})},Fc=(i,t,e,n,s,r,a,o,c,l,u)=>(h,d)=>{const f=a(h)?h:r(h);if(s.has(d)){const p=e();return Promise.reject(p)}try{s.add(d)}catch{}return t(c,()=>c(f))?f.decodeAudioData(d).then(p=>(fr(d).catch(()=>{}),t(o,()=>o(p))||u(p),i.add(p),p)):new Promise((p,g)=>{const m=async()=>{try{await fr(d)}catch{}},_=v=>{g(v),m()};try{f.decodeAudioData(d,v=>{typeof v.copyFromChannel!="function"&&(l(v),wi(v)),i.add(v),m().then(()=>p(v))},v=>{_(v===null?n():v)})}catch(v){_(v)}})},Vc=(i,t,e,n,s,r,a,o)=>(c,l)=>{const u=t.get(c);if(u===void 0)throw new Error("Missing the expected cycle count.");const h=r(c.context),d=o(h);if(u===l){if(t.delete(c),!d&&a(c)){const f=n(c),{outputs:p}=e(c);for(const g of p)if(ts(g)){const m=n(g[0]);i(f,m,g[1],g[2])}else{const m=s(g[0]);f.connect(m,g[1])}}}else t.set(c,u-l)},Bc={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",delayTime:0,maxDelayTime:1},zc=(i,t,e,n,s,r,a)=>class extends i{constructor(c,l){const u=s(c),h=k(k({},Bc),l),d=n(u,h),f=r(u),p=f?e(h.maxDelayTime):null;super(c,!1,d,p),this._delayTime=t(this,f,d.delayTime),a(this,h.maxDelayTime)}get delayTime(){return this._delayTime}},Uc=(i,t,e,n,s)=>r=>{const a=new WeakMap,o=async(c,l)=>{let u=e(c);const h=Ot(u,l);if(!h){const d={channelCount:u.channelCount,channelCountMode:u.channelCountMode,channelInterpretation:u.channelInterpretation,delayTime:u.delayTime.value,maxDelayTime:r};u=t(l,d)}return a.set(l,u),h?await i(l,c.delayTime,u.delayTime):await n(l,c.delayTime,u.delayTime),await s(c,l,u),u};return{render(c,l){const u=a.get(l);return u!==void 0?Promise.resolve(u):o(c,l)}}},qc=i=>(t,e,n,s)=>i(t[s],r=>r[0]===e&&r[1]===n),Wc=i=>(t,e)=>{i(t).delete(e)},jc=i=>"delayTime"in i,Gc=(i,t,e)=>function n(s,r){const a=bs(r)?r:e(i,r);if(jc(a))return[];if(s[0]===a)return[s];if(s.includes(a))return[];const{outputs:o}=t(a);return Array.from(o).map(c=>n([...s,a],c[0])).reduce((c,l)=>c.concat(l),[])},us=(i,t,e)=>{const n=t[e];if(n===void 0)throw i();return n},Hc=i=>(t,e=void 0,n=void 0,s=0)=>e===void 0?t.forEach(r=>r.disconnect()):typeof e=="number"?us(i,t,e).disconnect():Ss(e)?n===void 0?t.forEach(r=>r.disconnect(e)):s===void 0?us(i,t,n).disconnect(e,0):us(i,t,n).disconnect(e,0,s):n===void 0?t.forEach(r=>r.disconnect(e)):us(i,t,n).disconnect(e,0),Yc={attack:.003,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",knee:30,ratio:12,release:.25,threshold:-24},$c=(i,t,e,n,s,r,a,o)=>class extends i{constructor(l,u){const h=r(l),d=k(k({},Yc),u),f=n(h,d),p=a(h),g=p?e():null;super(l,!1,f,g),this._attack=t(this,p,f.attack),this._knee=t(this,p,f.knee),this._nativeDynamicsCompressorNode=f,this._ratio=t(this,p,f.ratio),this._release=t(this,p,f.release),this._threshold=t(this,p,f.threshold),o(this,.006)}get attack(){return this._attack}get channelCount(){return this._nativeDynamicsCompressorNode.channelCount}set channelCount(l){const u=this._nativeDynamicsCompressorNode.channelCount;if(this._nativeDynamicsCompressorNode.channelCount=l,l>2)throw this._nativeDynamicsCompressorNode.channelCount=u,s()}get channelCountMode(){return this._nativeDynamicsCompressorNode.channelCountMode}set channelCountMode(l){const u=this._nativeDynamicsCompressorNode.channelCountMode;if(this._nativeDynamicsCompressorNode.channelCountMode=l,l==="max")throw this._nativeDynamicsCompressorNode.channelCountMode=u,s()}get knee(){return this._knee}get ratio(){return this._ratio}get reduction(){return typeof this._nativeDynamicsCompressorNode.reduction.value=="number"?this._nativeDynamicsCompressorNode.reduction.value:this._nativeDynamicsCompressorNode.reduction}get release(){return this._release}get threshold(){return this._threshold}},Xc=(i,t,e,n,s)=>()=>{const r=new WeakMap,a=async(o,c)=>{let l=e(o);const u=Ot(l,c);if(!u){const h={attack:l.attack.value,channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,knee:l.knee.value,ratio:l.ratio.value,release:l.release.value,threshold:l.threshold.value};l=t(c,h)}return r.set(c,l),u?(await i(c,o.attack,l.attack),await i(c,o.knee,l.knee),await i(c,o.ratio,l.ratio),await i(c,o.release,l.release),await i(c,o.threshold,l.threshold)):(await n(c,o.attack,l.attack),await n(c,o.knee,l.knee),await n(c,o.ratio,l.ratio),await n(c,o.release,l.release),await n(c,o.threshold,l.threshold)),await s(o,c,l),l};return{render(o,c){const l=r.get(c);return l!==void 0?Promise.resolve(l):a(o,c)}}},Zc=()=>new DOMException("","EncodingError"),Kc=i=>t=>new Promise((e,n)=>{if(i===null){n(new SyntaxError);return}const s=i.document.head;if(s===null)n(new SyntaxError);else{const r=i.document.createElement("script"),a=new Blob([t],{type:"application/javascript"}),o=URL.createObjectURL(a),c=i.onerror,l=()=>{i.onerror=c,URL.revokeObjectURL(o)};i.onerror=(u,h,d,f,p)=>{if(h===o||h===i.location.href&&d===1&&f===1)return l(),n(p),!1;if(c!==null)return c(u,h,d,f,p)},r.onerror=()=>{l(),n(new SyntaxError)},r.onload=()=>{l(),e()},r.src=o,r.type="module",s.appendChild(r)}}),Jc=i=>class{constructor(e){this._nativeEventTarget=e,this._listeners=new WeakMap}addEventListener(e,n,s){if(n!==null){let r=this._listeners.get(n);r===void 0&&(r=i(this,n),typeof n=="function"&&this._listeners.set(n,r)),this._nativeEventTarget.addEventListener(e,r,s)}}dispatchEvent(e){return this._nativeEventTarget.dispatchEvent(e)}removeEventListener(e,n,s){const r=n===null?void 0:this._listeners.get(n);this._nativeEventTarget.removeEventListener(e,r===void 0?null:r,s)}},Qc=i=>(t,e,n)=>{Object.defineProperties(i,{currentFrame:{configurable:!0,get(){return Math.round(t*e)}},currentTime:{configurable:!0,get(){return t}}});try{return n()}finally{i!==null&&(delete i.currentFrame,delete i.currentTime)}},tl=i=>async t=>{try{const e=await fetch(t);if(e.ok)return[await e.text(),e.url]}catch{}throw i()},el={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",gain:1},nl=(i,t,e,n,s,r)=>class extends i{constructor(o,c){const l=s(o),u=k(k({},el),c),h=n(l,u),d=r(l),f=d?e():null;super(o,!1,h,f),this._gain=t(this,d,h.gain,Dt,Lt)}get gain(){return this._gain}},sl=(i,t,e,n,s)=>()=>{const r=new WeakMap,a=async(o,c)=>{let l=e(o);const u=Ot(l,c);if(!u){const h={channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,gain:l.gain.value};l=t(c,h)}return r.set(c,l),u?await i(c,o.gain,l.gain):await n(c,o.gain,l.gain),await s(o,c,l),l};return{render(o,c){const l=r.get(c);return l!==void 0?Promise.resolve(l):a(o,c)}}},il=(i,t)=>e=>t(i,e),rl=i=>t=>{const e=i(t);if(e.renderer===null)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return e.renderer},al=i=>t=>{var e;return(e=i.get(t))!==null&&e!==void 0?e:0},ol=i=>t=>{const e=i(t);if(e.renderer===null)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return e.renderer},cl=i=>t=>i.get(t),At=()=>new DOMException("","InvalidStateError"),ll=i=>t=>{const e=i.get(t);if(e===void 0)throw At();return e},ul=(i,t)=>e=>{let n=i.get(e);if(n!==void 0)return n;if(t===null)throw new Error("Missing the native OfflineAudioContext constructor.");return n=new t(1,1,44100),i.set(e,n),n},hl=i=>t=>{const e=i.get(t);if(e===void 0)throw new Error("The context has no set of AudioWorkletNodes.");return e},Us=()=>new DOMException("","InvalidAccessError"),dl=i=>{i.getFrequencyResponse=(t=>(e,n,s)=>{if(e.length!==n.length||n.length!==s.length)throw Us();return t.call(i,e,n,s)})(i.getFrequencyResponse)},fl={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers"},pl=(i,t,e,n,s,r)=>class extends i{constructor(o,c){const l=n(o),u=s(l),h=k(k({},fl),c),d=t(l,u?null:o.baseLatency,h),f=u?e(h.feedback,h.feedforward):null;super(o,!1,d,f),dl(d),this._nativeIIRFilterNode=d,r(this,1)}getFrequencyResponse(o,c,l){return this._nativeIIRFilterNode.getFrequencyResponse(o,c,l)}},Wr=(i,t,e,n,s,r,a,o,c,l,u)=>{const h=l.length;let d=o;for(let f=0;f<h;f+=1){let p=e[0]*l[f];for(let g=1;g<s;g+=1){const m=d-g&c-1;p+=e[g]*r[m],p-=i[g]*a[m]}for(let g=s;g<n;g+=1)p+=e[g]*r[d-g&c-1];for(let g=s;g<t;g+=1)p-=i[g]*a[d-g&c-1];r[d]=l[f],a[d]=p,d=d+1&c-1,u[f]=p}return d},ml=(i,t,e,n)=>{const s=e instanceof Float64Array?e:new Float64Array(e),r=n instanceof Float64Array?n:new Float64Array(n),a=s.length,o=r.length,c=Math.min(a,o);if(s[0]!==1){for(let p=0;p<a;p+=1)r[p]/=s[0];for(let p=1;p<o;p+=1)s[p]/=s[0]}const l=32,u=new Float32Array(l),h=new Float32Array(l),d=t.createBuffer(i.numberOfChannels,i.length,i.sampleRate),f=i.numberOfChannels;for(let p=0;p<f;p+=1){const g=i.getChannelData(p),m=d.getChannelData(p);u.fill(0),h.fill(0),Wr(s,a,r,o,c,u,h,0,l,g,m)}return d},gl=(i,t,e,n,s)=>(r,a)=>{const o=new WeakMap;let c=null;const l=async(u,h)=>{let d=null,f=t(u);const p=Ot(f,h);if(h.createIIRFilter===void 0?d=i(h,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}):p||(f=h.createIIRFilter(a,r)),o.set(h,d===null?f:d),d!==null){if(c===null){if(e===null)throw new Error("Missing the native OfflineAudioContext constructor.");const m=new e(u.context.destination.channelCount,u.context.length,h.sampleRate);c=(async()=>{await n(u,m,m.destination);const _=await s(m);return ml(_,h,r,a)})()}const g=await c;return d.buffer=g,d.start(0),d}return await n(u,h,f),f};return{render(u,h){const d=o.get(h);return d!==void 0?Promise.resolve(d):l(u,h)}}},_l=(i,t,e,n,s,r)=>a=>(o,c)=>{const l=i.get(o);if(l===void 0){if(!a&&r(o)){const u=n(o),{outputs:h}=e(o);for(const d of h)if(ts(d)){const f=n(d[0]);t(u,f,d[1],d[2])}else{const f=s(d[0]);u.disconnect(f,d[1])}}i.set(o,c)}else i.set(o,l+c)},yl=(i,t)=>e=>{const n=i.get(e);return t(n)||t(e)},vl=(i,t)=>e=>i.has(e)||t(e),wl=(i,t)=>e=>i.has(e)||t(e),bl=(i,t)=>e=>{const n=i.get(e);return t(n)||t(e)},Tl=i=>t=>i!==null&&t instanceof i,El=i=>t=>i!==null&&typeof i.AudioNode=="function"&&t instanceof i.AudioNode,Sl=i=>t=>i!==null&&typeof i.AudioParam=="function"&&t instanceof i.AudioParam,Nl=(i,t)=>e=>i(e)||t(e),xl=i=>t=>i!==null&&t instanceof i,Al=i=>i!==null&&i.isSecureContext,Cl=(i,t,e,n)=>class extends i{constructor(r,a){const o=e(r),c=t(o,a);if(n(o))throw TypeError();super(r,!0,c,null),this._nativeMediaElementAudioSourceNode=c}get mediaElement(){return this._nativeMediaElementAudioSourceNode.mediaElement}},Ml={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers"},Il=(i,t,e,n)=>class extends i{constructor(r,a){const o=e(r);if(n(o))throw new TypeError;const c=k(k({},Ml),a),l=t(o,c);super(r,!1,l,null),this._nativeMediaStreamAudioDestinationNode=l}get stream(){return this._nativeMediaStreamAudioDestinationNode.stream}},Ol=(i,t,e,n)=>class extends i{constructor(r,a){const o=e(r),c=t(o,a);if(n(o))throw new TypeError;super(r,!0,c,null),this._nativeMediaStreamAudioSourceNode=c}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}},kl=(i,t,e)=>class extends i{constructor(s,r){const a=e(s),o=t(a,r);super(s,!0,o,null)}},Dl=(i,t,e,n,s,r)=>class extends e{constructor(o,c){super(o),this._nativeContext=o,Bs.set(this,o),n(o)&&s.set(o,new Set),this._destination=new i(this,c),this._listener=t(this,o),this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(o){const c=typeof o=="function"?r(this,o):null;this._nativeContext.onstatechange=c;const l=this._nativeContext.onstatechange;this._onstatechange=l!==null&&l===c?o:l}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}},Fn=i=>{const t=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const e=i.decodeAudioData(t.buffer,()=>{});return e===void 0?!1:(e.catch(()=>{}),!0)}catch{}return!1},Rl=(i,t)=>(e,n,s)=>{const r=new Set;return e.connect=(a=>(o,c=0,l=0)=>{const u=r.size===0;if(t(o))return a.call(e,o,c,l),i(r,[o,c,l],h=>h[0]===o&&h[1]===c&&h[2]===l,!0),u&&n(),o;a.call(e,o,c),i(r,[o,c],h=>h[0]===o&&h[1]===c,!0),u&&n()})(e.connect),e.disconnect=(a=>(o,c,l)=>{const u=r.size>0;if(o===void 0)a.apply(e),r.clear();else if(typeof o=="number"){a.call(e,o);for(const d of r)d[1]===o&&r.delete(d)}else{t(o)?a.call(e,o,c,l):a.call(e,o,c);for(const d of r)d[0]===o&&(c===void 0||d[1]===c)&&(l===void 0||d[2]===l)&&r.delete(d)}const h=r.size===0;u&&h&&s()})(e.disconnect),e},ft=(i,t,e)=>{const n=t[e];n!==void 0&&n!==i[e]&&(i[e]=n)},Nt=(i,t)=>{ft(i,t,"channelCount"),ft(i,t,"channelCountMode"),ft(i,t,"channelInterpretation")},pr=i=>typeof i.getFloatTimeDomainData=="function",Pl=i=>{i.getFloatTimeDomainData=t=>{const e=new Uint8Array(t.length);i.getByteTimeDomainData(e);const n=Math.max(e.length,i.fftSize);for(let s=0;s<n;s+=1)t[s]=(e[s]-128)*.0078125;return t}},Ll=(i,t)=>(e,n)=>{const s=e.createAnalyser();if(Nt(s,n),!(n.maxDecibels>n.minDecibels))throw t();return ft(s,n,"fftSize"),ft(s,n,"maxDecibels"),ft(s,n,"minDecibels"),ft(s,n,"smoothingTimeConstant"),i(pr,()=>pr(s))||Pl(s),s},Fl=i=>i===null?null:i.hasOwnProperty("AudioBuffer")?i.AudioBuffer:null,gt=(i,t,e)=>{const n=t[e];n!==void 0&&n!==i[e].value&&(i[e].value=n)},Vl=i=>{i.start=(t=>{let e=!1;return(n=0,s=0,r)=>{if(e)throw At();t.call(i,n,s,r),e=!0}})(i.start)},Ei=i=>{i.start=(t=>(e=0,n=0,s)=>{if(typeof s=="number"&&s<0||n<0||e<0)throw new RangeError("The parameters can't be negative.");t.call(i,e,n,s)})(i.start)},Si=i=>{i.stop=(t=>(e=0)=>{if(e<0)throw new RangeError("The parameter can't be negative.");t.call(i,e)})(i.stop)},Bl=(i,t,e,n,s,r,a,o,c,l,u)=>(h,d)=>{const f=h.createBufferSource();return Nt(f,d),gt(f,d,"playbackRate"),ft(f,d,"buffer"),ft(f,d,"loop"),ft(f,d,"loopEnd"),ft(f,d,"loopStart"),t(e,()=>e(h))||Vl(f),t(n,()=>n(h))||c(f),t(s,()=>s(h))||l(f,h),t(r,()=>r(h))||Ei(f),t(a,()=>a(h))||u(f,h),t(o,()=>o(h))||Si(f),i(h,f),f},zl=i=>i===null?null:i.hasOwnProperty("AudioContext")?i.AudioContext:i.hasOwnProperty("webkitAudioContext")?i.webkitAudioContext:null,Ul=(i,t)=>(e,n,s)=>{const r=e.destination;if(r.channelCount!==n)try{r.channelCount=n}catch{}s&&r.channelCountMode!=="explicit"&&(r.channelCountMode="explicit"),r.maxChannelCount===0&&Object.defineProperty(r,"maxChannelCount",{value:n});const a=i(e,{channelCount:n,channelCountMode:r.channelCountMode,channelInterpretation:r.channelInterpretation,gain:1});return t(a,"channelCount",o=>()=>o.call(a),o=>c=>{o.call(a,c);try{r.channelCount=c}catch(l){if(c>r.maxChannelCount)throw l}}),t(a,"channelCountMode",o=>()=>o.call(a),o=>c=>{o.call(a,c),r.channelCountMode=c}),t(a,"channelInterpretation",o=>()=>o.call(a),o=>c=>{o.call(a,c),r.channelInterpretation=c}),Object.defineProperty(a,"maxChannelCount",{get:()=>r.maxChannelCount}),a.connect(r),a},ql=i=>i===null?null:i.hasOwnProperty("AudioWorkletNode")?i.AudioWorkletNode:null,Wl=i=>{const{port1:t}=new MessageChannel;try{t.postMessage(i)}finally{t.close()}},jl=(i,t,e,n,s)=>(r,a,o,c,l,u)=>{if(o!==null)try{const h=new o(r,c,u),d=new Map;let f=null;if(Object.defineProperties(h,{channelCount:{get:()=>u.channelCount,set:()=>{throw i()}},channelCountMode:{get:()=>"explicit",set:()=>{throw i()}},onprocessorerror:{get:()=>f,set:p=>{typeof f=="function"&&h.removeEventListener("processorerror",f),f=typeof p=="function"?p:null,typeof f=="function"&&h.addEventListener("processorerror",f)}}}),h.addEventListener=(p=>(...g)=>{if(g[0]==="processorerror"){const m=typeof g[1]=="function"?g[1]:typeof g[1]=="object"&&g[1]!==null&&typeof g[1].handleEvent=="function"?g[1].handleEvent:null;if(m!==null){const _=d.get(g[1]);_!==void 0?g[1]=_:(g[1]=v=>{v.type==="error"?(Object.defineProperties(v,{type:{value:"processorerror"}}),m(v)):m(new ErrorEvent(g[0],k({},v)))},d.set(m,g[1]))}}return p.call(h,"error",g[1],g[2]),p.call(h,...g)})(h.addEventListener),h.removeEventListener=(p=>(...g)=>{if(g[0]==="processorerror"){const m=d.get(g[1]);m!==void 0&&(d.delete(g[1]),g[1]=m)}return p.call(h,"error",g[1],g[2]),p.call(h,g[0],g[1],g[2])})(h.removeEventListener),u.numberOfOutputs!==0){const p=e(r,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return h.connect(p).connect(r.destination),s(h,()=>p.disconnect(),()=>p.connect(r.destination))}return h}catch(h){throw h.code===11?n():h}if(l===void 0)throw n();return Wl(u),t(r,a,l,u)},jr=(i,t)=>i===null?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(i*t))))),Gl=i=>new Promise((t,e)=>{const{port1:n,port2:s}=new MessageChannel;n.onmessage=({data:r})=>{n.close(),s.close(),t(r)},n.onmessageerror=({data:r})=>{n.close(),s.close(),e(r)},s.postMessage(i)}),Hl=async(i,t)=>{const e=await Gl(t);return new i(e)},Yl=(i,t,e,n)=>{let s=ci.get(i);s===void 0&&(s=new WeakMap,ci.set(i,s));const r=Hl(e,n);return s.set(t,r),r},$l=(i,t,e,n,s,r,a,o,c,l,u,h,d)=>(f,p,g,m)=>{if(m.numberOfInputs===0&&m.numberOfOutputs===0)throw c();const _=Array.isArray(m.outputChannelCount)?m.outputChannelCount:Array.from(m.outputChannelCount);if(_.some(z=>z<1))throw c();if(_.length!==m.numberOfOutputs)throw t();if(m.channelCountMode!=="explicit")throw c();const v=m.channelCount*m.numberOfInputs,S=_.reduce((z,H)=>z+H,0),A=g.parameterDescriptors===void 0?0:g.parameterDescriptors.length;if(v+A>6||S>6)throw c();const w=new MessageChannel,b=[],y=[];for(let z=0;z<m.numberOfInputs;z+=1)b.push(a(f,{channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation,gain:1})),y.push(s(f,{channelCount:m.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:m.channelCount}));const T=[];if(g.parameterDescriptors!==void 0)for(const{defaultValue:z,maxValue:H,minValue:St,name:pt}of g.parameterDescriptors){const et=r(f,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:m.parameterData[pt]!==void 0?m.parameterData[pt]:z===void 0?0:z});Object.defineProperties(et.offset,{defaultValue:{get:()=>z===void 0?0:z},maxValue:{get:()=>H===void 0?Dt:H},minValue:{get:()=>St===void 0?Lt:St}}),T.push(et)}const O=n(f,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,v+A)}),D=jr(p,f.sampleRate),M=o(f,D,v+A,Math.max(1,S)),C=s(f,{channelCount:Math.max(1,S),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,S)}),P=[];for(let z=0;z<m.numberOfOutputs;z+=1)P.push(n(f,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:_[z]}));for(let z=0;z<m.numberOfInputs;z+=1){b[z].connect(y[z]);for(let H=0;H<m.channelCount;H+=1)y[z].connect(O,H,z*m.channelCount+H)}const N=new Ur(g.parameterDescriptors===void 0?[]:g.parameterDescriptors.map(({name:z},H)=>{const St=T[H];return St.connect(O,0,v+H),St.start(0),[z,St.offset]}));O.connect(M);let V=m.channelInterpretation,F=null;const U=m.numberOfOutputs===0?[M]:P,G={get bufferSize(){return D},get channelCount(){return m.channelCount},set channelCount(z){throw e()},get channelCountMode(){return m.channelCountMode},set channelCountMode(z){throw e()},get channelInterpretation(){return V},set channelInterpretation(z){for(const H of b)H.channelInterpretation=z;V=z},get context(){return M.context},get inputs(){return b},get numberOfInputs(){return m.numberOfInputs},get numberOfOutputs(){return m.numberOfOutputs},get onprocessorerror(){return F},set onprocessorerror(z){typeof F=="function"&&G.removeEventListener("processorerror",F),F=typeof z=="function"?z:null,typeof F=="function"&&G.addEventListener("processorerror",F)},get parameters(){return N},get port(){return w.port2},addEventListener(...z){return M.addEventListener(z[0],z[1],z[2])},connect:i.bind(null,U),disconnect:l.bind(null,U),dispatchEvent(...z){return M.dispatchEvent(z[0])},removeEventListener(...z){return M.removeEventListener(z[0],z[1],z[2])}},q=new Map;w.port1.addEventListener=(z=>(...H)=>{if(H[0]==="message"){const St=typeof H[1]=="function"?H[1]:typeof H[1]=="object"&&H[1]!==null&&typeof H[1].handleEvent=="function"?H[1].handleEvent:null;if(St!==null){const pt=q.get(H[1]);pt!==void 0?H[1]=pt:(H[1]=et=>{u(f.currentTime,f.sampleRate,()=>St(et))},q.set(St,H[1]))}}return z.call(w.port1,H[0],H[1],H[2])})(w.port1.addEventListener),w.port1.removeEventListener=(z=>(...H)=>{if(H[0]==="message"){const St=q.get(H[1]);St!==void 0&&(q.delete(H[1]),H[1]=St)}return z.call(w.port1,H[0],H[1],H[2])})(w.port1.removeEventListener);let X=null;Object.defineProperty(w.port1,"onmessage",{get:()=>X,set:z=>{typeof X=="function"&&w.port1.removeEventListener("message",X),X=typeof z=="function"?z:null,typeof X=="function"&&(w.port1.addEventListener("message",X),w.port1.start())}}),g.prototype.port=w.port1;let J=null;Yl(f,G,g,m).then(z=>J=z);const vt=xs(m.numberOfInputs,m.channelCount),zt=xs(m.numberOfOutputs,_),Ut=g.parameterDescriptors===void 0?[]:g.parameterDescriptors.reduce((z,{name:H})=>j(k({},z),{[H]:new Float32Array(128)}),{});let nt=!0;const Y=()=>{m.numberOfOutputs>0&&M.disconnect(C);for(let z=0,H=0;z<m.numberOfOutputs;z+=1){const St=P[z];for(let pt=0;pt<_[z];pt+=1)C.disconnect(St,H+pt,pt);H+=_[z]}},Qe=new Map;M.onaudioprocess=({inputBuffer:z,outputBuffer:H})=>{if(J!==null){const St=h(G);for(let pt=0;pt<D;pt+=128){for(let et=0;et<m.numberOfInputs;et+=1)for(let mt=0;mt<m.channelCount;mt+=1)Ns(z,vt[et],mt,mt,pt);g.parameterDescriptors!==void 0&&g.parameterDescriptors.forEach(({name:et},mt)=>{Ns(z,Ut,et,v+mt,pt)});for(let et=0;et<m.numberOfInputs;et+=1)for(let mt=0;mt<_[et];mt+=1)zt[et][mt].byteLength===0&&(zt[et][mt]=new Float32Array(128));try{const et=vt.map((jt,Te)=>{if(St[Te].size>0)return Qe.set(Te,D/128),jt;const Js=Qe.get(Te);return Js===void 0?[]:(jt.every(Ya=>Ya.every($a=>$a===0))&&(Js===1?Qe.delete(Te):Qe.set(Te,Js-1)),jt)});nt=u(f.currentTime+pt/f.sampleRate,f.sampleRate,()=>J.process(et,zt,Ut));for(let jt=0,Te=0;jt<m.numberOfOutputs;jt+=1){for(let Mn=0;Mn<_[jt];Mn+=1)qr(H,zt[jt],Mn,Te+Mn,pt);Te+=_[jt]}}catch(et){nt=!1,G.dispatchEvent(new ErrorEvent("processorerror",{colno:et.colno,filename:et.filename,lineno:et.lineno,message:et.message}))}if(!nt){for(let et=0;et<m.numberOfInputs;et+=1){b[et].disconnect(y[et]);for(let mt=0;mt<m.channelCount;mt+=1)y[pt].disconnect(O,mt,et*m.channelCount+mt)}if(g.parameterDescriptors!==void 0){const et=g.parameterDescriptors.length;for(let mt=0;mt<et;mt+=1){const jt=T[mt];jt.disconnect(O,0,v+mt),jt.stop()}}O.disconnect(M),M.onaudioprocess=null,xn?Y():en();break}}}};let xn=!1;const W=a(f,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0}),tn=()=>M.connect(W).connect(f.destination),en=()=>{M.disconnect(W),W.disconnect()},An=()=>{if(nt){en(),m.numberOfOutputs>0&&M.connect(C);for(let z=0,H=0;z<m.numberOfOutputs;z+=1){const St=P[z];for(let pt=0;pt<_[z];pt+=1)C.connect(St,H+pt,pt);H+=_[z]}}xn=!0},Cn=()=>{nt&&(tn(),Y()),xn=!1};return tn(),d(G,An,Cn)},Gr=(i,t)=>{const e=i.createBiquadFilter();return Nt(e,t),gt(e,t,"Q"),gt(e,t,"detune"),gt(e,t,"frequency"),gt(e,t,"gain"),ft(e,t,"type"),e},Xl=(i,t)=>(e,n)=>{const s=e.createChannelMerger(n.numberOfInputs);return i!==null&&i.name==="webkitAudioContext"&&t(e,s),Nt(s,n),s},Zl=i=>{const t=i.numberOfOutputs;Object.defineProperty(i,"channelCount",{get:()=>t,set:e=>{if(e!==t)throw At()}}),Object.defineProperty(i,"channelCountMode",{get:()=>"explicit",set:e=>{if(e!=="explicit")throw At()}}),Object.defineProperty(i,"channelInterpretation",{get:()=>"discrete",set:e=>{if(e!=="discrete")throw At()}})},es=(i,t)=>{const e=i.createChannelSplitter(t.numberOfOutputs);return Nt(e,t),Zl(e),e},Kl=(i,t,e,n,s)=>(r,a)=>{if(r.createConstantSource===void 0)return e(r,a);const o=r.createConstantSource();return Nt(o,a),gt(o,a,"offset"),t(n,()=>n(r))||Ei(o),t(s,()=>s(r))||Si(o),i(r,o),o},vn=(i,t)=>(i.connect=t.connect.bind(t),i.disconnect=t.disconnect.bind(t),i),Jl=(i,t,e,n)=>(s,o)=>{var c=o,{offset:r}=c,a=In(c,["offset"]);const l=s.createBuffer(1,2,44100),u=t(s,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),h=e(s,j(k({},a),{gain:r})),d=l.getChannelData(0);d[0]=1,d[1]=1,u.buffer=l,u.loop=!0;const f={get bufferSize(){},get channelCount(){return h.channelCount},set channelCount(m){h.channelCount=m},get channelCountMode(){return h.channelCountMode},set channelCountMode(m){h.channelCountMode=m},get channelInterpretation(){return h.channelInterpretation},set channelInterpretation(m){h.channelInterpretation=m},get context(){return h.context},get inputs(){return[]},get numberOfInputs(){return u.numberOfInputs},get numberOfOutputs(){return h.numberOfOutputs},get offset(){return h.gain},get onended(){return u.onended},set onended(m){u.onended=m},addEventListener(...m){return u.addEventListener(m[0],m[1],m[2])},dispatchEvent(...m){return u.dispatchEvent(m[0])},removeEventListener(...m){return u.removeEventListener(m[0],m[1],m[2])},start(m=0){u.start.call(u,m)},stop(m=0){u.stop.call(u,m)}},p=()=>u.connect(h),g=()=>u.disconnect(h);return i(s,u),n(vn(f,h),p,g)},Ql=(i,t)=>(e,n)=>{const s=e.createConvolver();if(Nt(s,n),n.disableNormalization===s.normalize&&(s.normalize=!n.disableNormalization),ft(s,n,"buffer"),n.channelCount>2||(t(s,"channelCount",r=>()=>r.call(s),r=>a=>{if(a>2)throw i();return r.call(s,a)}),n.channelCountMode==="max"))throw i();return t(s,"channelCountMode",r=>()=>r.call(s),r=>a=>{if(a==="max")throw i();return r.call(s,a)}),s},Hr=(i,t)=>{const e=i.createDelay(t.maxDelayTime);return Nt(e,t),gt(e,t,"delayTime"),e},tu=i=>(t,e)=>{const n=t.createDynamicsCompressor();if(Nt(n,e),e.channelCount>2||e.channelCountMode==="max")throw i();return gt(n,e,"attack"),gt(n,e,"knee"),gt(n,e,"ratio"),gt(n,e,"release"),gt(n,e,"threshold"),n},Bt=(i,t)=>{const e=i.createGain();return Nt(e,t),gt(e,t,"gain"),e},eu=i=>(t,e,n)=>{if(t.createIIRFilter===void 0)return i(t,e,n);const s=t.createIIRFilter(n.feedforward,n.feedback);return Nt(s,n),s};function nu(i,t){const e=t[0]*t[0]+t[1]*t[1];return[(i[0]*t[0]+i[1]*t[1])/e,(i[1]*t[0]-i[0]*t[1])/e]}function su(i,t){return[i[0]*t[0]-i[1]*t[1],i[0]*t[1]+i[1]*t[0]]}function mr(i,t){let e=[0,0];for(let n=i.length-1;n>=0;n-=1)e=su(e,t),e[0]+=i[n];return e}const iu=(i,t,e,n)=>(s,r,{channelCount:a,channelCountMode:o,channelInterpretation:c,feedback:l,feedforward:u})=>{const h=jr(r,s.sampleRate),d=l instanceof Float64Array?l:new Float64Array(l),f=u instanceof Float64Array?u:new Float64Array(u),p=d.length,g=f.length,m=Math.min(p,g);if(p===0||p>20)throw n();if(d[0]===0)throw t();if(g===0||g>20)throw n();if(f[0]===0)throw t();if(d[0]!==1){for(let T=0;T<g;T+=1)f[T]/=d[0];for(let T=1;T<p;T+=1)d[T]/=d[0]}const _=e(s,h,a,a);_.channelCount=a,_.channelCountMode=o,_.channelInterpretation=c;const v=32,S=[],A=[],w=[];for(let T=0;T<a;T+=1){S.push(0);const O=new Float32Array(v),D=new Float32Array(v);O.fill(0),D.fill(0),A.push(O),w.push(D)}_.onaudioprocess=T=>{const O=T.inputBuffer,D=T.outputBuffer,M=O.numberOfChannels;for(let C=0;C<M;C+=1){const P=O.getChannelData(C),N=D.getChannelData(C);S[C]=Wr(d,p,f,g,m,A[C],w[C],S[C],v,P,N)}};const b=s.sampleRate/2;return vn({get bufferSize(){return h},get channelCount(){return _.channelCount},set channelCount(T){_.channelCount=T},get channelCountMode(){return _.channelCountMode},set channelCountMode(T){_.channelCountMode=T},get channelInterpretation(){return _.channelInterpretation},set channelInterpretation(T){_.channelInterpretation=T},get context(){return _.context},get inputs(){return[_]},get numberOfInputs(){return _.numberOfInputs},get numberOfOutputs(){return _.numberOfOutputs},addEventListener(...T){return _.addEventListener(T[0],T[1],T[2])},dispatchEvent(...T){return _.dispatchEvent(T[0])},getFrequencyResponse(T,O,D){if(T.length!==O.length||O.length!==D.length)throw i();const M=T.length;for(let C=0;C<M;C+=1){const P=-Math.PI*(T[C]/b),N=[Math.cos(P),Math.sin(P)],V=mr(f,N),F=mr(d,N),U=nu(V,F);O[C]=Math.sqrt(U[0]*U[0]+U[1]*U[1]),D[C]=Math.atan2(U[1],U[0])}},removeEventListener(...T){return _.removeEventListener(T[0],T[1],T[2])}},_)},ru=(i,t)=>i.createMediaElementSource(t.mediaElement),au=(i,t)=>{const e=i.createMediaStreamDestination();return Nt(e,t),e.numberOfOutputs===1&&Object.defineProperty(e,"numberOfOutputs",{get:()=>0}),e},ou=(i,{mediaStream:t})=>{const e=t.getAudioTracks();e.sort((r,a)=>r.id<a.id?-1:r.id>a.id?1:0);const n=e.slice(0,1),s=i.createMediaStreamSource(new MediaStream(n));return Object.defineProperty(s,"mediaStream",{value:t}),s},cu=(i,t)=>(e,{mediaStreamTrack:n})=>{if(typeof e.createMediaStreamTrackSource=="function")return e.createMediaStreamTrackSource(n);const s=new MediaStream([n]),r=e.createMediaStreamSource(s);if(n.kind!=="audio")throw i();if(t(e))throw new TypeError;return r},lu=i=>i===null?null:i.hasOwnProperty("OfflineAudioContext")?i.OfflineAudioContext:i.hasOwnProperty("webkitOfflineAudioContext")?i.webkitOfflineAudioContext:null,uu=(i,t,e,n,s,r)=>(a,o)=>{const c=a.createOscillator();return Nt(c,o),gt(c,o,"detune"),gt(c,o,"frequency"),o.periodicWave!==void 0?c.setPeriodicWave(o.periodicWave):ft(c,o,"type"),t(e,()=>e(a))||Ei(c),t(n,()=>n(a))||r(c,a),t(s,()=>s(a))||Si(c),i(a,c),c},hu=i=>(t,e)=>{const n=t.createPanner();return n.orientationX===void 0?i(t,e):(Nt(n,e),gt(n,e,"orientationX"),gt(n,e,"orientationY"),gt(n,e,"orientationZ"),gt(n,e,"positionX"),gt(n,e,"positionY"),gt(n,e,"positionZ"),ft(n,e,"coneInnerAngle"),ft(n,e,"coneOuterAngle"),ft(n,e,"coneOuterGain"),ft(n,e,"distanceModel"),ft(n,e,"maxDistance"),ft(n,e,"panningModel"),ft(n,e,"refDistance"),ft(n,e,"rolloffFactor"),n)},du=(i,t,e,n,s,r,a,o,c,l)=>(u,D)=>{var M=D,{coneInnerAngle:h,coneOuterAngle:d,coneOuterGain:f,distanceModel:p,maxDistance:g,orientationX:m,orientationY:_,orientationZ:v,panningModel:S,positionX:A,positionY:w,positionZ:b,refDistance:y,rolloffFactor:T}=M,O=In(M,["coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationX","orientationY","orientationZ","panningModel","positionX","positionY","positionZ","refDistance","rolloffFactor"]);const C=u.createPanner();if(O.channelCount>2||O.channelCountMode==="max")throw a();Nt(C,O);const P={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},N=e(u,j(k({},P),{channelInterpretation:"speakers",numberOfInputs:6})),V=n(u,j(k({},O),{gain:1})),F=n(u,j(k({},P),{gain:1})),U=n(u,j(k({},P),{gain:0})),G=n(u,j(k({},P),{gain:0})),q=n(u,j(k({},P),{gain:0})),X=n(u,j(k({},P),{gain:0})),J=n(u,j(k({},P),{gain:0})),ot=s(u,256,6,1),vt=r(u,j(k({},P),{curve:new Float32Array([1,1]),oversample:"none"}));let zt=[m,_,v],Ut=[A,w,b];const nt=new Float32Array(1);ot.onaudioprocess=({inputBuffer:W})=>{const tn=[c(W,nt,0),c(W,nt,1),c(W,nt,2)];tn.some((An,Cn)=>An!==zt[Cn])&&(C.setOrientation(...tn),zt=tn);const en=[c(W,nt,3),c(W,nt,4),c(W,nt,5)];en.some((An,Cn)=>An!==Ut[Cn])&&(C.setPosition(...en),Ut=en)},Object.defineProperty(U.gain,"defaultValue",{get:()=>0}),Object.defineProperty(G.gain,"defaultValue",{get:()=>0}),Object.defineProperty(q.gain,"defaultValue",{get:()=>0}),Object.defineProperty(X.gain,"defaultValue",{get:()=>0}),Object.defineProperty(J.gain,"defaultValue",{get:()=>0});const Y={get bufferSize(){},get channelCount(){return C.channelCount},set channelCount(W){if(W>2)throw a();V.channelCount=W,C.channelCount=W},get channelCountMode(){return C.channelCountMode},set channelCountMode(W){if(W==="max")throw a();V.channelCountMode=W,C.channelCountMode=W},get channelInterpretation(){return C.channelInterpretation},set channelInterpretation(W){V.channelInterpretation=W,C.channelInterpretation=W},get coneInnerAngle(){return C.coneInnerAngle},set coneInnerAngle(W){C.coneInnerAngle=W},get coneOuterAngle(){return C.coneOuterAngle},set coneOuterAngle(W){C.coneOuterAngle=W},get coneOuterGain(){return C.coneOuterGain},set coneOuterGain(W){if(W<0||W>1)throw t();C.coneOuterGain=W},get context(){return C.context},get distanceModel(){return C.distanceModel},set distanceModel(W){C.distanceModel=W},get inputs(){return[V]},get maxDistance(){return C.maxDistance},set maxDistance(W){if(W<0)throw new RangeError;C.maxDistance=W},get numberOfInputs(){return C.numberOfInputs},get numberOfOutputs(){return C.numberOfOutputs},get orientationX(){return F.gain},get orientationY(){return U.gain},get orientationZ(){return G.gain},get panningModel(){return C.panningModel},set panningModel(W){C.panningModel=W},get positionX(){return q.gain},get positionY(){return X.gain},get positionZ(){return J.gain},get refDistance(){return C.refDistance},set refDistance(W){if(W<0)throw new RangeError;C.refDistance=W},get rolloffFactor(){return C.rolloffFactor},set rolloffFactor(W){if(W<0)throw new RangeError;C.rolloffFactor=W},addEventListener(...W){return V.addEventListener(W[0],W[1],W[2])},dispatchEvent(...W){return V.dispatchEvent(W[0])},removeEventListener(...W){return V.removeEventListener(W[0],W[1],W[2])}};h!==Y.coneInnerAngle&&(Y.coneInnerAngle=h),d!==Y.coneOuterAngle&&(Y.coneOuterAngle=d),f!==Y.coneOuterGain&&(Y.coneOuterGain=f),p!==Y.distanceModel&&(Y.distanceModel=p),g!==Y.maxDistance&&(Y.maxDistance=g),m!==Y.orientationX.value&&(Y.orientationX.value=m),_!==Y.orientationY.value&&(Y.orientationY.value=_),v!==Y.orientationZ.value&&(Y.orientationZ.value=v),S!==Y.panningModel&&(Y.panningModel=S),A!==Y.positionX.value&&(Y.positionX.value=A),w!==Y.positionY.value&&(Y.positionY.value=w),b!==Y.positionZ.value&&(Y.positionZ.value=b),y!==Y.refDistance&&(Y.refDistance=y),T!==Y.rolloffFactor&&(Y.rolloffFactor=T),(zt[0]!==1||zt[1]!==0||zt[2]!==0)&&C.setOrientation(...zt),(Ut[0]!==0||Ut[1]!==0||Ut[2]!==0)&&C.setPosition(...Ut);const Qe=()=>{V.connect(C),i(V,vt,0,0),vt.connect(F).connect(N,0,0),vt.connect(U).connect(N,0,1),vt.connect(G).connect(N,0,2),vt.connect(q).connect(N,0,3),vt.connect(X).connect(N,0,4),vt.connect(J).connect(N,0,5),N.connect(ot).connect(u.destination)},xn=()=>{V.disconnect(C),o(V,vt,0,0),vt.disconnect(F),F.disconnect(N),vt.disconnect(U),U.disconnect(N),vt.disconnect(G),G.disconnect(N),vt.disconnect(q),q.disconnect(N),vt.disconnect(X),X.disconnect(N),vt.disconnect(J),J.disconnect(N),N.disconnect(ot),ot.disconnect(u.destination)};return l(vn(Y,C),Qe,xn)},fu=i=>(t,{disableNormalization:e,imag:n,real:s})=>{const r=n instanceof Float32Array?n:new Float32Array(n),a=s instanceof Float32Array?s:new Float32Array(s),o=t.createPeriodicWave(a,r,{disableNormalization:e});if(Array.from(n).length<2)throw i();return o},ns=(i,t,e,n)=>i.createScriptProcessor(t,e,n),pu=(i,t)=>(e,n)=>{const s=n.channelCountMode;if(s==="clamped-max")throw t();if(e.createStereoPanner===void 0)return i(e,n);const r=e.createStereoPanner();return Nt(r,n),gt(r,n,"pan"),Object.defineProperty(r,"channelCountMode",{get:()=>s,set:a=>{if(a!==s)throw t()}}),r},mu=(i,t,e,n,s,r)=>{const o=new Float32Array([1,1]),c=Math.PI/2,l={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},u=j(k({},l),{oversample:"none"}),h=(p,g,m,_)=>{const v=new Float32Array(16385),S=new Float32Array(16385);for(let O=0;O<16385;O+=1){const D=O/16384*c;v[O]=Math.cos(D),S[O]=Math.sin(D)}const A=e(p,j(k({},l),{gain:0})),w=n(p,j(k({},u),{curve:v})),b=n(p,j(k({},u),{curve:o})),y=e(p,j(k({},l),{gain:0})),T=n(p,j(k({},u),{curve:S}));return{connectGraph(){g.connect(A),g.connect(b.inputs===void 0?b:b.inputs[0]),g.connect(y),b.connect(m),m.connect(w.inputs===void 0?w:w.inputs[0]),m.connect(T.inputs===void 0?T:T.inputs[0]),w.connect(A.gain),T.connect(y.gain),A.connect(_,0,0),y.connect(_,0,1)},disconnectGraph(){g.disconnect(A),g.disconnect(b.inputs===void 0?b:b.inputs[0]),g.disconnect(y),b.disconnect(m),m.disconnect(w.inputs===void 0?w:w.inputs[0]),m.disconnect(T.inputs===void 0?T:T.inputs[0]),w.disconnect(A.gain),T.disconnect(y.gain),A.disconnect(_,0,0),y.disconnect(_,0,1)}}},d=(p,g,m,_)=>{const v=new Float32Array(16385),S=new Float32Array(16385),A=new Float32Array(16385),w=new Float32Array(16385),b=Math.floor(16385/2);for(let U=0;U<16385;U+=1)if(U>b){const G=(U-b)/(16384-b)*c;v[U]=Math.cos(G),S[U]=Math.sin(G),A[U]=0,w[U]=1}else{const G=U/(16384-b)*c;v[U]=1,S[U]=0,A[U]=Math.cos(G),w[U]=Math.sin(G)}const y=t(p,{channelCount:2,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:2}),T=e(p,j(k({},l),{gain:0})),O=n(p,j(k({},u),{curve:v})),D=e(p,j(k({},l),{gain:0})),M=n(p,j(k({},u),{curve:S})),C=n(p,j(k({},u),{curve:o})),P=e(p,j(k({},l),{gain:0})),N=n(p,j(k({},u),{curve:A})),V=e(p,j(k({},l),{gain:0})),F=n(p,j(k({},u),{curve:w}));return{connectGraph(){g.connect(y),g.connect(C.inputs===void 0?C:C.inputs[0]),y.connect(T,0),y.connect(D,0),y.connect(P,1),y.connect(V,1),C.connect(m),m.connect(O.inputs===void 0?O:O.inputs[0]),m.connect(M.inputs===void 0?M:M.inputs[0]),m.connect(N.inputs===void 0?N:N.inputs[0]),m.connect(F.inputs===void 0?F:F.inputs[0]),O.connect(T.gain),M.connect(D.gain),N.connect(P.gain),F.connect(V.gain),T.connect(_,0,0),P.connect(_,0,0),D.connect(_,0,1),V.connect(_,0,1)},disconnectGraph(){g.disconnect(y),g.disconnect(C.inputs===void 0?C:C.inputs[0]),y.disconnect(T,0),y.disconnect(D,0),y.disconnect(P,1),y.disconnect(V,1),C.disconnect(m),m.disconnect(O.inputs===void 0?O:O.inputs[0]),m.disconnect(M.inputs===void 0?M:M.inputs[0]),m.disconnect(N.inputs===void 0?N:N.inputs[0]),m.disconnect(F.inputs===void 0?F:F.inputs[0]),O.disconnect(T.gain),M.disconnect(D.gain),N.disconnect(P.gain),F.disconnect(V.gain),T.disconnect(_,0,0),P.disconnect(_,0,0),D.disconnect(_,0,1),V.disconnect(_,0,1)}}},f=(p,g,m,_,v)=>{if(g===1)return h(p,m,_,v);if(g===2)return d(p,m,_,v);throw s()};return(p,S)=>{var A=S,{channelCount:g,channelCountMode:m,pan:_}=A,v=In(A,["channelCount","channelCountMode","pan"]);if(m==="max")throw s();const w=i(p,j(k({},v),{channelCount:1,channelCountMode:m,numberOfInputs:2})),b=e(p,j(k({},v),{channelCount:g,channelCountMode:m,gain:1})),y=e(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:_});let{connectGraph:T,disconnectGraph:O}=f(p,g,b,y,w);Object.defineProperty(y.gain,"defaultValue",{get:()=>0}),Object.defineProperty(y.gain,"maxValue",{get:()=>1}),Object.defineProperty(y.gain,"minValue",{get:()=>-1});const D={get bufferSize(){},get channelCount(){return b.channelCount},set channelCount(N){b.channelCount!==N&&(M&&O(),{connectGraph:T,disconnectGraph:O}=f(p,N,b,y,w),M&&T()),b.channelCount=N},get channelCountMode(){return b.channelCountMode},set channelCountMode(N){if(N==="clamped-max"||N==="max")throw s();b.channelCountMode=N},get channelInterpretation(){return b.channelInterpretation},set channelInterpretation(N){b.channelInterpretation=N},get context(){return b.context},get inputs(){return[b]},get numberOfInputs(){return b.numberOfInputs},get numberOfOutputs(){return b.numberOfOutputs},get pan(){return y.gain},addEventListener(...N){return b.addEventListener(N[0],N[1],N[2])},dispatchEvent(...N){return b.dispatchEvent(N[0])},removeEventListener(...N){return b.removeEventListener(N[0],N[1],N[2])}};let M=!1;const C=()=>{T(),M=!0},P=()=>{O(),M=!1};return r(vn(D,w),C,P)}},gu=(i,t,e,n,s,r,a)=>(o,c)=>{const l=o.createWaveShaper();if(r!==null&&r.name==="webkitAudioContext"&&o.createGain().gain.automationRate===void 0)return e(o,c);Nt(l,c);const u=c.curve===null||c.curve instanceof Float32Array?c.curve:new Float32Array(c.curve);if(u!==null&&u.length<2)throw t();ft(l,{curve:u},"curve"),ft(l,c,"oversample");let h=null,d=!1;return a(l,"curve",g=>()=>g.call(l),g=>m=>(g.call(l,m),d&&(n(m)&&h===null?h=i(o,l):!n(m)&&h!==null&&(h(),h=null)),m)),s(l,()=>{d=!0,n(l.curve)&&(h=i(o,l))},()=>{d=!1,h!==null&&(h(),h=null)})},_u=(i,t,e,n,s)=>(r,l)=>{var u=l,{curve:a,oversample:o}=u,c=In(u,["curve","oversample"]);const h=r.createWaveShaper(),d=r.createWaveShaper();Nt(h,c),Nt(d,c);const f=e(r,j(k({},c),{gain:1})),p=e(r,j(k({},c),{gain:-1})),g=e(r,j(k({},c),{gain:1})),m=e(r,j(k({},c),{gain:-1}));let _=null,v=!1,S=null;const A={get bufferSize(){},get channelCount(){return h.channelCount},set channelCount(y){f.channelCount=y,p.channelCount=y,h.channelCount=y,g.channelCount=y,d.channelCount=y,m.channelCount=y},get channelCountMode(){return h.channelCountMode},set channelCountMode(y){f.channelCountMode=y,p.channelCountMode=y,h.channelCountMode=y,g.channelCountMode=y,d.channelCountMode=y,m.channelCountMode=y},get channelInterpretation(){return h.channelInterpretation},set channelInterpretation(y){f.channelInterpretation=y,p.channelInterpretation=y,h.channelInterpretation=y,g.channelInterpretation=y,d.channelInterpretation=y,m.channelInterpretation=y},get context(){return h.context},get curve(){return S},set curve(y){if(y!==null&&y.length<2)throw t();if(y===null)h.curve=y,d.curve=y;else{const T=y.length,O=new Float32Array(T+2-T%2),D=new Float32Array(T+2-T%2);O[0]=y[0],D[0]=-y[T-1];const M=Math.ceil((T+1)/2),C=(T+1)/2-1;for(let P=1;P<M;P+=1){const N=P/M*C,V=Math.floor(N),F=Math.ceil(N);O[P]=V===F?y[V]:(1-(N-V))*y[V]+(1-(F-N))*y[F],D[P]=V===F?-y[T-1-V]:-((1-(N-V))*y[T-1-V])-(1-(F-N))*y[T-1-F]}O[M]=T%2===1?y[M-1]:(y[M-2]+y[M-1])/2,h.curve=O,d.curve=D}S=y,v&&(n(S)&&_===null?_=i(r,f):_!==null&&(_(),_=null))},get inputs(){return[f]},get numberOfInputs(){return h.numberOfInputs},get numberOfOutputs(){return h.numberOfOutputs},get oversample(){return h.oversample},set oversample(y){h.oversample=y,d.oversample=y},addEventListener(...y){return f.addEventListener(y[0],y[1],y[2])},dispatchEvent(...y){return f.dispatchEvent(y[0])},removeEventListener(...y){return f.removeEventListener(y[0],y[1],y[2])}};a!==null&&(A.curve=a instanceof Float32Array?a:new Float32Array(a)),o!==A.oversample&&(A.oversample=o);const w=()=>{f.connect(h).connect(g),f.connect(p).connect(d).connect(m).connect(g),v=!0,n(S)&&(_=i(r,f))},b=()=>{f.disconnect(h),h.disconnect(g),f.disconnect(p),p.disconnect(d),d.disconnect(m),m.disconnect(g),v=!1,_!==null&&(_(),_=null)};return s(vn(A,g),w,b)},Pt=()=>new DOMException("","NotSupportedError"),yu={numberOfChannels:1},vu=(i,t,e,n,s)=>class extends i{constructor(a,o,c){let l;if(typeof a=="number"&&o!==void 0&&c!==void 0)l={length:o,numberOfChannels:a,sampleRate:c};else if(typeof a=="object")l=a;else throw new Error("The given parameters are not valid.");const{length:u,numberOfChannels:h,sampleRate:d}=k(k({},yu),l),f=n(h,u,d);t(Fn,()=>Fn(f))||f.addEventListener("statechange",(()=>{let p=0;const g=m=>{this._state==="running"&&(p>0?(f.removeEventListener("statechange",g),m.stopImmediatePropagation(),this._waitForThePromiseToSettle(m)):p+=1)};return g})()),super(f,h),this._length=u,this._nativeOfflineAudioContext=f,this._state=null}get length(){return this._nativeOfflineAudioContext.length===void 0?this._length:this._nativeOfflineAudioContext.length}get state(){return this._state===null?this._nativeOfflineAudioContext.state:this._state}startRendering(){return this._state==="running"?Promise.reject(e()):(this._state="running",s(this.destination,this._nativeOfflineAudioContext).finally(()=>{this._state=null,Fr(this)}))}_waitForThePromiseToSettle(a){this._state===null?this._nativeOfflineAudioContext.dispatchEvent(a):setTimeout(()=>this._waitForThePromiseToSettle(a))}},wu={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:440,periodicWave:void 0,type:"sine"},bu=(i,t,e,n,s,r,a)=>class extends i{constructor(c,l){const u=s(c),h=k(k({},wu),l),d=e(u,h),f=r(u),p=f?n():null,g=c.sampleRate/2;super(c,!1,d,p),this._detune=t(this,f,d.detune,153600,-153600),this._frequency=t(this,f,d.frequency,g,-g),this._nativeOscillatorNode=d,this._onended=null,this._oscillatorNodeRenderer=p,this._oscillatorNodeRenderer!==null&&h.periodicWave!==void 0&&(this._oscillatorNodeRenderer.periodicWave=h.periodicWave)}get detune(){return this._detune}get frequency(){return this._frequency}get onended(){return this._onended}set onended(c){const l=typeof c=="function"?a(this,c):null;this._nativeOscillatorNode.onended=l;const u=this._nativeOscillatorNode.onended;this._onended=u!==null&&u===l?c:u}get type(){return this._nativeOscillatorNode.type}set type(c){this._nativeOscillatorNode.type=c,this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.periodicWave=null)}setPeriodicWave(c){this._nativeOscillatorNode.setPeriodicWave(c),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.periodicWave=c)}start(c=0){if(this._nativeOscillatorNode.start(c),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.start=c),this.context.state!=="closed"){mn(this);const l=()=>{this._nativeOscillatorNode.removeEventListener("ended",l),ge(this)&&Jn(this)};this._nativeOscillatorNode.addEventListener("ended",l)}}stop(c=0){this._nativeOscillatorNode.stop(c),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.stop=c)}},Tu=(i,t,e,n,s)=>()=>{const r=new WeakMap;let a=null,o=null,c=null;const l=async(u,h)=>{let d=e(u);const f=Ot(d,h);if(!f){const p={channelCount:d.channelCount,channelCountMode:d.channelCountMode,channelInterpretation:d.channelInterpretation,detune:d.detune.value,frequency:d.frequency.value,periodicWave:a===null?void 0:a,type:d.type};d=t(h,p),o!==null&&d.start(o),c!==null&&d.stop(c)}return r.set(h,d),f?(await i(h,u.detune,d.detune),await i(h,u.frequency,d.frequency)):(await n(h,u.detune,d.detune),await n(h,u.frequency,d.frequency)),await s(u,h,d),d};return{set periodicWave(u){a=u},set start(u){o=u},set stop(u){c=u},render(u,h){const d=r.get(h);return d!==void 0?Promise.resolve(d):l(u,h)}}},Eu={channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:1,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1},Su=(i,t,e,n,s,r,a)=>class extends i{constructor(c,l){const u=s(c),h=k(k({},Eu),l),d=e(u,h),f=r(u),p=f?n():null;super(c,!1,d,p),this._nativePannerNode=d,this._orientationX=t(this,f,d.orientationX,Dt,Lt),this._orientationY=t(this,f,d.orientationY,Dt,Lt),this._orientationZ=t(this,f,d.orientationZ,Dt,Lt),this._positionX=t(this,f,d.positionX,Dt,Lt),this._positionY=t(this,f,d.positionY,Dt,Lt),this._positionZ=t(this,f,d.positionZ,Dt,Lt),a(this,1)}get coneInnerAngle(){return this._nativePannerNode.coneInnerAngle}set coneInnerAngle(c){this._nativePannerNode.coneInnerAngle=c}get coneOuterAngle(){return this._nativePannerNode.coneOuterAngle}set coneOuterAngle(c){this._nativePannerNode.coneOuterAngle=c}get coneOuterGain(){return this._nativePannerNode.coneOuterGain}set coneOuterGain(c){this._nativePannerNode.coneOuterGain=c}get distanceModel(){return this._nativePannerNode.distanceModel}set distanceModel(c){this._nativePannerNode.distanceModel=c}get maxDistance(){return this._nativePannerNode.maxDistance}set maxDistance(c){this._nativePannerNode.maxDistance=c}get orientationX(){return this._orientationX}get orientationY(){return this._orientationY}get orientationZ(){return this._orientationZ}get panningModel(){return this._nativePannerNode.panningModel}set panningModel(c){this._nativePannerNode.panningModel=c}get positionX(){return this._positionX}get positionY(){return this._positionY}get positionZ(){return this._positionZ}get refDistance(){return this._nativePannerNode.refDistance}set refDistance(c){this._nativePannerNode.refDistance=c}get rolloffFactor(){return this._nativePannerNode.rolloffFactor}set rolloffFactor(c){this._nativePannerNode.rolloffFactor=c}},Nu=(i,t,e,n,s,r,a,o,c,l)=>()=>{const u=new WeakMap;let h=null;const d=async(f,p)=>{let g=null,m=r(f);const _={channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation},v=j(k({},_),{coneInnerAngle:m.coneInnerAngle,coneOuterAngle:m.coneOuterAngle,coneOuterGain:m.coneOuterGain,distanceModel:m.distanceModel,maxDistance:m.maxDistance,panningModel:m.panningModel,refDistance:m.refDistance,rolloffFactor:m.rolloffFactor}),S=Ot(m,p);if("bufferSize"in m)g=n(p,j(k({},_),{gain:1}));else if(!S){const A=j(k({},v),{orientationX:m.orientationX.value,orientationY:m.orientationY.value,orientationZ:m.orientationZ.value,positionX:m.positionX.value,positionY:m.positionY.value,positionZ:m.positionZ.value});m=s(p,A)}if(u.set(p,g===null?m:g),g!==null){if(h===null){if(a===null)throw new Error("Missing the native OfflineAudioContext constructor.");const M=new a(6,f.context.length,p.sampleRate),C=t(M,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6});C.connect(M.destination),h=(async()=>{const P=await Promise.all([f.orientationX,f.orientationY,f.orientationZ,f.positionX,f.positionY,f.positionZ].map(async(N,V)=>{const F=e(M,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:V===0?1:0});return await o(M,N,F.offset),F}));for(let N=0;N<6;N+=1)P[N].connect(C,0,N),P[N].start(0);return l(M)})()}const A=await h,w=n(p,j(k({},_),{gain:1}));await c(f,p,w);const b=[];for(let M=0;M<A.numberOfChannels;M+=1)b.push(A.getChannelData(M));let y=[b[0][0],b[1][0],b[2][0]],T=[b[3][0],b[4][0],b[5][0]],O=n(p,j(k({},_),{gain:1})),D=s(p,j(k({},v),{orientationX:y[0],orientationY:y[1],orientationZ:y[2],positionX:T[0],positionY:T[1],positionZ:T[2]}));w.connect(O).connect(D.inputs[0]),D.connect(g);for(let M=128;M<A.length;M+=128){const C=[b[0][M],b[1][M],b[2][M]],P=[b[3][M],b[4][M],b[5][M]];if(C.some((N,V)=>N!==y[V])||P.some((N,V)=>N!==T[V])){y=C,T=P;const N=M/p.sampleRate;O.gain.setValueAtTime(0,N),O=n(p,j(k({},_),{gain:0})),D=s(p,j(k({},v),{orientationX:y[0],orientationY:y[1],orientationZ:y[2],positionX:T[0],positionY:T[1],positionZ:T[2]})),O.gain.setValueAtTime(1,N),w.connect(O).connect(D.inputs[0]),D.connect(g)}}return g}return S?(await i(p,f.orientationX,m.orientationX),await i(p,f.orientationY,m.orientationY),await i(p,f.orientationZ,m.orientationZ),await i(p,f.positionX,m.positionX),await i(p,f.positionY,m.positionY),await i(p,f.positionZ,m.positionZ)):(await o(p,f.orientationX,m.orientationX),await o(p,f.orientationY,m.orientationY),await o(p,f.orientationZ,m.orientationZ),await o(p,f.positionX,m.positionX),await o(p,f.positionY,m.positionY),await o(p,f.positionZ,m.positionZ)),yn(m)?await c(f,p,m.inputs[0]):await c(f,p,m),m};return{render(f,p){const g=u.get(p);return g!==void 0?Promise.resolve(g):d(f,p)}}},xu={disableNormalization:!1},Au=(i,t,e,n)=>class Yr{constructor(r,a){const o=t(r),c=n(k(k({},xu),a)),l=i(o,c);return e.add(l),l}static[Symbol.hasInstance](r){return r!==null&&typeof r=="object"&&Object.getPrototypeOf(r)===Yr.prototype||e.has(r)}},Cu=(i,t)=>(e,n,s)=>(i(n).replay(s),t(n,e,s)),Mu=(i,t,e)=>async(n,s,r)=>{const a=i(n);await Promise.all(a.activeInputs.map((o,c)=>Array.from(o).map(async([l,u])=>{const d=await t(l).render(l,s),f=n.context.destination;!e(l)&&(n!==f||!e(n))&&d.connect(r,u,c)})).reduce((o,c)=>[...o,...c],[]))},Iu=(i,t,e)=>async(n,s,r)=>{const a=t(n);await Promise.all(Array.from(a.activeInputs).map(async([o,c])=>{const u=await i(o).render(o,s);e(o)||u.connect(r,c)}))},Ou=(i,t,e,n)=>s=>i(Fn,()=>Fn(s))?Promise.resolve(i(n,n)).then(r=>{if(!r){const a=e(s,512,0,1);s.oncomplete=()=>{a.onaudioprocess=null,a.disconnect()},a.onaudioprocess=()=>s.currentTime,a.connect(s.destination)}return s.startRendering()}):new Promise(r=>{const a=t(s,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});s.oncomplete=o=>{a.disconnect(),r(o.renderedBuffer)},a.connect(s.destination),s.startRendering()}),ku=i=>(t,e)=>{i.set(t,e)},Du=i=>(t,e)=>i.set(t,e),Ru=(i,t,e,n,s,r,a,o)=>(c,l)=>e(c).render(c,l).then(()=>Promise.all(Array.from(n(l)).map(u=>e(u).render(u,l)))).then(()=>s(l)).then(u=>(typeof u.copyFromChannel!="function"?(a(u),wi(u)):t(r,()=>r(u))||o(u),i.add(u),u)),Pu={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",pan:0},Lu=(i,t,e,n,s,r)=>class extends i{constructor(o,c){const l=s(o),u=k(k({},Pu),c),h=e(l,u),d=r(l),f=d?n():null;super(o,!1,h,f),this._pan=t(this,d,h.pan)}get pan(){return this._pan}},Fu=(i,t,e,n,s)=>()=>{const r=new WeakMap,a=async(o,c)=>{let l=e(o);const u=Ot(l,c);if(!u){const h={channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,pan:l.pan.value};l=t(c,h)}return r.set(c,l),u?await i(c,o.pan,l.pan):await n(c,o.pan,l.pan),yn(l)?await s(o,c,l.inputs[0]):await s(o,c,l),l};return{render(o,c){const l=r.get(c);return l!==void 0?Promise.resolve(l):a(o,c)}}},Vu=i=>()=>{if(i===null)return!1;try{new i({length:1,sampleRate:44100})}catch{return!1}return!0},Bu=(i,t)=>async()=>{if(i===null)return!0;if(t===null)return!1;const e=new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),n=new t(1,128,44100),s=URL.createObjectURL(e);let r=!1,a=!1;try{await n.audioWorklet.addModule(s);const o=new i(n,"a",{numberOfOutputs:0}),c=n.createOscillator();o.port.onmessage=()=>r=!0,o.onprocessorerror=()=>a=!0,c.connect(o),c.start(0),await n.startRendering()}catch{}finally{URL.revokeObjectURL(s)}return r&&!a},zu=(i,t)=>()=>{if(t===null)return Promise.resolve(!1);const e=new t(1,1,44100),n=i(e,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise(s=>{e.oncomplete=()=>{n.disconnect(),s(e.currentTime!==0)},e.startRendering()})},Uu=()=>new DOMException("","UnknownError"),qu={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",curve:null,oversample:"none"},Wu=(i,t,e,n,s,r,a)=>class extends i{constructor(c,l){const u=s(c),h=k(k({},qu),l),d=e(u,h),p=r(u)?n():null;super(c,!0,d,p),this._isCurveNullified=!1,this._nativeWaveShaperNode=d,a(this,1)}get curve(){return this._isCurveNullified?null:this._nativeWaveShaperNode.curve}set curve(c){if(c===null)this._isCurveNullified=!0,this._nativeWaveShaperNode.curve=new Float32Array([0,0]);else{if(c.length<2)throw t();this._isCurveNullified=!1,this._nativeWaveShaperNode.curve=c}}get oversample(){return this._nativeWaveShaperNode.oversample}set oversample(c){this._nativeWaveShaperNode.oversample=c}},ju=(i,t,e)=>()=>{const n=new WeakMap,s=async(r,a)=>{let o=t(r);if(!Ot(o,a)){const l={channelCount:o.channelCount,channelCountMode:o.channelCountMode,channelInterpretation:o.channelInterpretation,curve:o.curve,oversample:o.oversample};o=i(a,l)}return n.set(a,o),yn(o)?await e(r,a,o.inputs[0]):await e(r,a,o),o};return{render(r,a){const o=n.get(a);return o!==void 0?Promise.resolve(o):s(r,a)}}},Gu=()=>typeof window=="undefined"?null:window,Hu=(i,t)=>e=>{e.copyFromChannel=(n,s,r=0)=>{const a=i(r),o=i(s);if(o>=e.numberOfChannels)throw t();const c=e.length,l=e.getChannelData(o),u=n.length;for(let h=a<0?-a:0;h+a<c&&h<u;h+=1)n[h]=l[h+a]},e.copyToChannel=(n,s,r=0)=>{const a=i(r),o=i(s);if(o>=e.numberOfChannels)throw t();const c=e.length,l=e.getChannelData(o),u=n.length;for(let h=a<0?-a:0;h+a<c&&h<u;h+=1)l[h+a]=n[h]}},Yu=i=>t=>{t.copyFromChannel=(e=>(n,s,r=0)=>{const a=i(r),o=i(s);if(a<t.length)return e.call(t,n,o,a)})(t.copyFromChannel),t.copyToChannel=(e=>(n,s,r=0)=>{const a=i(r),o=i(s);if(a<t.length)return e.call(t,n,o,a)})(t.copyToChannel)},$u=i=>(t,e)=>{const n=e.createBuffer(1,1,44100);t.buffer===null&&(t.buffer=n),i(t,"buffer",s=>()=>{const r=s.call(t);return r===n?null:r},s=>r=>s.call(t,r===null?n:r))},Xu=(i,t)=>(e,n)=>{n.channelCount=1,n.channelCountMode="explicit",Object.defineProperty(n,"channelCount",{get:()=>1,set:()=>{throw i()}}),Object.defineProperty(n,"channelCountMode",{get:()=>"explicit",set:()=>{throw i()}});const s=e.createBufferSource();t(n,()=>{const o=n.numberOfInputs;for(let c=0;c<o;c+=1)s.connect(n,0,c)},()=>s.disconnect(n))},$r=(i,t,e)=>i.copyFromChannel===void 0?i.getChannelData(e)[0]:(i.copyFromChannel(t,e),t[0]),Xr=i=>{if(i===null)return!1;const t=i.length;return t%2!==0?i[Math.floor(t/2)]!==0:i[t/2-1]+i[t/2]!==0},ss=(i,t,e,n)=>{let s=i;for(;!s.hasOwnProperty(t);)s=Object.getPrototypeOf(s);const{get:r,set:a}=Object.getOwnPropertyDescriptor(s,t);Object.defineProperty(i,t,{get:e(r),set:n(a)})},Zu=i=>j(k({},i),{outputChannelCount:i.outputChannelCount!==void 0?i.outputChannelCount:i.numberOfInputs===1&&i.numberOfOutputs===1?[i.channelCount]:Array.from({length:i.numberOfOutputs},()=>1)}),Ku=i=>j(k({},i),{channelCount:i.numberOfOutputs}),Ju=i=>{const{imag:t,real:e}=i;return t===void 0?e===void 0?j(k({},i),{imag:[0,0],real:[0,0]}):j(k({},i),{imag:Array.from(e,()=>0),real:e}):e===void 0?j(k({},i),{imag:t,real:Array.from(t,()=>0)}):j(k({},i),{imag:t,real:e})},Zr=(i,t,e)=>{try{i.setValueAtTime(t,e)}catch(n){if(n.code!==9)throw n;Zr(i,t,e+1e-7)}},Qu=i=>{const t=i.createBufferSource();t.start();try{t.start()}catch{return!0}return!1},th=i=>{const t=i.createBufferSource(),e=i.createBuffer(1,1,44100);t.buffer=e;try{t.start(0,1)}catch{return!1}return!0},eh=i=>{const t=i.createBufferSource();t.start();try{t.stop()}catch{return!1}return!0},Ni=i=>{const t=i.createOscillator();try{t.start(-1)}catch(e){return e instanceof RangeError}return!1},Kr=i=>{const t=i.createBuffer(1,1,44100),e=i.createBufferSource();e.buffer=t,e.start(),e.stop();try{return e.stop(),!0}catch{return!1}},xi=i=>{const t=i.createOscillator();try{t.stop(-1)}catch(e){return e instanceof RangeError}return!1},nh=i=>{const{port1:t,port2:e}=new MessageChannel;try{t.postMessage(i)}finally{t.close(),e.close()}},sh=i=>{i.start=(t=>(e=0,n=0,s)=>{const r=i.buffer,a=r===null?n:Math.min(r.duration,n);r!==null&&a>r.duration-.5/i.context.sampleRate?t.call(i,e,0,0):t.call(i,e,a,s)})(i.start)},Jr=(i,t)=>{const e=t.createGain();i.connect(e);const n=(s=>()=>{s.call(i,e),i.removeEventListener("ended",n)})(i.disconnect);i.addEventListener("ended",n),vn(i,e),i.stop=(s=>{let r=!1;return(a=0)=>{if(r)try{s.call(i,a)}catch{e.gain.setValueAtTime(0,a)}else s.call(i,a),r=!0}})(i.stop)},wn=(i,t)=>e=>{const n={value:i};return Object.defineProperties(e,{currentTarget:n,target:n}),typeof t=="function"?t.call(i,e):t.handleEvent.call(i,e)},ih=So(Ze),rh=Io(Ze),ah=qc(zs),Qr=new WeakMap,oh=al(Qr),se=yc(new Map,new WeakMap),le=Gu(),ta=Ll(se,ue),Ai=rl(Rt),Ct=Mu(Rt,Ai,ze),ch=Po(ta,ht,Ct),ut=ll(Bs),ve=lu(le),it=xl(ve),ea=new WeakMap,na=Jc(wn),is=zl(le),Ci=Tl(is),Mi=El(le),sa=Sl(le),Vn=ql(le),Tt=ac(No(Ir),Mo(ih,rh,Ts,ah,Es,Rt,oh,Kn,ht,Ze,ge,ze,ps),se,_l(ai,Es,Rt,ht,Ln,ge),ue,Us,Pt,Vc(Ts,ai,Rt,ht,Ln,ut,ge,it),Gc(ea,Rt,ne),na,ut,Ci,Mi,sa,it,Vn),lh=Ro(Tt,ch,ue,ta,ut,it),Ii=new WeakSet,gr=Fl(le),ia=Oc(new Uint32Array(1)),Oi=Hu(ia,ue),ki=Yu(ia),uh=Fo(Ii,se,Pt,gr,ve,Vu(gr),Oi,ki),qs=Oo(Bt),ra=Iu(Ai,Qn,ze),he=Nc(ra),bn=Bl(qs,se,Qu,th,eh,Ni,Kr,xi,sh,$u(ss),Jr),de=Cu(ol(Qn),ra),hh=zo(he,bn,ht,de,Ct),ie=oc(xo(Or),ea,vi,cc,yo,vo,wo,bo,To,si,Cr,is,Zr),dh=Bo(Tt,hh,ie,At,bn,ut,it,wn),fh=Xo(Tt,Zo,ue,At,Ul(Bt,ss),ut,it,Ct),ph=_c(he,Gr,ht,de,Ct),Ke=Du(Qr),mh=gc(Tt,ie,ph,Us,Gr,ut,it,Ke),Oe=Rl(Ze,Mi),gh=Xu(At,Oe),ke=Xl(is,gh),_h=bc(ke,ht,Ct),yh=wc(Tt,_h,ke,ut,it),vh=Sc(es,ht,Ct),wh=Ec(Tt,vh,es,ut,it,Ku),bh=Jl(qs,bn,Bt,Oe),Tn=Kl(qs,se,bh,Ni,xi),Th=Ic(he,Tn,ht,de,Ct),Eh=Mc(Tt,ie,Th,Tn,ut,it,wn),aa=Ql(Pt,ss),Sh=Rc(aa,ht,Ct),Nh=Dc(Tt,Sh,aa,ut,it,Ke),xh=Uc(he,Hr,ht,de,Ct),Ah=zc(Tt,ie,xh,Hr,ut,it,Ke),oa=tu(Pt),Ch=Xc(he,oa,ht,de,Ct),Mh=$c(Tt,ie,Ch,oa,Pt,ut,it,Ke),Ih=sl(he,Bt,ht,de,Ct),Oh=nl(Tt,ie,Ih,Bt,ut,it),kh=iu(Us,At,ns,Pt),Ws=Ou(se,Bt,ns,zu(Bt,ve)),Dh=gl(bn,ht,ve,Ct,Ws),Rh=eu(kh),Ph=pl(Tt,Rh,Dh,ut,it,Ke),Lh=Ko(ie,ke,Tn,ns,Pt,$r,it,ss),ca=new WeakMap,Fh=Dl(fh,Lh,na,it,ca,wn),la=uu(qs,se,Ni,Kr,xi,Jr),Vh=Tu(he,la,ht,de,Ct),Bh=bu(Tt,ie,la,Vh,ut,it,wn),ua=Ac(bn),zh=_u(ua,At,Bt,Xr,Oe),js=gu(ua,At,zh,Xr,Oe,is,ss),Uh=du(Ts,At,ke,Bt,ns,js,Pt,Es,$r,Oe),ha=hu(Uh),qh=Nu(he,ke,Tn,Bt,ha,ht,ve,de,Ct,Ws),Wh=Su(Tt,ie,ha,qh,ut,it,Ke),jh=fu(ue),Gh=Au(jh,ut,new WeakSet,Ju),Hh=mu(ke,es,Bt,js,Pt,Oe),da=pu(Hh,Pt),Yh=Fu(he,da,ht,de,Ct),$h=Lu(Tt,ie,da,Yh,ut,it),Xh=ju(js,ht,Ct),Zh=Wu(Tt,At,js,Xh,ut,it,Ke),fa=Al(le),Di=Qc(le),pa=new WeakMap,Kh=ul(pa,ve),Jh=fa?Co(se,Pt,Kc(le),Di,tl(Eo),ut,Kh,it,Vn,new WeakMap,new WeakMap,Bu(Vn,ve),le):void 0,Qh=Nl(Ci,it),td=Fc(Ii,se,Lc,Zc,new WeakSet,ut,Qh,ws,Fn,Oi,ki),ma=pc(Jh,lh,uh,dh,mh,yh,wh,Eh,Nh,td,Ah,Mh,Oh,Ph,Fh,Bh,Wh,Gh,$h,Zh),ed=Cl(Tt,ru,ut,it),nd=Il(Tt,au,ut,it),sd=Ol(Tt,ou,ut,it),id=cu(At,it),rd=kl(Tt,id,ut),ad=$o(ma,At,Pt,Uu,ed,nd,sd,rd,is),Ri=hl(ca),od=ko(Ri),ga=xc(ue),cd=Wc(Ri),_a=Hc(ue),ya=new WeakMap,ld=il(ya,ne),ud=$l(ga,ue,At,ke,es,Tn,Bt,ns,Pt,_a,Di,ld,Oe),hd=jl(At,ud,Bt,Pt,Oe),dd=fc(he,ga,bn,ke,es,Tn,Bt,cd,_a,Di,ht,Vn,ve,de,Ct,Ws),fd=cl(pa),pd=ku(ya),_r=fa?uc(od,Tt,ie,dd,hd,Rt,fd,ut,it,Vn,Zu,pd,nh,wn):void 0,md=Pc(Pt,ve),gd=Ru(Ii,se,Ai,Ri,Ws,ws,Oi,ki),_d=vu(ma,se,At,md,gd),yd=yl(Bs,Ci),vd=vl(yi,Mi),wd=wl(vi,sa),bd=bl(Bs,it);function Z(i,t){if(!i)throw new Error(t)}function Ce(i,t,e=1/0){if(!(t<=i&&i<=e))throw new RangeError(`Value must be within [${t}, ${e}], got: ${i}`)}function va(i){!i.isOffline&&i.state!=="running"&&ba('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')}let wa=console;function Td(...i){wa.log(...i)}function ba(...i){wa.warn(...i)}function Ht(i){return typeof i=="undefined"}function K(i){return!Ht(i)}function Ed(i){return typeof i=="function"}function Ue(i){return typeof i=="number"}function Fe(i){return Object.prototype.toString.call(i)==="[object Object]"&&i.constructor===Object}function Sd(i){return typeof i=="boolean"}function ee(i){return Array.isArray(i)}function Yt(i){return typeof i=="string"}function hs(i){return Yt(i)&&/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(i)}function Nd(i){return new ad(i)}function xd(i,t,e){return new _d(i,t,e)}const Ve=typeof self=="object"?self:null,Ad=Ve&&(Ve.hasOwnProperty("AudioContext")||Ve.hasOwnProperty("webkitAudioContext"));function Cd(i,t,e){return Z(K(_r),"This node only works in a secure context (https or localhost)"),new _r(i,t,e)}function re(i,t,e,n){var s=arguments.length,r=s<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,e):n,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")r=Reflect.decorate(i,t,e,n);else for(var o=i.length-1;o>=0;o--)(a=i[o])&&(r=(s<3?a(r):s>3?a(t,e,r):a(t,e))||r);return s>3&&r&&Object.defineProperty(t,e,r),r}function Et(i,t,e,n){function s(r){return r instanceof e?r:new e(function(a){a(r)})}return new(e||(e=Promise))(function(r,a){function o(u){try{l(n.next(u))}catch(h){a(h)}}function c(u){try{l(n.throw(u))}catch(h){a(h)}}function l(u){u.done?r(u.value):s(u.value).then(o,c)}l((n=n.apply(i,t||[])).next())})}class Md{constructor(t,e,n){this._callback=t,this._type=e,this._updateInterval=n,this._createClock()}_createWorker(){const t=new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval*1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`],{type:"text/javascript"}),e=URL.createObjectURL(t),n=new Worker(e);n.onmessage=this._callback.bind(this),this._worker=n}_createTimeout(){this._timeout=setTimeout(()=>{this._createTimeout(),this._callback()},this._updateInterval*1e3)}_createClock(){if(this._type==="worker")try{this._createWorker()}catch{this._type="timeout",this._createClock()}else this._type==="timeout"&&this._createTimeout()}_disposeClock(){this._timeout&&(clearTimeout(this._timeout),this._timeout=0),this._worker&&(this._worker.terminate(),this._worker.onmessage=null)}get updateInterval(){return this._updateInterval}set updateInterval(t){this._updateInterval=Math.max(t,128/44100),this._type==="worker"&&this._worker.postMessage(Math.max(t*1e3,1))}get type(){return this._type}set type(t){this._disposeClock(),this._type=t,this._createClock()}dispose(){this._disposeClock()}}function qe(i){return wd(i)}function xe(i){return vd(i)}function ms(i){return bd(i)}function nn(i){return yd(i)}function Ta(i){return i instanceof AudioBuffer}function Id(i,t){return i==="value"||qe(t)||xe(t)||Ta(t)}function ln(i,...t){if(!t.length)return i;const e=t.shift();if(Fe(i)&&Fe(e))for(const n in e)Id(n,e[n])?i[n]=e[n]:Fe(e[n])?(i[n]||Object.assign(i,{[n]:{}}),ln(i[n],e[n])):Object.assign(i,{[n]:e[n]});return ln(i,...t)}function Od(i,t){return i.length===t.length&&i.every((e,n)=>t[n]===e)}function B(i,t,e=[],n){const s={},r=Array.from(t);if(Fe(r[0])&&n&&!Reflect.has(r[0],n)&&(Object.keys(r[0]).some(o=>Reflect.has(i,o))||(ln(s,{[n]:r[0]}),e.splice(e.indexOf(n),1),r.shift())),r.length===1&&Fe(r[0]))ln(s,r[0]);else for(let a=0;a<e.length;a++)K(r[a])&&(s[e[a]]=r[a]);return ln(i,s)}function kd(i){return i.constructor.getDefaults()}function un(i,t){return Ht(i)?t:i}function yr(i,t){return t.forEach(e=>{Reflect.has(i,e)&&delete i[e]}),i}/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */class we{constructor(){this.debug=!1,this._wasDisposed=!1}static getDefaults(){return{}}log(...t){(this.debug||Ve&&this.toString()===Ve.TONE_DEBUG_CLASS)&&Td(this,...t)}dispose(){return this._wasDisposed=!0,this}get disposed(){return this._wasDisposed}toString(){return this.name}}we.version=Ar;const Pi=1e-6;function As(i,t){return i>t+Pi}function hi(i,t){return As(i,t)||Zt(i,t)}function Ea(i,t){return i+Pi<t}function Zt(i,t){return Math.abs(i-t)<Pi}function Dd(i,t,e){return Math.max(Math.min(i,e),t)}class fe extends we{constructor(){super(),this.name="Timeline",this._timeline=[];const t=B(fe.getDefaults(),arguments,["memory"]);this.memory=t.memory,this.increasing=t.increasing}static getDefaults(){return{memory:1/0,increasing:!1}}get length(){return this._timeline.length}add(t){if(Z(Reflect.has(t,"time"),"Timeline: events must have a time attribute"),t.time=t.time.valueOf(),this.increasing&&this.length){const e=this._timeline[this.length-1];Z(hi(t.time,e.time),"The time must be greater than or equal to the last scheduled time"),this._timeline.push(t)}else{const e=this._search(t.time);this._timeline.splice(e+1,0,t)}if(this.length>this.memory){const e=this.length-this.memory;this._timeline.splice(0,e)}return this}remove(t){const e=this._timeline.indexOf(t);return e!==-1&&this._timeline.splice(e,1),this}get(t,e="time"){const n=this._search(t,e);return n!==-1?this._timeline[n]:null}peek(){return this._timeline[0]}shift(){return this._timeline.shift()}getAfter(t,e="time"){const n=this._search(t,e);return n+1<this._timeline.length?this._timeline[n+1]:null}getBefore(t){const e=this._timeline.length;if(e>0&&this._timeline[e-1].time<t)return this._timeline[e-1];const n=this._search(t);return n-1>=0?this._timeline[n-1]:null}cancel(t){if(this._timeline.length>1){let e=this._search(t);if(e>=0)if(Zt(this._timeline[e].time,t)){for(let n=e;n>=0&&Zt(this._timeline[n].time,t);n--)e=n;this._timeline=this._timeline.slice(0,e)}else this._timeline=this._timeline.slice(0,e+1);else this._timeline=[]}else this._timeline.length===1&&hi(this._timeline[0].time,t)&&(this._timeline=[]);return this}cancelBefore(t){const e=this._search(t);return e>=0&&(this._timeline=this._timeline.slice(e+1)),this}previousEvent(t){const e=this._timeline.indexOf(t);return e>0?this._timeline[e-1]:null}_search(t,e="time"){if(this._timeline.length===0)return-1;let n=0;const s=this._timeline.length;let r=s;if(s>0&&this._timeline[s-1][e]<=t)return s-1;for(;n<r;){let a=Math.floor(n+(r-n)/2);const o=this._timeline[a],c=this._timeline[a+1];if(Zt(o[e],t)){for(let l=a;l<this._timeline.length;l++){const u=this._timeline[l];if(Zt(u[e],t))a=l;else break}return a}else{if(Ea(o[e],t)&&As(c[e],t))return a;As(o[e],t)?r=a:n=a+1}}return-1}_iterate(t,e=0,n=this._timeline.length-1){this._timeline.slice(e,n+1).forEach(t)}forEach(t){return this._iterate(t),this}forEachBefore(t,e){const n=this._search(t);return n!==-1&&this._iterate(e,0,n),this}forEachAfter(t,e){const n=this._search(t);return this._iterate(e,n+1),this}forEachBetween(t,e,n){let s=this._search(t),r=this._search(e);return s!==-1&&r!==-1?(this._timeline[s].time!==t&&(s+=1),this._timeline[r].time===e&&(r-=1),this._iterate(n,s,r)):s===-1&&this._iterate(n,0,r),this}forEachFrom(t,e){let n=this._search(t);for(;n>=0&&this._timeline[n].time>=t;)n--;return this._iterate(e,n+1),this}forEachAtTime(t,e){const n=this._search(t);if(n!==-1&&Zt(this._timeline[n].time,t)){let s=n;for(let r=n;r>=0&&Zt(this._timeline[r].time,t);r--)s=r;this._iterate(r=>{e(r)},s,n)}return this}dispose(){return super.dispose(),this._timeline=[],this}}const Sa=[];function Gs(i){Sa.push(i)}function Rd(i){Sa.forEach(t=>t(i))}const Na=[];function Hs(i){Na.push(i)}function Pd(i){Na.forEach(t=>t(i))}class rs extends we{constructor(){super(...arguments),this.name="Emitter"}on(t,e){return t.split(/\W+/).forEach(s=>{Ht(this._events)&&(this._events={}),this._events.hasOwnProperty(s)||(this._events[s]=[]),this._events[s].push(e)}),this}once(t,e){const n=(...s)=>{e(...s),this.off(t,n)};return this.on(t,n),this}off(t,e){return t.split(/\W+/).forEach(s=>{if(Ht(this._events)&&(this._events={}),this._events.hasOwnProperty(t))if(Ht(e))this._events[t]=[];else{const r=this._events[t];for(let a=r.length-1;a>=0;a--)r[a]===e&&r.splice(a,1)}}),this}emit(t,...e){if(this._events&&this._events.hasOwnProperty(t)){const n=this._events[t].slice(0);for(let s=0,r=n.length;s<r;s++)n[s].apply(this,e)}return this}static mixin(t){["on","once","off","emit"].forEach(e=>{const n=Object.getOwnPropertyDescriptor(rs.prototype,e);Object.defineProperty(t.prototype,e,n)})}dispose(){return super.dispose(),this._events=void 0,this}}class xa extends rs{constructor(){super(...arguments),this.isOffline=!1}toJSON(){return{}}}class as extends xa{constructor(){super(),this.name="Context",this._constants=new Map,this._timeouts=new fe,this._timeoutIds=0,this._initialized=!1,this.isOffline=!1,this._workletModules=new Map;const t=B(as.getDefaults(),arguments,["context"]);t.context?this._context=t.context:this._context=Nd({latencyHint:t.latencyHint}),this._ticker=new Md(this.emit.bind(this,"tick"),t.clockSource,t.updateInterval),this.on("tick",this._timeoutLoop.bind(this)),this._context.onstatechange=()=>{this.emit("statechange",this.state)},this._setLatencyHint(t.latencyHint),this.lookAhead=t.lookAhead}static getDefaults(){return{clockSource:"worker",latencyHint:"interactive",lookAhead:.1,updateInterval:.05}}initialize(){return this._initialized||(Rd(this),this._initialized=!0),this}createAnalyser(){return this._context.createAnalyser()}createOscillator(){return this._context.createOscillator()}createBufferSource(){return this._context.createBufferSource()}createBiquadFilter(){return this._context.createBiquadFilter()}createBuffer(t,e,n){return this._context.createBuffer(t,e,n)}createChannelMerger(t){return this._context.createChannelMerger(t)}createChannelSplitter(t){return this._context.createChannelSplitter(t)}createConstantSource(){return this._context.createConstantSource()}createConvolver(){return this._context.createConvolver()}createDelay(t){return this._context.createDelay(t)}createDynamicsCompressor(){return this._context.createDynamicsCompressor()}createGain(){return this._context.createGain()}createIIRFilter(t,e){return this._context.createIIRFilter(t,e)}createPanner(){return this._context.createPanner()}createPeriodicWave(t,e,n){return this._context.createPeriodicWave(t,e,n)}createStereoPanner(){return this._context.createStereoPanner()}createWaveShaper(){return this._context.createWaveShaper()}createMediaStreamSource(t){return Z(nn(this._context),"Not available if OfflineAudioContext"),this._context.createMediaStreamSource(t)}createMediaElementSource(t){return Z(nn(this._context),"Not available if OfflineAudioContext"),this._context.createMediaElementSource(t)}createMediaStreamDestination(){return Z(nn(this._context),"Not available if OfflineAudioContext"),this._context.createMediaStreamDestination()}decodeAudioData(t){return this._context.decodeAudioData(t)}get currentTime(){return this._context.currentTime}get state(){return this._context.state}get sampleRate(){return this._context.sampleRate}get listener(){return this.initialize(),this._listener}set listener(t){Z(!this._initialized,"The listener cannot be set after initialization."),this._listener=t}get transport(){return this.initialize(),this._transport}set transport(t){Z(!this._initialized,"The transport cannot be set after initialization."),this._transport=t}get draw(){return this.initialize(),this._draw}set draw(t){Z(!this._initialized,"Draw cannot be set after initialization."),this._draw=t}get destination(){return this.initialize(),this._destination}set destination(t){Z(!this._initialized,"The destination cannot be set after initialization."),this._destination=t}createAudioWorkletNode(t,e){return Cd(this.rawContext,t,e)}addAudioWorkletModule(t,e){return Et(this,void 0,void 0,function*(){Z(K(this.rawContext.audioWorklet),"AudioWorkletNode is only available in a secure context (https or localhost)"),this._workletModules.has(e)||this._workletModules.set(e,this.rawContext.audioWorklet.addModule(t)),yield this._workletModules.get(e)})}workletsAreReady(){return Et(this,void 0,void 0,function*(){const t=[];this._workletModules.forEach(e=>t.push(e)),yield Promise.all(t)})}get updateInterval(){return this._ticker.updateInterval}set updateInterval(t){this._ticker.updateInterval=t}get clockSource(){return this._ticker.type}set clockSource(t){this._ticker.type=t}get latencyHint(){return this._latencyHint}_setLatencyHint(t){let e=0;if(this._latencyHint=t,Yt(t))switch(t){case"interactive":e=.1;break;case"playback":e=.5;break;case"balanced":e=.25;break}this.lookAhead=e,this.updateInterval=e/2}get rawContext(){return this._context}now(){return this._context.currentTime+this.lookAhead}immediate(){return this._context.currentTime}resume(){return nn(this._context)?this._context.resume():Promise.resolve()}close(){return Et(this,void 0,void 0,function*(){nn(this._context)&&(yield this._context.close()),this._initialized&&Pd(this)})}getConstant(t){if(this._constants.has(t))return this._constants.get(t);{const e=this._context.createBuffer(1,128,this._context.sampleRate),n=e.getChannelData(0);for(let r=0;r<n.length;r++)n[r]=t;const s=this._context.createBufferSource();return s.channelCount=1,s.channelCountMode="explicit",s.buffer=e,s.loop=!0,s.start(0),this._constants.set(t,s),s}}dispose(){return super.dispose(),this._ticker.dispose(),this._timeouts.dispose(),Object.keys(this._constants).map(t=>this._constants[t].disconnect()),this}_timeoutLoop(){const t=this.now();let e=this._timeouts.peek();for(;this._timeouts.length&&e&&e.time<=t;)e.callback(),this._timeouts.shift(),e=this._timeouts.peek()}setTimeout(t,e){this._timeoutIds++;const n=this.now();return this._timeouts.add({callback:t,id:this._timeoutIds,time:n+e}),this._timeoutIds}clearTimeout(t){return this._timeouts.forEach(e=>{e.id===t&&this._timeouts.remove(e)}),this}clearInterval(t){return this.clearTimeout(t)}setInterval(t,e){const n=++this._timeoutIds,s=()=>{const r=this.now();this._timeouts.add({callback:()=>{t(),s()},id:n,time:r+e})};return s(),n}}class Ld extends xa{constructor(){super(...arguments),this.lookAhead=0,this.latencyHint=0,this.isOffline=!1}createAnalyser(){return{}}createOscillator(){return{}}createBufferSource(){return{}}createBiquadFilter(){return{}}createBuffer(t,e,n){return{}}createChannelMerger(t){return{}}createChannelSplitter(t){return{}}createConstantSource(){return{}}createConvolver(){return{}}createDelay(t){return{}}createDynamicsCompressor(){return{}}createGain(){return{}}createIIRFilter(t,e){return{}}createPanner(){return{}}createPeriodicWave(t,e,n){return{}}createStereoPanner(){return{}}createWaveShaper(){return{}}createMediaStreamSource(t){return{}}createMediaElementSource(t){return{}}createMediaStreamDestination(){return{}}decodeAudioData(t){return Promise.resolve({})}createAudioWorkletNode(t,e){return{}}get rawContext(){return{}}addAudioWorkletModule(t,e){return Et(this,void 0,void 0,function*(){return Promise.resolve()})}resume(){return Promise.resolve()}setTimeout(t,e){return 0}clearTimeout(t){return this}setInterval(t,e){return 0}clearInterval(t){return this}getConstant(t){return{}}get currentTime(){return 0}get state(){return{}}get sampleRate(){return 0}get listener(){return{}}get transport(){return{}}get draw(){return{}}set draw(t){}get destination(){return{}}set destination(t){}now(){return 0}immediate(){return 0}}function yt(i,t){ee(t)?t.forEach(e=>yt(i,e)):Object.defineProperty(i,t,{enumerable:!0,writable:!1})}function Aa(i,t){ee(t)?t.forEach(e=>Aa(i,e)):Object.defineProperty(i,t,{writable:!0})}const at=()=>{};class ct extends we{constructor(){super(),this.name="ToneAudioBuffer",this.onload=at;const t=B(ct.getDefaults(),arguments,["url","onload","onerror"]);this.reverse=t.reverse,this.onload=t.onload,t.url&&Ta(t.url)||t.url instanceof ct?this.set(t.url):Yt(t.url)&&this.load(t.url).catch(t.onerror)}static getDefaults(){return{onerror:at,onload:at,reverse:!1}}get sampleRate(){return this._buffer?this._buffer.sampleRate:qt().sampleRate}set(t){return t instanceof ct?t.loaded?this._buffer=t.get():t.onload=()=>{this.set(t),this.onload(this)}:this._buffer=t,this._reversed&&this._reverse(),this}get(){return this._buffer}load(t){return Et(this,void 0,void 0,function*(){const e=ct.load(t).then(n=>{this.set(n),this.onload(this)});ct.downloads.push(e);try{yield e}finally{const n=ct.downloads.indexOf(e);ct.downloads.splice(n,1)}return this})}dispose(){return super.dispose(),this._buffer=void 0,this}fromArray(t){const e=ee(t)&&t[0].length>0,n=e?t.length:1,s=e?t[0].length:t.length,r=qt(),a=r.createBuffer(n,s,r.sampleRate),o=!e&&n===1?[t]:t;for(let c=0;c<n;c++)a.copyToChannel(o[c],c);return this._buffer=a,this}toMono(t){if(Ue(t))this.fromArray(this.toArray(t));else{let e=new Float32Array(this.length);const n=this.numberOfChannels;for(let s=0;s<n;s++){const r=this.toArray(s);for(let a=0;a<r.length;a++)e[a]+=r[a]}e=e.map(s=>s/n),this.fromArray(e)}return this}toArray(t){if(Ue(t))return this.getChannelData(t);if(this.numberOfChannels===1)return this.toArray(0);{const e=[];for(let n=0;n<this.numberOfChannels;n++)e[n]=this.getChannelData(n);return e}}getChannelData(t){return this._buffer?this._buffer.getChannelData(t):new Float32Array(0)}slice(t,e=this.duration){const n=Math.floor(t*this.sampleRate),s=Math.floor(e*this.sampleRate);Z(n<s,"The start time must be less than the end time");const r=s-n,a=qt().createBuffer(this.numberOfChannels,r,this.sampleRate);for(let o=0;o<this.numberOfChannels;o++)a.copyToChannel(this.getChannelData(o).subarray(n,s),o);return new ct(a)}_reverse(){if(this.loaded)for(let t=0;t<this.numberOfChannels;t++)this.getChannelData(t).reverse();return this}get loaded(){return this.length>0}get duration(){return this._buffer?this._buffer.duration:0}get length(){return this._buffer?this._buffer.length:0}get numberOfChannels(){return this._buffer?this._buffer.numberOfChannels:0}get reverse(){return this._reversed}set reverse(t){this._reversed!==t&&(this._reversed=t,this._reverse())}static fromArray(t){return new ct().fromArray(t)}static fromUrl(t){return Et(this,void 0,void 0,function*(){return yield new ct().load(t)})}static load(t){return Et(this,void 0,void 0,function*(){const e=t.match(/\[([^\]\[]+\|.+)\]$/);if(e){const o=e[1].split("|");let c=o[0];for(const l of o)if(ct.supportsType(l)){c=l;break}t=t.replace(e[0],c)}const n=ct.baseUrl===""||ct.baseUrl.endsWith("/")?ct.baseUrl:ct.baseUrl+"/",s=yield fetch(n+t);if(!s.ok)throw new Error(`could not load url: ${t}`);const r=yield s.arrayBuffer();return yield qt().decodeAudioData(r)})}static supportsType(t){const e=t.split("."),n=e[e.length-1];return document.createElement("audio").canPlayType("audio/"+n)!==""}static loaded(){return Et(this,void 0,void 0,function*(){for(yield Promise.resolve();ct.downloads.length;)yield ct.downloads[0]})}}ct.baseUrl="";ct.downloads=[];class Li extends as{constructor(){super({clockSource:"offline",context:ms(arguments[0])?arguments[0]:xd(arguments[0],arguments[1]*arguments[2],arguments[2]),lookAhead:0,updateInterval:ms(arguments[0])?128/arguments[0].sampleRate:128/arguments[2]}),this.name="OfflineContext",this._currentTime=0,this.isOffline=!0,this._duration=ms(arguments[0])?arguments[0].length/arguments[0].sampleRate:arguments[1]}now(){return this._currentTime}get currentTime(){return this._currentTime}_renderClock(t){return Et(this,void 0,void 0,function*(){let e=0;for(;this._duration-this._currentTime>=0;){this.emit("tick"),this._currentTime+=128/this.sampleRate,e++;const n=Math.floor(this.sampleRate/128);t&&e%n===0&&(yield new Promise(s=>setTimeout(s,1)))}})}render(t=!0){return Et(this,void 0,void 0,function*(){yield this.workletsAreReady(),yield this._renderClock(t);const e=yield this._context.startRendering();return new ct(e)})}close(){return Promise.resolve()}}const Ca=new Ld;let hn=Ca;function qt(){return hn===Ca&&Ad&&Fd(new as),hn}function Fd(i){nn(i)?hn=new as(i):ms(i)?hn=new Li(i):hn=i}function Vd(){return hn.resume()}if(Ve&&!Ve.TONE_SILENCE_LOGGING){const t=` * Tone.js v${Ar} * `;console.log(`%c${t}`,"background: #000; color: #fff")}function Bd(i){return Math.pow(10,i/20)}function zd(i){return 20*(Math.log(i)/Math.LN10)}function Ma(i){return Math.pow(2,i/12)}let Ys=440;function Ud(){return Ys}function qd(i){Ys=i}function Re(i){return Math.round(Ia(i))}function Ia(i){return 69+12*Math.log2(i/Ys)}function Oa(i){return Ys*Math.pow(2,(i-69)/12)}class Fi extends we{constructor(t,e,n){super(),this.defaultUnits="s",this._val=e,this._units=n,this.context=t,this._expressions=this._getExpressions()}_getExpressions(){return{hz:{method:t=>this._frequencyToUnits(parseFloat(t)),regexp:/^(\d+(?:\.\d+)?)hz$/i},i:{method:t=>this._ticksToUnits(parseInt(t,10)),regexp:/^(\d+)i$/i},m:{method:t=>this._beatsToUnits(parseInt(t,10)*this._getTimeSignature()),regexp:/^(\d+)m$/i},n:{method:(t,e)=>{const n=parseInt(t,10),s=e==="."?1.5:1;return n===1?this._beatsToUnits(this._getTimeSignature())*s:this._beatsToUnits(4/n)*s},regexp:/^(\d+)n(\.?)$/i},number:{method:t=>this._expressions[this.defaultUnits].method.call(this,t),regexp:/^(\d+(?:\.\d+)?)$/},s:{method:t=>this._secondsToUnits(parseFloat(t)),regexp:/^(\d+(?:\.\d+)?)s$/},samples:{method:t=>parseInt(t,10)/this.context.sampleRate,regexp:/^(\d+)samples$/},t:{method:t=>{const e=parseInt(t,10);return this._beatsToUnits(8/(Math.floor(e)*3))},regexp:/^(\d+)t$/i},tr:{method:(t,e,n)=>{let s=0;return t&&t!=="0"&&(s+=this._beatsToUnits(this._getTimeSignature()*parseFloat(t))),e&&e!=="0"&&(s+=this._beatsToUnits(parseFloat(e))),n&&n!=="0"&&(s+=this._beatsToUnits(parseFloat(n)/4)),s},regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/}}}valueOf(){if(this._val instanceof Fi&&this.fromType(this._val),Ht(this._val))return this._noArg();if(Yt(this._val)&&Ht(this._units)){for(const t in this._expressions)if(this._expressions[t].regexp.test(this._val.trim())){this._units=t;break}}else if(Fe(this._val)){let t=0;for(const e in this._val)if(K(this._val[e])){const n=this._val[e];t+=new this.constructor(this.context,e).valueOf()*n}return t}if(K(this._units)){const t=this._expressions[this._units],e=this._val.toString().trim().match(t.regexp);return e?t.method.apply(this,e.slice(1)):t.method.call(this,this._val)}else return Yt(this._val)?parseFloat(this._val):this._val}_frequencyToUnits(t){return 1/t}_beatsToUnits(t){return 60/this._getBpm()*t}_secondsToUnits(t){return t}_ticksToUnits(t){return t*this._beatsToUnits(1)/this._getPPQ()}_noArg(){return this._now()}_getBpm(){return this.context.transport.bpm.value}_getTimeSignature(){return this.context.transport.timeSignature}_getPPQ(){return this.context.transport.PPQ}fromType(t){switch(this._units=void 0,this.defaultUnits){case"s":this._val=t.toSeconds();break;case"i":this._val=t.toTicks();break;case"hz":this._val=t.toFrequency();break;case"midi":this._val=t.toMidi();break}return this}toFrequency(){return 1/this.toSeconds()}toSamples(){return this.toSeconds()*this.context.sampleRate}toMilliseconds(){return this.toSeconds()*1e3}}class Qt extends Fi{constructor(){super(...arguments),this.name="TimeClass"}_getExpressions(){return Object.assign(super._getExpressions(),{now:{method:t=>this._now()+new this.constructor(this.context,t).valueOf(),regexp:/^\+(.+)/},quantize:{method:t=>{const e=new Qt(this.context,t).valueOf();return this._secondsToUnits(this.context.transport.nextSubdivision(e))},regexp:/^@(.+)/}})}quantize(t,e=1){const n=new this.constructor(this.context,t).valueOf(),s=this.valueOf(),o=Math.round(s/n)*n-s;return s+o*e}toNotation(){const t=this.toSeconds(),e=["1m"];for(let r=1;r<9;r++){const a=Math.pow(2,r);e.push(a+"n."),e.push(a+"n"),e.push(a+"t")}e.push("0");let n=e[0],s=new Qt(this.context,e[0]).toSeconds();return e.forEach(r=>{const a=new Qt(this.context,r).toSeconds();Math.abs(a-t)<Math.abs(s-t)&&(n=r,s=a)}),n}toBarsBeatsSixteenths(){const t=this._beatsToUnits(1);let e=this.valueOf()/t;e=parseFloat(e.toFixed(4));const n=Math.floor(e/this._getTimeSignature());let s=e%1*4;e=Math.floor(e)%this._getTimeSignature();const r=s.toString();return r.length>3&&(s=parseFloat(parseFloat(r).toFixed(3))),[n,e,s].join(":")}toTicks(){const t=this._beatsToUnits(1),e=this.valueOf()/t;return Math.round(e*this._getPPQ())}toSeconds(){return this.valueOf()}toMidi(){return Re(this.toFrequency())}_now(){return this.context.now()}}class Ft extends Qt{constructor(){super(...arguments),this.name="Frequency",this.defaultUnits="hz"}static get A4(){return Ud()}static set A4(t){qd(t)}_getExpressions(){return Object.assign({},super._getExpressions(),{midi:{regexp:/^(\d+(?:\.\d+)?midi)/,method(t){return this.defaultUnits==="midi"?t:Ft.mtof(t)}},note:{regexp:/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,method(t,e){const s=Wd[t.toLowerCase()]+(parseInt(e,10)+1)*12;return this.defaultUnits==="midi"?s:Ft.mtof(s)}},tr:{regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,method(t,e,n){let s=1;return t&&t!=="0"&&(s*=this._beatsToUnits(this._getTimeSignature()*parseFloat(t))),e&&e!=="0"&&(s*=this._beatsToUnits(parseFloat(e))),n&&n!=="0"&&(s*=this._beatsToUnits(parseFloat(n)/4)),s}}})}transpose(t){return new Ft(this.context,this.valueOf()*Ma(t))}harmonize(t){return t.map(e=>this.transpose(e))}toMidi(){return Re(this.valueOf())}toNote(){const t=this.toFrequency(),e=Math.log2(t/Ft.A4);let n=Math.round(12*e)+57;const s=Math.floor(n/12);return s<0&&(n+=-12*s),jd[n%12]+s.toString()}toSeconds(){return 1/super.toSeconds()}toTicks(){const t=this._beatsToUnits(1),e=this.valueOf()/t;return Math.floor(e*this._getPPQ())}_noArg(){return 0}_frequencyToUnits(t){return t}_ticksToUnits(t){return 1/(t*60/(this._getBpm()*this._getPPQ()))}_beatsToUnits(t){return 1/super._beatsToUnits(t)}_secondsToUnits(t){return 1/t}static mtof(t){return Oa(t)}static ftom(t){return Re(t)}}const Wd={cbb:-2,cb:-1,c:0,"c#":1,cx:2,dbb:0,db:1,d:2,"d#":3,dx:4,ebb:2,eb:3,e:4,"e#":5,ex:6,fbb:3,fb:4,f:5,"f#":6,fx:7,gbb:5,gb:6,g:7,"g#":8,gx:9,abb:7,ab:8,a:9,"a#":10,ax:11,bbb:9,bb:10,b:11,"b#":12,bx:13},jd=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];function Gd(i,t){return new Ft(qt(),i,t)}class kn extends Qt{constructor(){super(...arguments),this.name="TransportTime"}_now(){return this.context.transport.seconds}}class Vt extends we{constructor(){super();const t=B(Vt.getDefaults(),arguments,["context"]);this.defaultContext?this.context=this.defaultContext:this.context=t.context}static getDefaults(){return{context:qt()}}now(){return this.context.currentTime+this.context.lookAhead}immediate(){return this.context.currentTime}get sampleTime(){return 1/this.context.sampleRate}get blockTime(){return 128/this.context.sampleRate}toSeconds(t){return new Qt(this.context,t).toSeconds()}toFrequency(t){return new Ft(this.context,t).toFrequency()}toTicks(t){return new kn(this.context,t).toTicks()}_getPartialProperties(t){const e=this.get();return Object.keys(e).forEach(n=>{Ht(t[n])&&delete e[n]}),e}get(){const t=kd(this);return Object.keys(t).forEach(e=>{if(Reflect.has(this,e)){const n=this[e];K(n)&&K(n.value)&&K(n.setValueAtTime)?t[e]=n.value:n instanceof Vt?t[e]=n._getPartialProperties(t[e]):ee(n)||Ue(n)||Yt(n)||Sd(n)?t[e]=n:delete t[e]}}),t}set(t){return Object.keys(t).forEach(e=>{Reflect.has(this,e)&&K(this[e])&&(this[e]&&K(this[e].value)&&K(this[e].setValueAtTime)?this[e].value!==t[e]&&(this[e].value=t[e]):this[e]instanceof Vt?this[e].set(t[e]):this[e]=t[e])}),this}}class Vi extends fe{constructor(t="stopped"){super(),this.name="StateTimeline",this._initial=t,this.setStateAtTime(this._initial,0)}getValueAtTime(t){const e=this.get(t);return e!==null?e.state:this._initial}setStateAtTime(t,e,n){return Ce(e,0),this.add(Object.assign({},n,{state:t,time:e})),this}getLastState(t,e){const n=this._search(e);for(let s=n;s>=0;s--){const r=this._timeline[s];if(r.state===t)return r}}getNextState(t,e){const n=this._search(e);if(n!==-1)for(let s=n;s<this._timeline.length;s++){const r=this._timeline[s];if(r.state===t)return r}}}class dt extends Vt{constructor(){super(B(dt.getDefaults(),arguments,["param","units","convert"])),this.name="Param",this.overridden=!1,this._minOutput=1e-7;const t=B(dt.getDefaults(),arguments,["param","units","convert"]);for(Z(K(t.param)&&(qe(t.param)||t.param instanceof dt),"param must be an AudioParam");!qe(t.param);)t.param=t.param._param;this._swappable=K(t.swappable)?t.swappable:!1,this._swappable?(this.input=this.context.createGain(),this._param=t.param,this.input.connect(this._param)):this._param=this.input=t.param,this._events=new fe(1e3),this._initialValue=this._param.defaultValue,this.units=t.units,this.convert=t.convert,this._minValue=t.minValue,this._maxValue=t.maxValue,K(t.value)&&t.value!==this._toType(this._initialValue)&&this.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(Vt.getDefaults(),{convert:!0,units:"number"})}get value(){const t=this.now();return this.getValueAtTime(t)}set value(t){this.cancelScheduledValues(this.now()),this.setValueAtTime(t,this.now())}get minValue(){return K(this._minValue)?this._minValue:this.units==="time"||this.units==="frequency"||this.units==="normalRange"||this.units==="positive"||this.units==="transportTime"||this.units==="ticks"||this.units==="bpm"||this.units==="hertz"||this.units==="samples"?0:this.units==="audioRange"?-1:this.units==="decibels"?-1/0:this._param.minValue}get maxValue(){return K(this._maxValue)?this._maxValue:this.units==="normalRange"||this.units==="audioRange"?1:this._param.maxValue}_is(t,e){return this.units===e}_assertRange(t){return K(this.maxValue)&&K(this.minValue)&&Ce(t,this._fromType(this.minValue),this._fromType(this.maxValue)),t}_fromType(t){return this.convert&&!this.overridden?this._is(t,"time")?this.toSeconds(t):this._is(t,"decibels")?Bd(t):this._is(t,"frequency")?this.toFrequency(t):t:this.overridden?0:t}_toType(t){return this.convert&&this.units==="decibels"?zd(t):t}setValueAtTime(t,e){const n=this.toSeconds(e),s=this._fromType(t);return Z(isFinite(s)&&isFinite(n),`Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._assertRange(s),this.log(this.units,"setValueAtTime",t,n),this._events.add({time:n,type:"setValueAtTime",value:s}),this._param.setValueAtTime(s,n),this}getValueAtTime(t){const e=Math.max(this.toSeconds(t),0),n=this._events.getAfter(e),s=this._events.get(e);let r=this._initialValue;if(s===null)r=this._initialValue;else if(s.type==="setTargetAtTime"&&(n===null||n.type==="setValueAtTime")){const a=this._events.getBefore(s.time);let o;a===null?o=this._initialValue:o=a.value,s.type==="setTargetAtTime"&&(r=this._exponentialApproach(s.time,o,s.value,s.constant,e))}else if(n===null)r=s.value;else if(n.type==="linearRampToValueAtTime"||n.type==="exponentialRampToValueAtTime"){let a=s.value;if(s.type==="setTargetAtTime"){const o=this._events.getBefore(s.time);o===null?a=this._initialValue:a=o.value}n.type==="linearRampToValueAtTime"?r=this._linearInterpolate(s.time,a,n.time,n.value,e):r=this._exponentialInterpolate(s.time,a,n.time,n.value,e)}else r=s.value;return this._toType(r)}setRampPoint(t){t=this.toSeconds(t);let e=this.getValueAtTime(t);return this.cancelAndHoldAtTime(t),this._fromType(e)===0&&(e=this._toType(this._minOutput)),this.setValueAtTime(e,t),this}linearRampToValueAtTime(t,e){const n=this._fromType(t),s=this.toSeconds(e);return Z(isFinite(n)&&isFinite(s),`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._assertRange(n),this._events.add({time:s,type:"linearRampToValueAtTime",value:n}),this.log(this.units,"linearRampToValueAtTime",t,s),this._param.linearRampToValueAtTime(n,s),this}exponentialRampToValueAtTime(t,e){let n=this._fromType(t);n=Zt(n,0)?this._minOutput:n,this._assertRange(n);const s=this.toSeconds(e);return Z(isFinite(n)&&isFinite(s),`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._events.add({time:s,type:"exponentialRampToValueAtTime",value:n}),this.log(this.units,"exponentialRampToValueAtTime",t,s),this._param.exponentialRampToValueAtTime(n,s),this}exponentialRampTo(t,e,n){return n=this.toSeconds(n),this.setRampPoint(n),this.exponentialRampToValueAtTime(t,n+this.toSeconds(e)),this}linearRampTo(t,e,n){return n=this.toSeconds(n),this.setRampPoint(n),this.linearRampToValueAtTime(t,n+this.toSeconds(e)),this}targetRampTo(t,e,n){return n=this.toSeconds(n),this.setRampPoint(n),this.exponentialApproachValueAtTime(t,n,e),this}exponentialApproachValueAtTime(t,e,n){e=this.toSeconds(e),n=this.toSeconds(n);const s=Math.log(n+1)/Math.log(200);return this.setTargetAtTime(t,e,s),this.cancelAndHoldAtTime(e+n*.9),this.linearRampToValueAtTime(t,e+n),this}setTargetAtTime(t,e,n){const s=this._fromType(t);Z(isFinite(n)&&n>0,"timeConstant must be a number greater than 0");const r=this.toSeconds(e);return this._assertRange(s),Z(isFinite(s)&&isFinite(r),`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._events.add({constant:n,time:r,type:"setTargetAtTime",value:s}),this.log(this.units,"setTargetAtTime",t,r,n),this._param.setTargetAtTime(s,r,n),this}setValueCurveAtTime(t,e,n,s=1){n=this.toSeconds(n),e=this.toSeconds(e);const r=this._fromType(t[0])*s;this.setValueAtTime(this._toType(r),e);const a=n/(t.length-1);for(let o=1;o<t.length;o++){const c=this._fromType(t[o])*s;this.linearRampToValueAtTime(this._toType(c),e+o*a)}return this}cancelScheduledValues(t){const e=this.toSeconds(t);return Z(isFinite(e),`Invalid argument to cancelScheduledValues: ${JSON.stringify(t)}`),this._events.cancel(e),this._param.cancelScheduledValues(e),this.log(this.units,"cancelScheduledValues",e),this}cancelAndHoldAtTime(t){const e=this.toSeconds(t),n=this._fromType(this.getValueAtTime(e));Z(isFinite(e),`Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(t)}`),this.log(this.units,"cancelAndHoldAtTime",e,"value="+n);const s=this._events.get(e),r=this._events.getAfter(e);return s&&Zt(s.time,e)?r?(this._param.cancelScheduledValues(r.time),this._events.cancel(r.time)):(this._param.cancelAndHoldAtTime(e),this._events.cancel(e+this.sampleTime)):r&&(this._param.cancelScheduledValues(r.time),this._events.cancel(r.time),r.type==="linearRampToValueAtTime"?this.linearRampToValueAtTime(this._toType(n),e):r.type==="exponentialRampToValueAtTime"&&this.exponentialRampToValueAtTime(this._toType(n),e)),this._events.add({time:e,type:"setValueAtTime",value:n}),this._param.setValueAtTime(n,e),this}rampTo(t,e=.1,n){return this.units==="frequency"||this.units==="bpm"||this.units==="decibels"?this.exponentialRampTo(t,e,n):this.linearRampTo(t,e,n),this}apply(t){const e=this.context.currentTime;t.setValueAtTime(this.getValueAtTime(e),e);const n=this._events.get(e);if(n&&n.type==="setTargetAtTime"){const s=this._events.getAfter(n.time),r=s?s.time:e+2,a=(r-e)/10;for(let o=e;o<r;o+=a)t.linearRampToValueAtTime(this.getValueAtTime(o),o)}return this._events.forEachAfter(this.context.currentTime,s=>{s.type==="cancelScheduledValues"?t.cancelScheduledValues(s.time):s.type==="setTargetAtTime"?t.setTargetAtTime(s.value,s.time,s.constant):t[s.type](s.value,s.time)}),this}setParam(t){Z(this._swappable,"The Param must be assigned as 'swappable' in the constructor");const e=this.input;return e.disconnect(this._param),this.apply(t),this._param=t,e.connect(this._param),this}dispose(){return super.dispose(),this._events.dispose(),this}get defaultValue(){return this._toType(this._param.defaultValue)}_exponentialApproach(t,e,n,s,r){return n+(e-n)*Math.exp(-(r-t)/s)}_linearInterpolate(t,e,n,s,r){return e+(s-e)*((r-t)/(n-t))}_exponentialInterpolate(t,e,n,s,r){return e*Math.pow(s/e,(r-t)/(n-t))}}class $ extends Vt{constructor(){super(...arguments),this.name="ToneAudioNode",this._internalChannels=[]}get numberOfInputs(){return K(this.input)?qe(this.input)||this.input instanceof dt?1:this.input.numberOfInputs:0}get numberOfOutputs(){return K(this.output)?this.output.numberOfOutputs:0}_isAudioNode(t){return K(t)&&(t instanceof $||xe(t))}_getInternalNodes(){const t=this._internalChannels.slice(0);return this._isAudioNode(this.input)&&t.push(this.input),this._isAudioNode(this.output)&&this.input!==this.output&&t.push(this.output),t}_setChannelProperties(t){this._getInternalNodes().forEach(n=>{n.channelCount=t.channelCount,n.channelCountMode=t.channelCountMode,n.channelInterpretation=t.channelInterpretation})}_getChannelProperties(){const t=this._getInternalNodes();Z(t.length>0,"ToneAudioNode does not have any internal nodes");const e=t[0];return{channelCount:e.channelCount,channelCountMode:e.channelCountMode,channelInterpretation:e.channelInterpretation}}get channelCount(){return this._getChannelProperties().channelCount}set channelCount(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelCount:t}))}get channelCountMode(){return this._getChannelProperties().channelCountMode}set channelCountMode(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelCountMode:t}))}get channelInterpretation(){return this._getChannelProperties().channelInterpretation}set channelInterpretation(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelInterpretation:t}))}connect(t,e=0,n=0){return En(this,t,e,n),this}toDestination(){return this.connect(this.context.destination),this}toMaster(){return ba("toMaster() has been renamed toDestination()"),this.toDestination()}disconnect(t,e=0,n=0){return Hd(this,t,e,n),this}chain(...t){return di(this,...t),this}fan(...t){return t.forEach(e=>this.connect(e)),this}dispose(){return super.dispose(),K(this.input)&&(this.input instanceof $?this.input.dispose():xe(this.input)&&this.input.disconnect()),K(this.output)&&(this.output instanceof $?this.output.dispose():xe(this.output)&&this.output.disconnect()),this._internalChannels=[],this}}function di(...i){const t=i.shift();i.reduce((e,n)=>(e instanceof $?e.connect(n):xe(e)&&En(e,n),n),t)}function En(i,t,e=0,n=0){for(Z(K(i),"Cannot connect from undefined node"),Z(K(t),"Cannot connect to undefined node"),(t instanceof $||xe(t))&&Z(t.numberOfInputs>0,"Cannot connect to node with no inputs"),Z(i.numberOfOutputs>0,"Cannot connect from node with no outputs");t instanceof $||t instanceof dt;)K(t.input)&&(t=t.input);for(;i instanceof $;)K(i.output)&&(i=i.output);qe(t)?i.connect(t,e):i.connect(t,e,n)}function Hd(i,t,e=0,n=0){if(K(t))for(;t instanceof $;)t=t.input;for(;!xe(i);)K(i.output)&&(i=i.output);qe(t)?i.disconnect(t,e):xe(t)?i.disconnect(t,e,n):i.disconnect()}class It extends ${constructor(){super(B(It.getDefaults(),arguments,["gain","units"])),this.name="Gain",this._gainNode=this.context.createGain(),this.input=this._gainNode,this.output=this._gainNode;const t=B(It.getDefaults(),arguments,["gain","units"]);this.gain=new dt({context:this.context,convert:t.convert,param:this._gainNode.gain,units:t.units,value:t.gain,minValue:t.minValue,maxValue:t.maxValue}),yt(this,"gain")}static getDefaults(){return Object.assign($.getDefaults(),{convert:!0,gain:1,units:"gain"})}dispose(){return super.dispose(),this._gainNode.disconnect(),this.gain.dispose(),this}}class gn extends ${constructor(t){super(t),this.onended=at,this._startTime=-1,this._stopTime=-1,this._timeout=-1,this.output=new It({context:this.context,gain:0}),this._gainNode=this.output,this.getStateAtTime=function(e){const n=this.toSeconds(e);return this._startTime!==-1&&n>=this._startTime&&(this._stopTime===-1||n<=this._stopTime)?"started":"stopped"},this._fadeIn=t.fadeIn,this._fadeOut=t.fadeOut,this._curve=t.curve,this.onended=t.onended}static getDefaults(){return Object.assign($.getDefaults(),{curve:"linear",fadeIn:0,fadeOut:0,onended:at})}_startGain(t,e=1){Z(this._startTime===-1,"Source cannot be started more than once");const n=this.toSeconds(this._fadeIn);return this._startTime=t+n,this._startTime=Math.max(this._startTime,this.context.currentTime),n>0?(this._gainNode.gain.setValueAtTime(0,t),this._curve==="linear"?this._gainNode.gain.linearRampToValueAtTime(e,t+n):this._gainNode.gain.exponentialApproachValueAtTime(e,t,n)):this._gainNode.gain.setValueAtTime(e,t),this}stop(t){return this.log("stop",t),this._stopGain(this.toSeconds(t)),this}_stopGain(t){Z(this._startTime!==-1,"'start' must be called before 'stop'"),this.cancelStop();const e=this.toSeconds(this._fadeOut);return this._stopTime=this.toSeconds(t)+e,this._stopTime=Math.max(this._stopTime,this.context.currentTime),e>0?this._curve==="linear"?this._gainNode.gain.linearRampTo(0,e,t):this._gainNode.gain.targetRampTo(0,e,t):(this._gainNode.gain.cancelAndHoldAtTime(t),this._gainNode.gain.setValueAtTime(0,t)),this.context.clearTimeout(this._timeout),this._timeout=this.context.setTimeout(()=>{const n=this._curve==="exponential"?e*2:0;this._stopSource(this.now()+n),this._onended()},this._stopTime-this.context.currentTime),this}_onended(){if(this.onended!==at&&(this.onended(this),this.onended=at,!this.context.isOffline)){const t=()=>this.dispose();typeof window.requestIdleCallback!="undefined"?window.requestIdleCallback(t):setTimeout(t,1e3)}}get state(){return this.getStateAtTime(this.now())}cancelStop(){return this.log("cancelStop"),Z(this._startTime!==-1,"Source is not started"),this._gainNode.gain.cancelScheduledValues(this._startTime+this.sampleTime),this.context.clearTimeout(this._timeout),this._stopTime=-1,this}dispose(){return super.dispose(),this._gainNode.disconnect(),this}}class Cs extends gn{constructor(){super(B(Cs.getDefaults(),arguments,["offset"])),this.name="ToneConstantSource",this._source=this.context.createConstantSource();const t=B(Cs.getDefaults(),arguments,["offset"]);En(this._source,this._gainNode),this.offset=new dt({context:this.context,convert:t.convert,param:this._source.offset,units:t.units,value:t.offset,minValue:t.minValue,maxValue:t.maxValue})}static getDefaults(){return Object.assign(gn.getDefaults(),{convert:!0,offset:1,units:"number"})}start(t){const e=this.toSeconds(t);return this.log("start",e),this._startGain(e),this._source.start(e),this}_stopSource(t){this._source.stop(t)}dispose(){return super.dispose(),this.state==="started"&&this.stop(),this._source.disconnect(),this.offset.dispose(),this}}class xt extends ${constructor(){super(B(xt.getDefaults(),arguments,["value","units"])),this.name="Signal",this.override=!0;const t=B(xt.getDefaults(),arguments,["value","units"]);this.output=this._constantSource=new Cs({context:this.context,convert:t.convert,offset:t.value,units:t.units,minValue:t.minValue,maxValue:t.maxValue}),this._constantSource.start(0),this.input=this._param=this._constantSource.offset}static getDefaults(){return Object.assign($.getDefaults(),{convert:!0,units:"number",value:0})}connect(t,e=0,n=0){return Bi(this,t,e,n),this}dispose(){return super.dispose(),this._param.dispose(),this._constantSource.dispose(),this}setValueAtTime(t,e){return this._param.setValueAtTime(t,e),this}getValueAtTime(t){return this._param.getValueAtTime(t)}setRampPoint(t){return this._param.setRampPoint(t),this}linearRampToValueAtTime(t,e){return this._param.linearRampToValueAtTime(t,e),this}exponentialRampToValueAtTime(t,e){return this._param.exponentialRampToValueAtTime(t,e),this}exponentialRampTo(t,e,n){return this._param.exponentialRampTo(t,e,n),this}linearRampTo(t,e,n){return this._param.linearRampTo(t,e,n),this}targetRampTo(t,e,n){return this._param.targetRampTo(t,e,n),this}exponentialApproachValueAtTime(t,e,n){return this._param.exponentialApproachValueAtTime(t,e,n),this}setTargetAtTime(t,e,n){return this._param.setTargetAtTime(t,e,n),this}setValueCurveAtTime(t,e,n,s){return this._param.setValueCurveAtTime(t,e,n,s),this}cancelScheduledValues(t){return this._param.cancelScheduledValues(t),this}cancelAndHoldAtTime(t){return this._param.cancelAndHoldAtTime(t),this}rampTo(t,e,n){return this._param.rampTo(t,e,n),this}get value(){return this._param.value}set value(t){this._param.value=t}get convert(){return this._param.convert}set convert(t){this._param.convert=t}get units(){return this._param.units}get overridden(){return this._param.overridden}set overridden(t){this._param.overridden=t}get maxValue(){return this._param.maxValue}get minValue(){return this._param.minValue}apply(t){return this._param.apply(t),this}}function Bi(i,t,e,n){(t instanceof dt||qe(t)||t instanceof xt&&t.override)&&(t.cancelScheduledValues(0),t.setValueAtTime(0,0),t instanceof xt&&(t.overridden=!0)),En(i,t,e,n)}class Ms extends dt{constructor(){super(B(Ms.getDefaults(),arguments,["value"])),this.name="TickParam",this._events=new fe(1/0),this._multiplier=1;const t=B(Ms.getDefaults(),arguments,["value"]);this._multiplier=t.multiplier,this._events.cancel(0),this._events.add({ticks:0,time:0,type:"setValueAtTime",value:this._fromType(t.value)}),this.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(dt.getDefaults(),{multiplier:1,units:"hertz",value:1})}setTargetAtTime(t,e,n){e=this.toSeconds(e),this.setRampPoint(e);const s=this._fromType(t),r=this._events.get(e),a=Math.round(Math.max(1/n,1));for(let o=0;o<=a;o++){const c=n*o+e,l=this._exponentialApproach(r.time,r.value,s,n,c);this.linearRampToValueAtTime(this._toType(l),c)}return this}setValueAtTime(t,e){const n=this.toSeconds(e);super.setValueAtTime(t,e);const s=this._events.get(n),r=this._events.previousEvent(s),a=this._getTicksUntilEvent(r,n);return s.ticks=Math.max(a,0),this}linearRampToValueAtTime(t,e){const n=this.toSeconds(e);super.linearRampToValueAtTime(t,e);const s=this._events.get(n),r=this._events.previousEvent(s),a=this._getTicksUntilEvent(r,n);return s.ticks=Math.max(a,0),this}exponentialRampToValueAtTime(t,e){e=this.toSeconds(e);const n=this._fromType(t),s=this._events.get(e),r=Math.round(Math.max((e-s.time)*10,1)),a=(e-s.time)/r;for(let o=0;o<=r;o++){const c=a*o+s.time,l=this._exponentialInterpolate(s.time,s.value,e,n,c);this.linearRampToValueAtTime(this._toType(l),c)}return this}_getTicksUntilEvent(t,e){if(t===null)t={ticks:0,time:0,type:"setValueAtTime",value:0};else if(Ht(t.ticks)){const a=this._events.previousEvent(t);t.ticks=this._getTicksUntilEvent(a,t.time)}const n=this._fromType(this.getValueAtTime(t.time));let s=this._fromType(this.getValueAtTime(e));const r=this._events.get(e);return r&&r.time===e&&r.type==="setValueAtTime"&&(s=this._fromType(this.getValueAtTime(e-this.sampleTime))),.5*(e-t.time)*(n+s)+t.ticks}getTicksAtTime(t){const e=this.toSeconds(t),n=this._events.get(e);return Math.max(this._getTicksUntilEvent(n,e),0)}getDurationOfTicks(t,e){const n=this.toSeconds(e),s=this.getTicksAtTime(e);return this.getTimeOfTick(s+t)-n}getTimeOfTick(t){const e=this._events.get(t,"ticks"),n=this._events.getAfter(t,"ticks");if(e&&e.ticks===t)return e.time;if(e&&n&&n.type==="linearRampToValueAtTime"&&e.value!==n.value){const s=this._fromType(this.getValueAtTime(e.time)),a=(this._fromType(this.getValueAtTime(n.time))-s)/(n.time-e.time),o=Math.sqrt(Math.pow(s,2)-2*a*(e.ticks-t)),c=(-s+o)/a,l=(-s-o)/a;return(c>0?c:l)+e.time}else return e?e.value===0?1/0:e.time+(t-e.ticks)/e.value:t/this._initialValue}ticksToTime(t,e){return this.getDurationOfTicks(t,e)}timeToTicks(t,e){const n=this.toSeconds(e),s=this.toSeconds(t),r=this.getTicksAtTime(n);return this.getTicksAtTime(n+s)-r}_fromType(t){return this.units==="bpm"&&this.multiplier?1/(60/t/this.multiplier):super._fromType(t)}_toType(t){return this.units==="bpm"&&this.multiplier?t/this.multiplier*60:super._toType(t)}get multiplier(){return this._multiplier}set multiplier(t){const e=this.value;this._multiplier=t,this.cancelScheduledValues(0),this.setValueAtTime(e,0)}}class Is extends xt{constructor(){super(B(Is.getDefaults(),arguments,["value"])),this.name="TickSignal";const t=B(Is.getDefaults(),arguments,["value"]);this.input=this._param=new Ms({context:this.context,convert:t.convert,multiplier:t.multiplier,param:this._constantSource.offset,units:t.units,value:t.value})}static getDefaults(){return Object.assign(xt.getDefaults(),{multiplier:1,units:"hertz",value:1})}ticksToTime(t,e){return this._param.ticksToTime(t,e)}timeToTicks(t,e){return this._param.timeToTicks(t,e)}getTimeOfTick(t){return this._param.getTimeOfTick(t)}getDurationOfTicks(t,e){return this._param.getDurationOfTicks(t,e)}getTicksAtTime(t){return this._param.getTicksAtTime(t)}get multiplier(){return this._param.multiplier}set multiplier(t){this._param.multiplier=t}dispose(){return super.dispose(),this._param.dispose(),this}}class Os extends Vt{constructor(){super(B(Os.getDefaults(),arguments,["frequency"])),this.name="TickSource",this._state=new Vi,this._tickOffset=new fe;const t=B(Os.getDefaults(),arguments,["frequency"]);this.frequency=new Is({context:this.context,units:t.units,value:t.frequency}),yt(this,"frequency"),this._state.setStateAtTime("stopped",0),this.setTicksAtTime(0,0)}static getDefaults(){return Object.assign({frequency:1,units:"hertz"},Vt.getDefaults())}get state(){return this.getStateAtTime(this.now())}start(t,e){const n=this.toSeconds(t);return this._state.getValueAtTime(n)!=="started"&&(this._state.setStateAtTime("started",n),K(e)&&this.setTicksAtTime(e,n)),this}stop(t){const e=this.toSeconds(t);if(this._state.getValueAtTime(e)==="stopped"){const n=this._state.get(e);n&&n.time>0&&(this._tickOffset.cancel(n.time),this._state.cancel(n.time))}return this._state.cancel(e),this._state.setStateAtTime("stopped",e),this.setTicksAtTime(0,e),this}pause(t){const e=this.toSeconds(t);return this._state.getValueAtTime(e)==="started"&&this._state.setStateAtTime("paused",e),this}cancel(t){return t=this.toSeconds(t),this._state.cancel(t),this._tickOffset.cancel(t),this}getTicksAtTime(t){const e=this.toSeconds(t),n=this._state.getLastState("stopped",e),s={state:"paused",time:e};this._state.add(s);let r=n,a=0;return this._state.forEachBetween(n.time,e+this.sampleTime,o=>{let c=r.time;const l=this._tickOffset.get(o.time);l&&l.time>=r.time&&(a=l.ticks,c=l.time),r.state==="started"&&o.state!=="started"&&(a+=this.frequency.getTicksAtTime(o.time)-this.frequency.getTicksAtTime(c)),r=o}),this._state.remove(s),a}get ticks(){return this.getTicksAtTime(this.now())}set ticks(t){this.setTicksAtTime(t,this.now())}get seconds(){return this.getSecondsAtTime(this.now())}set seconds(t){const e=this.now(),n=this.frequency.timeToTicks(t,e);this.setTicksAtTime(n,e)}getSecondsAtTime(t){t=this.toSeconds(t);const e=this._state.getLastState("stopped",t),n={state:"paused",time:t};this._state.add(n);let s=e,r=0;return this._state.forEachBetween(e.time,t+this.sampleTime,a=>{let o=s.time;const c=this._tickOffset.get(a.time);c&&c.time>=s.time&&(r=c.seconds,o=c.time),s.state==="started"&&a.state!=="started"&&(r+=a.time-o),s=a}),this._state.remove(n),r}setTicksAtTime(t,e){return e=this.toSeconds(e),this._tickOffset.cancel(e),this._tickOffset.add({seconds:this.frequency.getDurationOfTicks(t,e),ticks:t,time:e}),this}getStateAtTime(t){return t=this.toSeconds(t),this._state.getValueAtTime(t)}getTimeOfTick(t,e=this.now()){const n=this._tickOffset.get(e),s=this._state.get(e),r=Math.max(n.time,s.time),a=this.frequency.getTicksAtTime(r)+t-n.ticks;return this.frequency.getTimeOfTick(a)}forEachTickBetween(t,e,n){let s=this._state.get(t);this._state.forEachBetween(t,e,a=>{s&&s.state==="started"&&a.state!=="started"&&this.forEachTickBetween(Math.max(s.time,t),a.time-this.sampleTime,n),s=a});let r=null;if(s&&s.state==="started"){const a=Math.max(s.time,t),o=this.frequency.getTicksAtTime(a),c=this.frequency.getTicksAtTime(s.time),l=o-c;let u=Math.ceil(l)-l;u=Zt(u,1)?0:u;let h=this.frequency.getTimeOfTick(o+u);for(;h<e;){try{n(h,Math.round(this.getTicksAtTime(h)))}catch(d){r=d;break}h+=this.frequency.getDurationOfTicks(1,h)}}if(r)throw r;return this}dispose(){return super.dispose(),this._state.dispose(),this._tickOffset.dispose(),this.frequency.dispose(),this}}class Bn extends Vt{constructor(){super(B(Bn.getDefaults(),arguments,["callback","frequency"])),this.name="Clock",this.callback=at,this._lastUpdate=0,this._state=new Vi("stopped"),this._boundLoop=this._loop.bind(this);const t=B(Bn.getDefaults(),arguments,["callback","frequency"]);this.callback=t.callback,this._tickSource=new Os({context:this.context,frequency:t.frequency,units:t.units}),this._lastUpdate=0,this.frequency=this._tickSource.frequency,yt(this,"frequency"),this._state.setStateAtTime("stopped",0),this.context.on("tick",this._boundLoop)}static getDefaults(){return Object.assign(Vt.getDefaults(),{callback:at,frequency:1,units:"hertz"})}get state(){return this._state.getValueAtTime(this.now())}start(t,e){va(this.context);const n=this.toSeconds(t);return this.log("start",n),this._state.getValueAtTime(n)!=="started"&&(this._state.setStateAtTime("started",n),this._tickSource.start(n,e),n<this._lastUpdate&&this.emit("start",n,e)),this}stop(t){const e=this.toSeconds(t);return this.log("stop",e),this._state.cancel(e),this._state.setStateAtTime("stopped",e),this._tickSource.stop(e),e<this._lastUpdate&&this.emit("stop",e),this}pause(t){const e=this.toSeconds(t);return this._state.getValueAtTime(e)==="started"&&(this._state.setStateAtTime("paused",e),this._tickSource.pause(e),e<this._lastUpdate&&this.emit("pause",e)),this}get ticks(){return Math.ceil(this.getTicksAtTime(this.now()))}set ticks(t){this._tickSource.ticks=t}get seconds(){return this._tickSource.seconds}set seconds(t){this._tickSource.seconds=t}getSecondsAtTime(t){return this._tickSource.getSecondsAtTime(t)}setTicksAtTime(t,e){return this._tickSource.setTicksAtTime(t,e),this}getTimeOfTick(t,e=this.now()){return this._tickSource.getTimeOfTick(t,e)}getTicksAtTime(t){return this._tickSource.getTicksAtTime(t)}nextTickTime(t,e){const n=this.toSeconds(e),s=this.getTicksAtTime(n);return this._tickSource.getTimeOfTick(s+t,n)}_loop(){const t=this._lastUpdate,e=this.now();this._lastUpdate=e,this.log("loop",t,e),t!==e&&(this._state.forEachBetween(t,e,n=>{switch(n.state){case"started":const s=this._tickSource.getTicksAtTime(n.time);this.emit("start",n.time,s);break;case"stopped":n.time!==0&&this.emit("stop",n.time);break;case"paused":this.emit("pause",n.time);break}}),this._tickSource.forEachTickBetween(t,e,(n,s)=>{this.callback(n,s)}))}getStateAtTime(t){const e=this.toSeconds(t);return this._state.getValueAtTime(e)}dispose(){return super.dispose(),this.context.off("tick",this._boundLoop),this._tickSource.dispose(),this._state.dispose(),this}}rs.mixin(Bn);class os extends we{constructor(){super(),this.name="ToneAudioBuffers",this._buffers=new Map,this._loadingCount=0;const t=B(os.getDefaults(),arguments,["urls","onload","baseUrl"],"urls");this.baseUrl=t.baseUrl,Object.keys(t.urls).forEach(e=>{this._loadingCount++;const n=t.urls[e];this.add(e,n,this._bufferLoaded.bind(this,t.onload),t.onerror)})}static getDefaults(){return{baseUrl:"",onerror:at,onload:at,urls:{}}}has(t){return this._buffers.has(t.toString())}get(t){return Z(this.has(t),`ToneAudioBuffers has no buffer named: ${t}`),this._buffers.get(t.toString())}_bufferLoaded(t){this._loadingCount--,this._loadingCount===0&&t&&t()}get loaded(){return Array.from(this._buffers).every(([t,e])=>e.loaded)}add(t,e,n=at,s=at){return Yt(e)?this._buffers.set(t.toString(),new ct(this.baseUrl+e,n,s)):this._buffers.set(t.toString(),new ct(e,n,s)),this}dispose(){return super.dispose(),this._buffers.forEach(t=>t.dispose()),this._buffers.clear(),this}}class zi extends Ft{constructor(){super(...arguments),this.name="MidiClass",this.defaultUnits="midi"}_frequencyToUnits(t){return Re(super._frequencyToUnits(t))}_ticksToUnits(t){return Re(super._ticksToUnits(t))}_beatsToUnits(t){return Re(super._beatsToUnits(t))}_secondsToUnits(t){return Re(super._secondsToUnits(t))}toMidi(){return this.valueOf()}toFrequency(){return Oa(this.toMidi())}transpose(t){return new zi(this.context,this.toMidi()+t)}}function zn(i,t){return new zi(qt(),i,t)}class me extends kn{constructor(){super(...arguments),this.name="Ticks",this.defaultUnits="i"}_now(){return this.context.transport.ticks}_beatsToUnits(t){return this._getPPQ()*t}_secondsToUnits(t){return Math.floor(t/(60/this._getBpm())*this._getPPQ())}_ticksToUnits(t){return t}toTicks(){return this.valueOf()}toSeconds(){return this.valueOf()/this._getPPQ()*(60/this._getBpm())}}class Yd extends Vt{constructor(){super(...arguments),this.name="Draw",this.expiration=.25,this.anticipation=.008,this._events=new fe,this._boundDrawLoop=this._drawLoop.bind(this),this._animationFrame=-1}schedule(t,e){return this._events.add({callback:t,time:this.toSeconds(e)}),this._events.length===1&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop)),this}cancel(t){return this._events.cancel(this.toSeconds(t)),this}_drawLoop(){const t=this.context.currentTime;for(;this._events.length&&this._events.peek().time-this.anticipation<=t;){const e=this._events.shift();e&&t-e.time<=this.expiration&&e.callback()}this._events.length>0&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop))}dispose(){return super.dispose(),this._events.dispose(),cancelAnimationFrame(this._animationFrame),this}}Gs(i=>{i.draw=new Yd({context:i})});Hs(i=>{i.draw.dispose()});class $d extends we{constructor(){super(...arguments),this.name="IntervalTimeline",this._root=null,this._length=0}add(t){Z(K(t.time),"Events must have a time property"),Z(K(t.duration),"Events must have a duration parameter"),t.time=t.time.valueOf();let e=new Xd(t.time,t.time+t.duration,t);for(this._root===null?this._root=e:this._root.insert(e),this._length++;e!==null;)e.updateHeight(),e.updateMax(),this._rebalance(e),e=e.parent;return this}remove(t){if(this._root!==null){const e=[];this._root.search(t.time,e);for(const n of e)if(n.event===t){this._removeNode(n),this._length--;break}}return this}get length(){return this._length}cancel(t){return this.forEachFrom(t,e=>this.remove(e)),this}_setRoot(t){this._root=t,this._root!==null&&(this._root.parent=null)}_replaceNodeInParent(t,e){t.parent!==null?(t.isLeftChild()?t.parent.left=e:t.parent.right=e,this._rebalance(t.parent)):this._setRoot(e)}_removeNode(t){if(t.left===null&&t.right===null)this._replaceNodeInParent(t,null);else if(t.right===null)this._replaceNodeInParent(t,t.left);else if(t.left===null)this._replaceNodeInParent(t,t.right);else{const e=t.getBalance();let n,s=null;if(e>0)if(t.left.right===null)n=t.left,n.right=t.right,s=n;else{for(n=t.left.right;n.right!==null;)n=n.right;n.parent&&(n.parent.right=n.left,s=n.parent,n.left=t.left,n.right=t.right)}else if(t.right.left===null)n=t.right,n.left=t.left,s=n;else{for(n=t.right.left;n.left!==null;)n=n.left;n.parent&&(n.parent.left=n.right,s=n.parent,n.left=t.left,n.right=t.right)}t.parent!==null?t.isLeftChild()?t.parent.left=n:t.parent.right=n:this._setRoot(n),s&&this._rebalance(s)}t.dispose()}_rotateLeft(t){const e=t.parent,n=t.isLeftChild(),s=t.right;s&&(t.right=s.left,s.left=t),e!==null?n?e.left=s:e.right=s:this._setRoot(s)}_rotateRight(t){const e=t.parent,n=t.isLeftChild(),s=t.left;s&&(t.left=s.right,s.right=t),e!==null?n?e.left=s:e.right=s:this._setRoot(s)}_rebalance(t){const e=t.getBalance();e>1&&t.left?t.left.getBalance()<0?this._rotateLeft(t.left):this._rotateRight(t):e<-1&&t.right&&(t.right.getBalance()>0?this._rotateRight(t.right):this._rotateLeft(t))}get(t){if(this._root!==null){const e=[];if(this._root.search(t,e),e.length>0){let n=e[0];for(let s=1;s<e.length;s++)e[s].low>n.low&&(n=e[s]);return n.event}}return null}forEach(t){if(this._root!==null){const e=[];this._root.traverse(n=>e.push(n)),e.forEach(n=>{n.event&&t(n.event)})}return this}forEachAtTime(t,e){if(this._root!==null){const n=[];this._root.search(t,n),n.forEach(s=>{s.event&&e(s.event)})}return this}forEachFrom(t,e){if(this._root!==null){const n=[];this._root.searchAfter(t,n),n.forEach(s=>{s.event&&e(s.event)})}return this}dispose(){return super.dispose(),this._root!==null&&this._root.traverse(t=>t.dispose()),this._root=null,this}}class Xd{constructor(t,e,n){this._left=null,this._right=null,this.parent=null,this.height=0,this.event=n,this.low=t,this.high=e,this.max=this.high}insert(t){t.low<=this.low?this.left===null?this.left=t:this.left.insert(t):this.right===null?this.right=t:this.right.insert(t)}search(t,e){t>this.max||(this.left!==null&&this.left.search(t,e),this.low<=t&&this.high>t&&e.push(this),!(this.low>t)&&this.right!==null&&this.right.search(t,e))}searchAfter(t,e){this.low>=t&&(e.push(this),this.left!==null&&this.left.searchAfter(t,e)),this.right!==null&&this.right.searchAfter(t,e)}traverse(t){t(this),this.left!==null&&this.left.traverse(t),this.right!==null&&this.right.traverse(t)}updateHeight(){this.left!==null&&this.right!==null?this.height=Math.max(this.left.height,this.right.height)+1:this.right!==null?this.height=this.right.height+1:this.left!==null?this.height=this.left.height+1:this.height=0}updateMax(){this.max=this.high,this.left!==null&&(this.max=Math.max(this.max,this.left.max)),this.right!==null&&(this.max=Math.max(this.max,this.right.max))}getBalance(){let t=0;return this.left!==null&&this.right!==null?t=this.left.height-this.right.height:this.left!==null?t=this.left.height+1:this.right!==null&&(t=-(this.right.height+1)),t}isLeftChild(){return this.parent!==null&&this.parent.left===this}get left(){return this._left}set left(t){this._left=t,t!==null&&(t.parent=this),this.updateHeight(),this.updateMax()}get right(){return this._right}set right(t){this._right=t,t!==null&&(t.parent=this),this.updateHeight(),this.updateMax()}dispose(){this.parent=null,this._left=null,this._right=null,this.event=null}}class Me extends ${constructor(){super(B(Me.getDefaults(),arguments,["volume"])),this.name="Volume";const t=B(Me.getDefaults(),arguments,["volume"]);this.input=this.output=new It({context:this.context,gain:t.volume,units:"decibels"}),this.volume=this.output.gain,yt(this,"volume"),this._unmutedVolume=t.volume,this.mute=t.mute}static getDefaults(){return Object.assign($.getDefaults(),{mute:!1,volume:0})}get mute(){return this.volume.value===-1/0}set mute(t){!this.mute&&t?(this._unmutedVolume=this.volume.value,this.volume.value=-1/0):this.mute&&!t&&(this.volume.value=this._unmutedVolume)}dispose(){return super.dispose(),this.input.dispose(),this.volume.dispose(),this}}class ks extends ${constructor(){super(B(ks.getDefaults(),arguments)),this.name="Destination",this.input=new Me({context:this.context}),this.output=new It({context:this.context}),this.volume=this.input.volume;const t=B(ks.getDefaults(),arguments);di(this.input,this.output,this.context.rawContext.destination),this.mute=t.mute,this._internalChannels=[this.input,this.context.rawContext.destination,this.output]}static getDefaults(){return Object.assign($.getDefaults(),{mute:!1,volume:0})}get mute(){return this.input.mute}set mute(t){this.input.mute=t}chain(...t){return this.input.disconnect(),t.unshift(this.input),t.push(this.output),di(...t),this}get maxChannelCount(){return this.context.rawContext.destination.maxChannelCount}dispose(){return super.dispose(),this.volume.dispose(),this}}Gs(i=>{i.destination=new ks({context:i})});Hs(i=>{i.destination.dispose()});class Zd extends we{constructor(t){super(),this.name="TimelineValue",this._timeline=new fe({memory:10}),this._initialValue=t}set(t,e){return this._timeline.add({value:t,time:e}),this}get(t){const e=this._timeline.get(t);return e?e.value:this._initialValue}}class Ie{constructor(t,e){this.id=Ie._eventId++;const n=Object.assign(Ie.getDefaults(),e);this.transport=t,this.callback=n.callback,this._once=n.once,this.time=n.time}static getDefaults(){return{callback:at,once:!1,time:0}}invoke(t){this.callback&&(this.callback(t),this._once&&this.transport.clear(this.id))}dispose(){return this.callback=void 0,this}}Ie._eventId=0;class Ui extends Ie{constructor(t,e){super(t,e),this._currentId=-1,this._nextId=-1,this._nextTick=this.time,this._boundRestart=this._restart.bind(this);const n=Object.assign(Ui.getDefaults(),e);this.duration=new me(t.context,n.duration).valueOf(),this._interval=new me(t.context,n.interval).valueOf(),this._nextTick=n.time,this.transport.on("start",this._boundRestart),this.transport.on("loopStart",this._boundRestart),this.context=this.transport.context,this._restart()}static getDefaults(){return Object.assign({},Ie.getDefaults(),{duration:1/0,interval:1,once:!1})}invoke(t){this._createEvents(t),super.invoke(t)}_createEvents(t){const e=this.transport.getTicksAtTime(t);e>=this.time&&e>=this._nextTick&&this._nextTick+this._interval<this.time+this.duration&&(this._nextTick+=this._interval,this._currentId=this._nextId,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new me(this.context,this._nextTick).toSeconds()))}_restart(t){this.transport.clear(this._currentId),this.transport.clear(this._nextId),this._nextTick=this.time;const e=this.transport.getTicksAtTime(t);e>this.time&&(this._nextTick=this.time+Math.ceil((e-this.time)/this._interval)*this._interval),this._currentId=this.transport.scheduleOnce(this.invoke.bind(this),new me(this.context,this._nextTick).toSeconds()),this._nextTick+=this._interval,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new me(this.context,this._nextTick).toSeconds())}dispose(){return super.dispose(),this.transport.clear(this._currentId),this.transport.clear(this._nextId),this.transport.off("start",this._boundRestart),this.transport.off("loopStart",this._boundRestart),this}}class Un extends Vt{constructor(){super(B(Un.getDefaults(),arguments)),this.name="Transport",this._loop=new Zd(!1),this._loopStart=0,this._loopEnd=0,this._scheduledEvents={},this._timeline=new fe,this._repeatedEvents=new $d,this._syncedSignals=[],this._swingAmount=0;const t=B(Un.getDefaults(),arguments);this._ppq=t.ppq,this._clock=new Bn({callback:this._processTick.bind(this),context:this.context,frequency:0,units:"bpm"}),this._bindClockEvents(),this.bpm=this._clock.frequency,this._clock.frequency.multiplier=t.ppq,this.bpm.setValueAtTime(t.bpm,0),yt(this,"bpm"),this._timeSignature=t.timeSignature,this._swingTicks=t.ppq/2}static getDefaults(){return Object.assign(Vt.getDefaults(),{bpm:120,loopEnd:"4m",loopStart:0,ppq:192,swing:0,swingSubdivision:"8n",timeSignature:4})}_processTick(t,e){if(this._loop.get(t)&&e>=this._loopEnd&&(this.emit("loopEnd",t),this._clock.setTicksAtTime(this._loopStart,t),e=this._loopStart,this.emit("loopStart",t,this._clock.getSecondsAtTime(t)),this.emit("loop",t)),this._swingAmount>0&&e%this._ppq!==0&&e%(this._swingTicks*2)!==0){const n=e%(this._swingTicks*2)/(this._swingTicks*2),s=Math.sin(n*Math.PI)*this._swingAmount;t+=new me(this.context,this._swingTicks*2/3).toSeconds()*s}this._timeline.forEachAtTime(e,n=>n.invoke(t))}schedule(t,e){const n=new Ie(this,{callback:t,time:new kn(this.context,e).toTicks()});return this._addEvent(n,this._timeline)}scheduleRepeat(t,e,n,s=1/0){const r=new Ui(this,{callback:t,duration:new Qt(this.context,s).toTicks(),interval:new Qt(this.context,e).toTicks(),time:new kn(this.context,n).toTicks()});return this._addEvent(r,this._repeatedEvents)}scheduleOnce(t,e){const n=new Ie(this,{callback:t,once:!0,time:new kn(this.context,e).toTicks()});return this._addEvent(n,this._timeline)}clear(t){if(this._scheduledEvents.hasOwnProperty(t)){const e=this._scheduledEvents[t.toString()];e.timeline.remove(e.event),e.event.dispose(),delete this._scheduledEvents[t.toString()]}return this}_addEvent(t,e){return this._scheduledEvents[t.id.toString()]={event:t,timeline:e},e.add(t),t.id}cancel(t=0){const e=this.toTicks(t);return this._timeline.forEachFrom(e,n=>this.clear(n.id)),this._repeatedEvents.forEachFrom(e,n=>this.clear(n.id)),this}_bindClockEvents(){this._clock.on("start",(t,e)=>{e=new me(this.context,e).toSeconds(),this.emit("start",t,e)}),this._clock.on("stop",t=>{this.emit("stop",t)}),this._clock.on("pause",t=>{this.emit("pause",t)})}get state(){return this._clock.getStateAtTime(this.now())}start(t,e){let n;return K(e)&&(n=this.toTicks(e)),this._clock.start(t,n),this}stop(t){return this._clock.stop(t),this}pause(t){return this._clock.pause(t),this}toggle(t){return t=this.toSeconds(t),this._clock.getStateAtTime(t)!=="started"?this.start(t):this.stop(t),this}get timeSignature(){return this._timeSignature}set timeSignature(t){ee(t)&&(t=t[0]/t[1]*4),this._timeSignature=t}get loopStart(){return new Qt(this.context,this._loopStart,"i").toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t)}get loopEnd(){return new Qt(this.context,this._loopEnd,"i").toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t)}get loop(){return this._loop.get(this.now())}set loop(t){this._loop.set(t,this.now())}setLoopPoints(t,e){return this.loopStart=t,this.loopEnd=e,this}get swing(){return this._swingAmount}set swing(t){this._swingAmount=t}get swingSubdivision(){return new me(this.context,this._swingTicks).toNotation()}set swingSubdivision(t){this._swingTicks=this.toTicks(t)}get position(){const t=this.now(),e=this._clock.getTicksAtTime(t);return new me(this.context,e).toBarsBeatsSixteenths()}set position(t){const e=this.toTicks(t);this.ticks=e}get seconds(){return this._clock.seconds}set seconds(t){const e=this.now(),n=this._clock.frequency.timeToTicks(t,e);this.ticks=n}get progress(){if(this.loop){const t=this.now();return(this._clock.getTicksAtTime(t)-this._loopStart)/(this._loopEnd-this._loopStart)}else return 0}get ticks(){return this._clock.ticks}set ticks(t){if(this._clock.ticks!==t){const e=this.now();if(this.state==="started"){const n=this._clock.getTicksAtTime(e),s=this._clock.frequency.getDurationOfTicks(Math.ceil(n)-n,e),r=e+s;this.emit("stop",r),this._clock.setTicksAtTime(t,r),this.emit("start",r,this._clock.getSecondsAtTime(r))}else this._clock.setTicksAtTime(t,e)}}getTicksAtTime(t){return Math.round(this._clock.getTicksAtTime(t))}getSecondsAtTime(t){return this._clock.getSecondsAtTime(t)}get PPQ(){return this._clock.frequency.multiplier}set PPQ(t){this._clock.frequency.multiplier=t}nextSubdivision(t){if(t=this.toTicks(t),this.state!=="started")return 0;{const e=this.now(),n=this.getTicksAtTime(e),s=t-n%t;return this._clock.nextTickTime(s,e)}}syncSignal(t,e){if(!e){const s=this.now();if(t.getValueAtTime(s)!==0){const r=this.bpm.getValueAtTime(s),a=1/(60/r/this.PPQ);e=t.getValueAtTime(s)/a}else e=0}const n=new It(e);return this.bpm.connect(n),n.connect(t._param),this._syncedSignals.push({initial:t.value,ratio:n,signal:t}),t.value=0,this}unsyncSignal(t){for(let e=this._syncedSignals.length-1;e>=0;e--){const n=this._syncedSignals[e];n.signal===t&&(n.ratio.dispose(),n.signal.value=n.initial,this._syncedSignals.splice(e,1))}return this}dispose(){return super.dispose(),this._clock.dispose(),Aa(this,"bpm"),this._timeline.dispose(),this._repeatedEvents.dispose(),this}}rs.mixin(Un);Gs(i=>{i.transport=new Un({context:i})});Hs(i=>{i.transport.dispose()});class Wt extends ${constructor(t){super(t),this.input=void 0,this._state=new Vi("stopped"),this._synced=!1,this._scheduled=[],this._syncedStart=at,this._syncedStop=at,this._state.memory=100,this._state.increasing=!0,this._volume=this.output=new Me({context:this.context,mute:t.mute,volume:t.volume}),this.volume=this._volume.volume,yt(this,"volume"),this.onstop=t.onstop}static getDefaults(){return Object.assign($.getDefaults(),{mute:!1,onstop:at,volume:0})}get state(){return this._synced?this.context.transport.state==="started"?this._state.getValueAtTime(this.context.transport.seconds):"stopped":this._state.getValueAtTime(this.now())}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}_clampToCurrentTime(t){return this._synced?t:Math.max(t,this.context.currentTime)}start(t,e,n){let s=Ht(t)&&this._synced?this.context.transport.seconds:this.toSeconds(t);if(s=this._clampToCurrentTime(s),!this._synced&&this._state.getValueAtTime(s)==="started")Z(As(s,this._state.get(s).time),"Start time must be strictly greater than previous start time"),this._state.cancel(s),this._state.setStateAtTime("started",s),this.log("restart",s),this.restart(s,e,n);else if(this.log("start",s),this._state.setStateAtTime("started",s),this._synced){const r=this._state.get(s);r&&(r.offset=this.toSeconds(un(e,0)),r.duration=n?this.toSeconds(n):void 0);const a=this.context.transport.schedule(o=>{this._start(o,e,n)},s);this._scheduled.push(a),this.context.transport.state==="started"&&this.context.transport.getSecondsAtTime(this.immediate())>s&&this._syncedStart(this.now(),this.context.transport.seconds)}else va(this.context),this._start(s,e,n);return this}stop(t){let e=Ht(t)&&this._synced?this.context.transport.seconds:this.toSeconds(t);if(e=this._clampToCurrentTime(e),this._state.getValueAtTime(e)==="started"||K(this._state.getNextState("started",e))){if(this.log("stop",e),!this._synced)this._stop(e);else{const n=this.context.transport.schedule(this._stop.bind(this),e);this._scheduled.push(n)}this._state.cancel(e),this._state.setStateAtTime("stopped",e)}return this}restart(t,e,n){return t=this.toSeconds(t),this._state.getValueAtTime(t)==="started"&&(this._state.cancel(t),this._restart(t,e,n)),this}sync(){return this._synced||(this._synced=!0,this._syncedStart=(t,e)=>{if(e>0){const n=this._state.get(e);if(n&&n.state==="started"&&n.time!==e){const s=e-this.toSeconds(n.time);let r;n.duration&&(r=this.toSeconds(n.duration)-s),this._start(t,this.toSeconds(n.offset)+s,r)}}},this._syncedStop=t=>{const e=this.context.transport.getSecondsAtTime(Math.max(t-this.sampleTime,0));this._state.getValueAtTime(e)==="started"&&this._stop(t)},this.context.transport.on("start",this._syncedStart),this.context.transport.on("loopStart",this._syncedStart),this.context.transport.on("stop",this._syncedStop),this.context.transport.on("pause",this._syncedStop),this.context.transport.on("loopEnd",this._syncedStop)),this}unsync(){return this._synced&&(this.context.transport.off("stop",this._syncedStop),this.context.transport.off("pause",this._syncedStop),this.context.transport.off("loopEnd",this._syncedStop),this.context.transport.off("start",this._syncedStart),this.context.transport.off("loopStart",this._syncedStart)),this._synced=!1,this._scheduled.forEach(t=>this.context.transport.clear(t)),this._scheduled=[],this._state.cancel(0),this._stop(0),this}dispose(){return super.dispose(),this.onstop=at,this.unsync(),this._volume.dispose(),this._state.dispose(),this}}class We extends gn{constructor(){super(B(We.getDefaults(),arguments,["url","onload"])),this.name="ToneBufferSource",this._source=this.context.createBufferSource(),this._internalChannels=[this._source],this._sourceStarted=!1,this._sourceStopped=!1;const t=B(We.getDefaults(),arguments,["url","onload"]);En(this._source,this._gainNode),this._source.onended=()=>this._stopSource(),this.playbackRate=new dt({context:this.context,param:this._source.playbackRate,units:"positive",value:t.playbackRate}),this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this._buffer=new ct(t.url,t.onload,t.onerror),this._internalChannels.push(this._source)}static getDefaults(){return Object.assign(gn.getDefaults(),{url:new ct,loop:!1,loopEnd:0,loopStart:0,onload:at,onerror:at,playbackRate:1})}get fadeIn(){return this._fadeIn}set fadeIn(t){this._fadeIn=t}get fadeOut(){return this._fadeOut}set fadeOut(t){this._fadeOut=t}get curve(){return this._curve}set curve(t){this._curve=t}start(t,e,n,s=1){Z(this.buffer.loaded,"buffer is either not set or not loaded");const r=this.toSeconds(t);this._startGain(r,s),this.loop?e=un(e,this.loopStart):e=un(e,0);let a=Math.max(this.toSeconds(e),0);if(this.loop){const o=this.toSeconds(this.loopEnd)||this.buffer.duration,c=this.toSeconds(this.loopStart),l=o-c;hi(a,o)&&(a=(a-c)%l+c),Zt(a,this.buffer.duration)&&(a=0)}if(this._source.buffer=this.buffer.get(),this._source.loopEnd=this.toSeconds(this.loopEnd)||this.buffer.duration,Ea(a,this.buffer.duration)&&(this._sourceStarted=!0,this._source.start(r,a)),K(n)){let o=this.toSeconds(n);o=Math.max(o,0),this.stop(r+o)}return this}_stopSource(t){!this._sourceStopped&&this._sourceStarted&&(this._sourceStopped=!0,this._source.stop(this.toSeconds(t)),this._onended())}get loopStart(){return this._source.loopStart}set loopStart(t){this._source.loopStart=this.toSeconds(t)}get loopEnd(){return this._source.loopEnd}set loopEnd(t){this._source.loopEnd=this.toSeconds(t)}get buffer(){return this._buffer}set buffer(t){this._buffer.set(t)}get loop(){return this._source.loop}set loop(t){this._source.loop=t,this._sourceStarted&&this.cancelStop()}dispose(){return super.dispose(),this._source.onended=null,this._source.disconnect(),this._buffer.dispose(),this.playbackRate.dispose(),this}}function Je(i,t){return Et(this,void 0,void 0,function*(){const e=t/i.context.sampleRate,n=new Li(1,e,i.context.sampleRate);return new i.constructor(Object.assign(i.get(),{frequency:2/e,detune:0,context:n})).toDestination().start(0),(yield n.render()).getChannelData(0)})}class Ds extends gn{constructor(){super(B(Ds.getDefaults(),arguments,["frequency","type"])),this.name="ToneOscillatorNode",this._oscillator=this.context.createOscillator(),this._internalChannels=[this._oscillator];const t=B(Ds.getDefaults(),arguments,["frequency","type"]);En(this._oscillator,this._gainNode),this.type=t.type,this.frequency=new dt({context:this.context,param:this._oscillator.frequency,units:"frequency",value:t.frequency}),this.detune=new dt({context:this.context,param:this._oscillator.detune,units:"cents",value:t.detune}),yt(this,["frequency","detune"])}static getDefaults(){return Object.assign(gn.getDefaults(),{detune:0,frequency:440,type:"sine"})}start(t){const e=this.toSeconds(t);return this.log("start",e),this._startGain(e),this._oscillator.start(e),this}_stopSource(t){this._oscillator.stop(t)}setPeriodicWave(t){return this._oscillator.setPeriodicWave(t),this}get type(){return this._oscillator.type}set type(t){this._oscillator.type=t}dispose(){return super.dispose(),this.state==="started"&&this.stop(),this._oscillator.disconnect(),this.frequency.dispose(),this.detune.dispose(),this}}class bt extends Wt{constructor(){super(B(bt.getDefaults(),arguments,["frequency","type"])),this.name="Oscillator",this._oscillator=null;const t=B(bt.getDefaults(),arguments,["frequency","type"]);this.frequency=new xt({context:this.context,units:"frequency",value:t.frequency}),yt(this,"frequency"),this.detune=new xt({context:this.context,units:"cents",value:t.detune}),yt(this,"detune"),this._partials=t.partials,this._partialCount=t.partialCount,this._type=t.type,t.partialCount&&t.type!=="custom"&&(this._type=this.baseType+t.partialCount.toString()),this.phase=t.phase}static getDefaults(){return Object.assign(Wt.getDefaults(),{detune:0,frequency:440,partialCount:0,partials:[],phase:0,type:"sine"})}_start(t){const e=this.toSeconds(t),n=new Ds({context:this.context,onended:()=>this.onstop(this)});this._oscillator=n,this._wave?this._oscillator.setPeriodicWave(this._wave):this._oscillator.type=this._type,this._oscillator.connect(this.output),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.start(e)}_stop(t){const e=this.toSeconds(t);this._oscillator&&this._oscillator.stop(e)}_restart(t){const e=this.toSeconds(t);return this.log("restart",e),this._oscillator&&this._oscillator.cancelStop(),this._state.cancel(e),this}syncFrequency(){return this.context.transport.syncSignal(this.frequency),this}unsyncFrequency(){return this.context.transport.unsyncSignal(this.frequency),this}_getCachedPeriodicWave(){if(this._type==="custom")return bt._periodicWaveCache.find(e=>e.phase===this._phase&&Od(e.partials,this._partials));{const t=bt._periodicWaveCache.find(e=>e.type===this._type&&e.phase===this._phase);return this._partialCount=t?t.partialCount:this._partialCount,t}}get type(){return this._type}set type(t){this._type=t;const e=["sine","square","sawtooth","triangle"].indexOf(t)!==-1;if(this._phase===0&&e)this._wave=void 0,this._partialCount=0,this._oscillator!==null&&(this._oscillator.type=t);else{const n=this._getCachedPeriodicWave();if(K(n)){const{partials:s,wave:r}=n;this._wave=r,this._partials=s,this._oscillator!==null&&this._oscillator.setPeriodicWave(this._wave)}else{const[s,r]=this._getRealImaginary(t,this._phase),a=this.context.createPeriodicWave(s,r);this._wave=a,this._oscillator!==null&&this._oscillator.setPeriodicWave(this._wave),bt._periodicWaveCache.push({imag:r,partialCount:this._partialCount,partials:this._partials,phase:this._phase,real:s,type:this._type,wave:this._wave}),bt._periodicWaveCache.length>100&&bt._periodicWaveCache.shift()}}}get baseType(){return this._type.replace(this.partialCount.toString(),"")}set baseType(t){this.partialCount&&this._type!=="custom"&&t!=="custom"?this.type=t+this.partialCount:this.type=t}get partialCount(){return this._partialCount}set partialCount(t){Ce(t,0);let e=this._type;const n=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);if(n&&(e=n[1]),this._type!=="custom")t===0?this.type=e:this.type=e+t.toString();else{const s=new Float32Array(t);this._partials.forEach((r,a)=>s[a]=r),this._partials=Array.from(s),this.type=this._type}}_getRealImaginary(t,e){let s=2048;const r=new Float32Array(s),a=new Float32Array(s);let o=1;if(t==="custom"){if(o=this._partials.length+1,this._partialCount=this._partials.length,s=o,this._partials.length===0)return[r,a]}else{const c=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);c?(o=parseInt(c[2],10)+1,this._partialCount=parseInt(c[2],10),t=c[1],o=Math.max(o,2),s=o):this._partialCount=0,this._partials=[]}for(let c=1;c<s;++c){const l=2/(c*Math.PI);let u;switch(t){case"sine":u=c<=o?1:0,this._partials[c-1]=u;break;case"square":u=c&1?2*l:0,this._partials[c-1]=u;break;case"sawtooth":u=l*(c&1?1:-1),this._partials[c-1]=u;break;case"triangle":c&1?u=2*(l*l)*(c-1>>1&1?-1:1):u=0,this._partials[c-1]=u;break;case"custom":u=this._partials[c-1];break;default:throw new TypeError("Oscillator: invalid type: "+t)}u!==0?(r[c]=-u*Math.sin(e*c),a[c]=u*Math.cos(e*c)):(r[c]=0,a[c]=0)}return[r,a]}_inverseFFT(t,e,n){let s=0;const r=t.length;for(let a=0;a<r;a++)s+=t[a]*Math.cos(a*n)+e[a]*Math.sin(a*n);return s}getInitialValue(){const[t,e]=this._getRealImaginary(this._type,0);let n=0;const s=Math.PI*2,r=32;for(let a=0;a<r;a++)n=Math.max(this._inverseFFT(t,e,a/r*s),n);return Dd(-this._inverseFFT(t,e,this._phase)/n,-1,1)}get partials(){return this._partials.slice(0,this.partialCount)}set partials(t){this._partials=t,this._partialCount=this._partials.length,t.length&&(this.type="custom")}get phase(){return this._phase*(180/Math.PI)}set phase(t){this._phase=t*Math.PI/180,this.type=this._type}asArray(t=1024){return Et(this,void 0,void 0,function*(){return Je(this,t)})}dispose(){return super.dispose(),this._oscillator!==null&&this._oscillator.dispose(),this._wave=void 0,this.frequency.dispose(),this.detune.dispose(),this}}bt._periodicWaveCache=[];class $s extends ${constructor(){super(Object.assign(B($s.getDefaults(),arguments,["context"])))}connect(t,e=0,n=0){return Bi(this,t,e,n),this}}class qn extends $s{constructor(){super(Object.assign(B(qn.getDefaults(),arguments,["mapping","length"]))),this.name="WaveShaper",this._shaper=this.context.createWaveShaper(),this.input=this._shaper,this.output=this._shaper;const t=B(qn.getDefaults(),arguments,["mapping","length"]);ee(t.mapping)||t.mapping instanceof Float32Array?this.curve=Float32Array.from(t.mapping):Ed(t.mapping)&&this.setMap(t.mapping,t.length)}static getDefaults(){return Object.assign(xt.getDefaults(),{length:1024})}setMap(t,e=1024){const n=new Float32Array(e);for(let s=0,r=e;s<r;s++){const a=s/(r-1)*2-1;n[s]=t(a,s)}return this.curve=n,this}get curve(){return this._shaper.curve}set curve(t){this._shaper.curve=t}get oversample(){return this._shaper.oversample}set oversample(t){const e=["none","2x","4x"].some(n=>n.includes(t));Z(e,"oversampling must be either 'none', '2x', or '4x'"),this._shaper.oversample=t}dispose(){return super.dispose(),this._shaper.disconnect(),this}}class Kd extends $s{constructor(){super(...arguments),this.name="AudioToGain",this._norm=new qn({context:this.context,mapping:t=>(t+1)/2}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class je extends xt{constructor(){super(Object.assign(B(je.getDefaults(),arguments,["value"]))),this.name="Multiply",this.override=!1;const t=B(je.getDefaults(),arguments,["value"]);this._mult=this.input=this.output=new It({context:this.context,minValue:t.minValue,maxValue:t.maxValue}),this.factor=this._param=this._mult.gain,this.factor.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(xt.getDefaults(),{value:0})}dispose(){return super.dispose(),this._mult.dispose(),this}}class Wn extends Wt{constructor(){super(B(Wn.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="AMOscillator",this._modulationScale=new Kd({context:this.context}),this._modulationNode=new It({context:this.context});const t=B(Wn.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new bt({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase,type:t.type}),this.frequency=this._carrier.frequency,this.detune=this._carrier.detune,this._modulator=new bt({context:this.context,phase:t.phase,type:t.modulationType}),this.harmonicity=new je({context:this.context,units:"positive",value:t.harmonicity}),this.frequency.chain(this.harmonicity,this._modulator.frequency),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output),yt(this,["frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(bt.getDefaults(),{harmonicity:1,modulationType:"square"})}_start(t){this._modulator.start(t),this._carrier.start(t)}_stop(t){this._modulator.stop(t),this._carrier.stop(t)}_restart(t){this._modulator.restart(t),this._carrier.restart(t)}get type(){return this._carrier.type}set type(t){this._carrier.type=t}get baseType(){return this._carrier.baseType}set baseType(t){this._carrier.baseType=t}get partialCount(){return this._carrier.partialCount}set partialCount(t){this._carrier.partialCount=t}get modulationType(){return this._modulator.type}set modulationType(t){this._modulator.type=t}get phase(){return this._carrier.phase}set phase(t){this._carrier.phase=t,this._modulator.phase=t}get partials(){return this._carrier.partials}set partials(t){this._carrier.partials=t}asArray(t=1024){return Et(this,void 0,void 0,function*(){return Je(this,t)})}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this._modulationScale.dispose(),this}}class jn extends Wt{constructor(){super(B(jn.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="FMOscillator",this._modulationNode=new It({context:this.context,gain:0});const t=B(jn.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new bt({context:this.context,detune:t.detune,frequency:0,onstop:()=>this.onstop(this),phase:t.phase,type:t.type}),this.detune=this._carrier.detune,this.frequency=new xt({context:this.context,units:"frequency",value:t.frequency}),this._modulator=new bt({context:this.context,phase:t.phase,type:t.modulationType}),this.harmonicity=new je({context:this.context,units:"positive",value:t.harmonicity}),this.modulationIndex=new je({context:this.context,units:"positive",value:t.modulationIndex}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.frequency.chain(this.modulationIndex,this._modulationNode),this._modulator.connect(this._modulationNode.gain),this._modulationNode.connect(this._carrier.frequency),this._carrier.connect(this.output),this.detune.connect(this._modulator.detune),yt(this,["modulationIndex","frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(bt.getDefaults(),{harmonicity:1,modulationIndex:2,modulationType:"square"})}_start(t){this._modulator.start(t),this._carrier.start(t)}_stop(t){this._modulator.stop(t),this._carrier.stop(t)}_restart(t){return this._modulator.restart(t),this._carrier.restart(t),this}get type(){return this._carrier.type}set type(t){this._carrier.type=t}get baseType(){return this._carrier.baseType}set baseType(t){this._carrier.baseType=t}get partialCount(){return this._carrier.partialCount}set partialCount(t){this._carrier.partialCount=t}get modulationType(){return this._modulator.type}set modulationType(t){this._modulator.type=t}get phase(){return this._carrier.phase}set phase(t){this._carrier.phase=t,this._modulator.phase=t}get partials(){return this._carrier.partials}set partials(t){this._carrier.partials=t}asArray(t=1024){return Et(this,void 0,void 0,function*(){return Je(this,t)})}dispose(){return super.dispose(),this.frequency.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this.modulationIndex.dispose(),this}}class _n extends Wt{constructor(){super(B(_n.getDefaults(),arguments,["frequency","width"])),this.name="PulseOscillator",this._widthGate=new It({context:this.context,gain:0}),this._thresh=new qn({context:this.context,mapping:e=>e<=0?-1:1});const t=B(_n.getDefaults(),arguments,["frequency","width"]);this.width=new xt({context:this.context,units:"audioRange",value:t.width}),this._triangle=new bt({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase,type:"triangle"}),this.frequency=this._triangle.frequency,this.detune=this._triangle.detune,this._triangle.chain(this._thresh,this.output),this.width.chain(this._widthGate,this._thresh),yt(this,["width","frequency","detune"])}static getDefaults(){return Object.assign(Wt.getDefaults(),{detune:0,frequency:440,phase:0,type:"pulse",width:.2})}_start(t){t=this.toSeconds(t),this._triangle.start(t),this._widthGate.gain.setValueAtTime(1,t)}_stop(t){t=this.toSeconds(t),this._triangle.stop(t),this._widthGate.gain.cancelScheduledValues(t),this._widthGate.gain.setValueAtTime(0,t)}_restart(t){this._triangle.restart(t),this._widthGate.gain.cancelScheduledValues(t),this._widthGate.gain.setValueAtTime(1,t)}get phase(){return this._triangle.phase}set phase(t){this._triangle.phase=t}get type(){return"pulse"}get baseType(){return"pulse"}get partials(){return[]}get partialCount(){return 0}set carrierType(t){this._triangle.type=t}asArray(t=1024){return Et(this,void 0,void 0,function*(){return Je(this,t)})}dispose(){return super.dispose(),this._triangle.dispose(),this.width.dispose(),this._widthGate.dispose(),this._thresh.dispose(),this}}class Gn extends Wt{constructor(){super(B(Gn.getDefaults(),arguments,["frequency","type","spread"])),this.name="FatOscillator",this._oscillators=[];const t=B(Gn.getDefaults(),arguments,["frequency","type","spread"]);this.frequency=new xt({context:this.context,units:"frequency",value:t.frequency}),this.detune=new xt({context:this.context,units:"cents",value:t.detune}),this._spread=t.spread,this._type=t.type,this._phase=t.phase,this._partials=t.partials,this._partialCount=t.partialCount,this.count=t.count,yt(this,["frequency","detune"])}static getDefaults(){return Object.assign(bt.getDefaults(),{count:3,spread:20,type:"sawtooth"})}_start(t){t=this.toSeconds(t),this._forEach(e=>e.start(t))}_stop(t){t=this.toSeconds(t),this._forEach(e=>e.stop(t))}_restart(t){this._forEach(e=>e.restart(t))}_forEach(t){for(let e=0;e<this._oscillators.length;e++)t(this._oscillators[e],e)}get type(){return this._type}set type(t){this._type=t,this._forEach(e=>e.type=t)}get spread(){return this._spread}set spread(t){if(this._spread=t,this._oscillators.length>1){const e=-t/2,n=t/(this._oscillators.length-1);this._forEach((s,r)=>s.detune.value=e+n*r)}}get count(){return this._oscillators.length}set count(t){if(Ce(t,1),this._oscillators.length!==t){this._forEach(e=>e.dispose()),this._oscillators=[];for(let e=0;e<t;e++){const n=new bt({context:this.context,volume:-6-t*1.1,type:this._type,phase:this._phase+e/t*360,partialCount:this._partialCount,onstop:e===0?()=>this.onstop(this):at});this.type==="custom"&&(n.partials=this._partials),this.frequency.connect(n.frequency),this.detune.connect(n.detune),n.detune.overridden=!1,n.connect(this.output),this._oscillators[e]=n}this.spread=this._spread,this.state==="started"&&this._forEach(e=>e.start())}}get phase(){return this._phase}set phase(t){this._phase=t,this._forEach((e,n)=>e.phase=this._phase+n/this.count*360)}get baseType(){return this._oscillators[0].baseType}set baseType(t){this._forEach(e=>e.baseType=t),this._type=this._oscillators[0].type}get partials(){return this._oscillators[0].partials}set partials(t){this._partials=t,this._partialCount=this._partials.length,t.length&&(this._type="custom",this._forEach(e=>e.partials=t))}get partialCount(){return this._oscillators[0].partialCount}set partialCount(t){this._partialCount=t,this._forEach(e=>e.partialCount=t),this._type=this._oscillators[0].type}asArray(t=1024){return Et(this,void 0,void 0,function*(){return Je(this,t)})}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this._forEach(t=>t.dispose()),this}}class Hn extends Wt{constructor(){super(B(Hn.getDefaults(),arguments,["frequency","modulationFrequency"])),this.name="PWMOscillator",this.sourceType="pwm",this._scale=new je({context:this.context,value:2});const t=B(Hn.getDefaults(),arguments,["frequency","modulationFrequency"]);this._pulse=new _n({context:this.context,frequency:t.modulationFrequency}),this._pulse.carrierType="sine",this.modulationFrequency=this._pulse.frequency,this._modulator=new bt({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase}),this.frequency=this._modulator.frequency,this.detune=this._modulator.detune,this._modulator.chain(this._scale,this._pulse.width),this._pulse.connect(this.output),yt(this,["modulationFrequency","frequency","detune"])}static getDefaults(){return Object.assign(Wt.getDefaults(),{detune:0,frequency:440,modulationFrequency:.4,phase:0,type:"pwm"})}_start(t){t=this.toSeconds(t),this._modulator.start(t),this._pulse.start(t)}_stop(t){t=this.toSeconds(t),this._modulator.stop(t),this._pulse.stop(t)}_restart(t){this._modulator.restart(t),this._pulse.restart(t)}get type(){return"pwm"}get baseType(){return"pwm"}get partials(){return[]}get partialCount(){return 0}get phase(){return this._modulator.phase}set phase(t){this._modulator.phase=t}asArray(t=1024){return Et(this,void 0,void 0,function*(){return Je(this,t)})}dispose(){return super.dispose(),this._pulse.dispose(),this._scale.dispose(),this._modulator.dispose(),this}}const vr={am:Wn,fat:Gn,fm:jn,oscillator:bt,pulse:_n,pwm:Hn};class Yn extends Wt{constructor(){super(B(Yn.getDefaults(),arguments,["frequency","type"])),this.name="OmniOscillator";const t=B(Yn.getDefaults(),arguments,["frequency","type"]);this.frequency=new xt({context:this.context,units:"frequency",value:t.frequency}),this.detune=new xt({context:this.context,units:"cents",value:t.detune}),yt(this,["frequency","detune"]),this.set(t)}static getDefaults(){return Object.assign(bt.getDefaults(),jn.getDefaults(),Wn.getDefaults(),Gn.getDefaults(),_n.getDefaults(),Hn.getDefaults())}_start(t){this._oscillator.start(t)}_stop(t){this._oscillator.stop(t)}_restart(t){return this._oscillator.restart(t),this}get type(){let t="";return["am","fm","fat"].some(e=>this._sourceType===e)&&(t=this._sourceType),t+this._oscillator.type}set type(t){t.substr(0,2)==="fm"?(this._createNewOscillator("fm"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(2)):t.substr(0,2)==="am"?(this._createNewOscillator("am"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(2)):t.substr(0,3)==="fat"?(this._createNewOscillator("fat"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(3)):t==="pwm"?(this._createNewOscillator("pwm"),this._oscillator=this._oscillator):t==="pulse"?this._createNewOscillator("pulse"):(this._createNewOscillator("oscillator"),this._oscillator=this._oscillator,this._oscillator.type=t)}get partials(){return this._oscillator.partials}set partials(t){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&(this._oscillator.partials=t)}get partialCount(){return this._oscillator.partialCount}set partialCount(t){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&(this._oscillator.partialCount=t)}set(t){return Reflect.has(t,"type")&&t.type&&(this.type=t.type),super.set(t),this}_createNewOscillator(t){if(t!==this._sourceType){this._sourceType=t;const e=vr[t],n=this.now();if(this._oscillator){const s=this._oscillator;s.stop(n),this.context.setTimeout(()=>s.dispose(),this.blockTime)}this._oscillator=new e({context:this.context}),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.connect(this.output),this._oscillator.onstop=()=>this.onstop(this),this.state==="started"&&this._oscillator.start(n)}}get phase(){return this._oscillator.phase}set phase(t){this._oscillator.phase=t}get sourceType(){return this._sourceType}set sourceType(t){let e="sine";this._oscillator.type!=="pwm"&&this._oscillator.type!=="pulse"&&(e=this._oscillator.type),t==="fm"?this.type="fm"+e:t==="am"?this.type="am"+e:t==="fat"?this.type="fat"+e:t==="oscillator"?this.type=e:t==="pulse"?this.type="pulse":t==="pwm"&&(this.type="pwm")}_getOscType(t,e){return t instanceof vr[e]}get baseType(){return this._oscillator.baseType}set baseType(t){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&t!=="pulse"&&t!=="pwm"&&(this._oscillator.baseType=t)}get width(){if(this._getOscType(this._oscillator,"pulse"))return this._oscillator.width}get count(){if(this._getOscType(this._oscillator,"fat"))return this._oscillator.count}set count(t){this._getOscType(this._oscillator,"fat")&&Ue(t)&&(this._oscillator.count=t)}get spread(){if(this._getOscType(this._oscillator,"fat"))return this._oscillator.spread}set spread(t){this._getOscType(this._oscillator,"fat")&&Ue(t)&&(this._oscillator.spread=t)}get modulationType(){if(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))return this._oscillator.modulationType}set modulationType(t){(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))&&Yt(t)&&(this._oscillator.modulationType=t)}get modulationIndex(){if(this._getOscType(this._oscillator,"fm"))return this._oscillator.modulationIndex}get harmonicity(){if(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))return this._oscillator.harmonicity}get modulationFrequency(){if(this._getOscType(this._oscillator,"pwm"))return this._oscillator.modulationFrequency}asArray(t=1024){return Et(this,void 0,void 0,function*(){return Je(this,t)})}dispose(){return super.dispose(),this.detune.dispose(),this.frequency.dispose(),this._oscillator.dispose(),this}}function ka(i,t=1/0){const e=new WeakMap;return function(n,s){Reflect.defineProperty(n,s,{configurable:!0,enumerable:!0,get:function(){return e.get(this)},set:function(r){Ce(r,i,t),e.set(this,r)}})}}function be(i,t=1/0){const e=new WeakMap;return function(n,s){Reflect.defineProperty(n,s,{configurable:!0,enumerable:!0,get:function(){return e.get(this)},set:function(r){Ce(this.toSeconds(r),i,t),e.set(this,r)}})}}class $n extends Wt{constructor(){super(B($n.getDefaults(),arguments,["url","onload"])),this.name="Player",this._activeSources=new Set;const t=B($n.getDefaults(),arguments,["url","onload"]);this._buffer=new ct({onload:this._onload.bind(this,t.onload),onerror:t.onerror,reverse:t.reverse,url:t.url}),this.autostart=t.autostart,this._loop=t.loop,this._loopStart=t.loopStart,this._loopEnd=t.loopEnd,this._playbackRate=t.playbackRate,this.fadeIn=t.fadeIn,this.fadeOut=t.fadeOut}static getDefaults(){return Object.assign(Wt.getDefaults(),{autostart:!1,fadeIn:0,fadeOut:0,loop:!1,loopEnd:0,loopStart:0,onload:at,onerror:at,playbackRate:1,reverse:!1})}load(t){return Et(this,void 0,void 0,function*(){return yield this._buffer.load(t),this._onload(),this})}_onload(t=at){t(),this.autostart&&this.start()}_onSourceEnd(t){this.onstop(this),this._activeSources.delete(t),this._activeSources.size===0&&!this._synced&&this._state.getValueAtTime(this.now())==="started"&&(this._state.cancel(this.now()),this._state.setStateAtTime("stopped",this.now()))}start(t,e,n){return super.start(t,e,n),this}_start(t,e,n){this._loop?e=un(e,this._loopStart):e=un(e,0);const s=this.toSeconds(e),r=n;n=un(n,Math.max(this._buffer.duration-s,0));let a=this.toSeconds(n);a=a/this._playbackRate,t=this.toSeconds(t);const o=new We({url:this._buffer,context:this.context,fadeIn:this.fadeIn,fadeOut:this.fadeOut,loop:this._loop,loopEnd:this._loopEnd,loopStart:this._loopStart,onended:this._onSourceEnd.bind(this),playbackRate:this._playbackRate}).connect(this.output);!this._loop&&!this._synced&&(this._state.cancel(t+a),this._state.setStateAtTime("stopped",t+a,{implicitEnd:!0})),this._activeSources.add(o),this._loop&&Ht(r)?o.start(t,s):o.start(t,s,a-this.toSeconds(this.fadeOut))}_stop(t){const e=this.toSeconds(t);this._activeSources.forEach(n=>n.stop(e))}restart(t,e,n){return super.restart(t,e,n),this}_restart(t,e,n){this._stop(t),this._start(t,e,n)}seek(t,e){const n=this.toSeconds(e);if(this._state.getValueAtTime(n)==="started"){const s=this.toSeconds(t);this._stop(n),this._start(n,s)}return this}setLoopPoints(t,e){return this.loopStart=t,this.loopEnd=e,this}get loopStart(){return this._loopStart}set loopStart(t){this._loopStart=t,this.buffer.loaded&&Ce(this.toSeconds(t),0,this.buffer.duration),this._activeSources.forEach(e=>{e.loopStart=t})}get loopEnd(){return this._loopEnd}set loopEnd(t){this._loopEnd=t,this.buffer.loaded&&Ce(this.toSeconds(t),0,this.buffer.duration),this._activeSources.forEach(e=>{e.loopEnd=t})}get buffer(){return this._buffer}set buffer(t){this._buffer.set(t)}get loop(){return this._loop}set loop(t){if(this._loop!==t&&(this._loop=t,this._activeSources.forEach(e=>{e.loop=t}),t)){const e=this._state.getNextState("stopped",this.now());e&&this._state.cancel(e.time)}}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t;const e=this.now(),n=this._state.getNextState("stopped",e);n&&n.implicitEnd&&(this._state.cancel(n.time),this._activeSources.forEach(s=>s.cancelStop())),this._activeSources.forEach(s=>{s.playbackRate.setValueAtTime(t,e)})}get reverse(){return this._buffer.reverse}set reverse(t){this._buffer.reverse=t}get loaded(){return this._buffer.loaded}dispose(){return super.dispose(),this._activeSources.forEach(t=>t.dispose()),this._activeSources.clear(),this._buffer.dispose(),this}}re([be(0)],$n.prototype,"fadeIn",void 0);re([be(0)],$n.prototype,"fadeOut",void 0);class ye extends ${constructor(){super(B(ye.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="Envelope",this._sig=new xt({context:this.context,value:0}),this.output=this._sig,this.input=void 0;const t=B(ye.getDefaults(),arguments,["attack","decay","sustain","release"]);this.attack=t.attack,this.decay=t.decay,this.sustain=t.sustain,this.release=t.release,this.attackCurve=t.attackCurve,this.releaseCurve=t.releaseCurve,this.decayCurve=t.decayCurve}static getDefaults(){return Object.assign($.getDefaults(),{attack:.01,attackCurve:"linear",decay:.1,decayCurve:"exponential",release:1,releaseCurve:"exponential",sustain:.5})}get value(){return this.getValueAtTime(this.now())}_getCurve(t,e){if(Yt(t))return t;{let n;for(n in ds)if(ds[n][e]===t)return n;return t}}_setCurve(t,e,n){if(Yt(n)&&Reflect.has(ds,n)){const s=ds[n];Fe(s)?t!=="_decayCurve"&&(this[t]=s[e]):this[t]=s}else if(ee(n)&&t!=="_decayCurve")this[t]=n;else throw new Error("Envelope: invalid curve: "+n)}get attackCurve(){return this._getCurve(this._attackCurve,"In")}set attackCurve(t){this._setCurve("_attackCurve","In",t)}get releaseCurve(){return this._getCurve(this._releaseCurve,"Out")}set releaseCurve(t){this._setCurve("_releaseCurve","Out",t)}get decayCurve(){return this._decayCurve}set decayCurve(t){Z(["linear","exponential"].some(e=>e===t),`Invalid envelope curve: ${t}`),this._decayCurve=t}triggerAttack(t,e=1){this.log("triggerAttack",t,e),t=this.toSeconds(t);let s=this.toSeconds(this.attack);const r=this.toSeconds(this.decay),a=this.getValueAtTime(t);if(a>0){const o=1/s;s=(1-a)/o}if(s<this.sampleTime)this._sig.cancelScheduledValues(t),this._sig.setValueAtTime(e,t);else if(this._attackCurve==="linear")this._sig.linearRampTo(e,s,t);else if(this._attackCurve==="exponential")this._sig.targetRampTo(e,s,t);else{this._sig.cancelAndHoldAtTime(t);let o=this._attackCurve;for(let c=1;c<o.length;c++)if(o[c-1]<=a&&a<=o[c]){o=this._attackCurve.slice(c),o[0]=a;break}this._sig.setValueCurveAtTime(o,t,s,e)}if(r&&this.sustain<1){const o=e*this.sustain,c=t+s;this.log("decay",c),this._decayCurve==="linear"?this._sig.linearRampToValueAtTime(o,r+c):this._sig.exponentialApproachValueAtTime(o,c,r)}return this}triggerRelease(t){this.log("triggerRelease",t),t=this.toSeconds(t);const e=this.getValueAtTime(t);if(e>0){const n=this.toSeconds(this.release);n<this.sampleTime?this._sig.setValueAtTime(0,t):this._releaseCurve==="linear"?this._sig.linearRampTo(0,n,t):this._releaseCurve==="exponential"?this._sig.targetRampTo(0,n,t):(Z(ee(this._releaseCurve),"releaseCurve must be either 'linear', 'exponential' or an array"),this._sig.cancelAndHoldAtTime(t),this._sig.setValueCurveAtTime(this._releaseCurve,t,n,e))}return this}getValueAtTime(t){return this._sig.getValueAtTime(t)}triggerAttackRelease(t,e,n=1){return e=this.toSeconds(e),this.triggerAttack(e,n),this.triggerRelease(e+this.toSeconds(t)),this}cancel(t){return this._sig.cancelScheduledValues(this.toSeconds(t)),this}connect(t,e=0,n=0){return Bi(this,t,e,n),this}asArray(t=1024){return Et(this,void 0,void 0,function*(){const e=t/this.context.sampleRate,n=new Li(1,e,this.context.sampleRate),s=this.toSeconds(this.attack)+this.toSeconds(this.decay),r=s+this.toSeconds(this.release),a=r*.1,o=r+a,c=new this.constructor(Object.assign(this.get(),{attack:e*this.toSeconds(this.attack)/o,decay:e*this.toSeconds(this.decay)/o,release:e*this.toSeconds(this.release)/o,context:n}));return c._sig.toDestination(),c.triggerAttackRelease(e*(s+a)/o,0),(yield n.render()).getChannelData(0)})}dispose(){return super.dispose(),this._sig.dispose(),this}}re([be(0)],ye.prototype,"attack",void 0);re([be(0)],ye.prototype,"decay",void 0);re([ka(0,1)],ye.prototype,"sustain",void 0);re([be(0)],ye.prototype,"release",void 0);const ds=(()=>{let t,e;const n=[];for(t=0;t<128;t++)n[t]=Math.sin(t/(128-1)*(Math.PI/2));const s=[],r=6.4;for(t=0;t<128-1;t++){e=t/(128-1);const d=Math.sin(e*(Math.PI*2)*r-Math.PI/2)+1;s[t]=d/10+e*.83}s[128-1]=1;const a=[],o=5;for(t=0;t<128;t++)a[t]=Math.ceil(t/(128-1)*o)/o;const c=[];for(t=0;t<128;t++)e=t/(128-1),c[t]=.5*(1-Math.cos(Math.PI*e));const l=[];for(t=0;t<128;t++){e=t/(128-1);const d=Math.pow(e,3)*4+.2,f=Math.cos(d*Math.PI*2*e);l[t]=Math.abs(f*(1-e))}function u(d){const f=new Array(d.length);for(let p=0;p<d.length;p++)f[p]=1-d[p];return f}function h(d){return d.slice(0).reverse()}return{bounce:{In:u(l),Out:l},cosine:{In:n,Out:h(n)},exponential:"exponential",linear:"linear",ripple:{In:s,Out:u(s)},sine:{In:c,Out:u(c)},step:{In:a,Out:u(a)}}})();class Ge extends ${constructor(){super(B(Ge.getDefaults(),arguments)),this._scheduledEvents=[],this._synced=!1,this._original_triggerAttack=this.triggerAttack,this._original_triggerRelease=this.triggerRelease;const t=B(Ge.getDefaults(),arguments);this._volume=this.output=new Me({context:this.context,volume:t.volume}),this.volume=this._volume.volume,yt(this,"volume")}static getDefaults(){return Object.assign($.getDefaults(),{volume:0})}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",0)),this}_syncState(){let t=!1;return this._synced||(this._synced=!0,t=!0),t}_syncMethod(t,e){const n=this["_original_"+t]=this[t];this[t]=(...s)=>{const r=s[e],a=this.context.transport.schedule(o=>{s[e]=o,n.apply(this,s)},r);this._scheduledEvents.push(a)}}unsync(){return this._scheduledEvents.forEach(t=>this.context.transport.clear(t)),this._scheduledEvents=[],this._synced&&(this._synced=!1,this.triggerAttack=this._original_triggerAttack,this.triggerRelease=this._original_triggerRelease),this}triggerAttackRelease(t,e,n,s){const r=this.toSeconds(n),a=this.toSeconds(e);return this.triggerAttack(t,r,s),this.triggerRelease(r+a),this}dispose(){return super.dispose(),this._volume.dispose(),this.unsync(),this._scheduledEvents=[],this}}class He extends Ge{constructor(){super(B(He.getDefaults(),arguments));const t=B(He.getDefaults(),arguments);this.portamento=t.portamento,this.onsilence=t.onsilence}static getDefaults(){return Object.assign(Ge.getDefaults(),{detune:0,onsilence:at,portamento:0})}triggerAttack(t,e,n=1){this.log("triggerAttack",t,e,n);const s=this.toSeconds(e);return this._triggerEnvelopeAttack(s,n),this.setNote(t,s),this}triggerRelease(t){this.log("triggerRelease",t);const e=this.toSeconds(t);return this._triggerEnvelopeRelease(e),this}setNote(t,e){const n=this.toSeconds(e),s=t instanceof Ft?t.toFrequency():t;if(this.portamento>0&&this.getLevelAtTime(n)>.05){const r=this.toSeconds(this.portamento);this.frequency.exponentialRampTo(s,r,n)}else this.frequency.setValueAtTime(s,n);return this}}re([be(0)],He.prototype,"portamento",void 0);class qi extends ye{constructor(){super(B(qi.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="AmplitudeEnvelope",this._gainNode=new It({context:this.context,gain:0}),this.output=this._gainNode,this.input=this._gainNode,this._sig.connect(this._gainNode.gain),this.output=this._gainNode,this.input=this._gainNode}dispose(){return super.dispose(),this._gainNode.dispose(),this}}class Xn extends He{constructor(){super(B(Xn.getDefaults(),arguments)),this.name="Synth";const t=B(Xn.getDefaults(),arguments);this.oscillator=new Yn(Object.assign({context:this.context,detune:t.detune,onstop:()=>this.onsilence(this)},t.oscillator)),this.frequency=this.oscillator.frequency,this.detune=this.oscillator.detune,this.envelope=new qi(Object.assign({context:this.context},t.envelope)),this.oscillator.chain(this.envelope,this.output),yt(this,["oscillator","frequency","detune","envelope"])}static getDefaults(){return Object.assign(He.getDefaults(),{envelope:Object.assign(yr(ye.getDefaults(),Object.keys($.getDefaults())),{attack:.005,decay:.1,release:1,sustain:.3}),oscillator:Object.assign(yr(Yn.getDefaults(),[...Object.keys(Wt.getDefaults()),"frequency","detune"]),{type:"triangle"})})}_triggerEnvelopeAttack(t,e){if(this.envelope.triggerAttack(t,e),this.oscillator.start(t),this.envelope.sustain===0){const n=this.toSeconds(this.envelope.attack),s=this.toSeconds(this.envelope.decay);this.oscillator.stop(t+n+s)}}_triggerEnvelopeRelease(t){this.envelope.triggerRelease(t),this.oscillator.stop(t+this.toSeconds(this.envelope.release))}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this.oscillator.dispose(),this.envelope.dispose(),this}}class Zn extends Xn{constructor(){super(B(Zn.getDefaults(),arguments)),this.name="MembraneSynth",this.portamento=0;const t=B(Zn.getDefaults(),arguments);this.pitchDecay=t.pitchDecay,this.octaves=t.octaves,yt(this,["oscillator","envelope"])}static getDefaults(){return ln(He.getDefaults(),Xn.getDefaults(),{envelope:{attack:.001,attackCurve:"exponential",decay:.4,release:1.4,sustain:.01},octaves:10,oscillator:{type:"sine"},pitchDecay:.05})}setNote(t,e){const n=this.toSeconds(e),s=this.toFrequency(t instanceof Ft?t.toFrequency():t),r=s*this.octaves;return this.oscillator.frequency.setValueAtTime(r,n),this.oscillator.frequency.exponentialRampToValueAtTime(s,n+this.toSeconds(this.pitchDecay)),this}dispose(){return super.dispose(),this}}re([ka(0)],Zn.prototype,"octaves",void 0);re([be(0)],Zn.prototype,"pitchDecay",void 0);const Da=new Set;function Wi(i){Da.add(i)}function Ra(i,t){const e=`registerProcessor("${i}", ${t})`;Da.add(e)}const Jd=`
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;Wi(Jd);const Qd=`
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;Wi(Qd);const tf=`
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;Wi(tf);const ef="feedback-comb-filter",nf=`
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;Ra(ef,nf);class Ye extends Ge{constructor(){super(B(Ye.getDefaults(),arguments,["urls","onload","baseUrl"],"urls")),this.name="Sampler",this._activeSources=new Map;const t=B(Ye.getDefaults(),arguments,["urls","onload","baseUrl"],"urls"),e={};Object.keys(t.urls).forEach(n=>{const s=parseInt(n,10);if(Z(hs(n)||Ue(s)&&isFinite(s),`url key is neither a note or midi pitch: ${n}`),hs(n)){const r=new Ft(this.context,n).toMidi();e[r]=t.urls[n]}else Ue(s)&&isFinite(s)&&(e[s]=t.urls[s])}),this._buffers=new os({urls:e,onload:t.onload,baseUrl:t.baseUrl,onerror:t.onerror}),this.attack=t.attack,this.release=t.release,this.curve=t.curve,this._buffers.loaded&&Promise.resolve().then(t.onload)}static getDefaults(){return Object.assign(Ge.getDefaults(),{attack:0,baseUrl:"",curve:"exponential",onload:at,onerror:at,release:.1,urls:{}})}_findClosest(t){let n=0;for(;n<96;){if(this._buffers.has(t+n))return-n;if(this._buffers.has(t-n))return n;n++}throw new Error(`No available buffers for note: ${t}`)}triggerAttack(t,e,n=1){return this.log("triggerAttack",t,e,n),Array.isArray(t)||(t=[t]),t.forEach(s=>{const r=Ia(new Ft(this.context,s).toFrequency()),a=Math.round(r),o=r-a,c=this._findClosest(a),l=a-c,u=this._buffers.get(l),h=Ma(c+o),d=new We({url:u,context:this.context,curve:this.curve,fadeIn:this.attack,fadeOut:this.release,playbackRate:h}).connect(this.output);d.start(e,0,u.duration/h,n),ee(this._activeSources.get(a))||this._activeSources.set(a,[]),this._activeSources.get(a).push(d),d.onended=()=>{if(this._activeSources&&this._activeSources.has(a)){const f=this._activeSources.get(a),p=f.indexOf(d);p!==-1&&f.splice(p,1)}}}),this}triggerRelease(t,e){return this.log("triggerRelease",t,e),Array.isArray(t)||(t=[t]),t.forEach(n=>{const s=new Ft(this.context,n).toMidi();if(this._activeSources.has(s)&&this._activeSources.get(s).length){const r=this._activeSources.get(s);e=this.toSeconds(e),r.forEach(a=>{a.stop(e)}),this._activeSources.set(s,[])}}),this}releaseAll(t){const e=this.toSeconds(t);return this._activeSources.forEach(n=>{for(;n.length;)n.shift().stop(e)}),this}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",1)),this}triggerAttackRelease(t,e,n,s=1){const r=this.toSeconds(n);return this.triggerAttack(t,r,s),ee(e)?(Z(ee(t),"notes must be an array when duration is array"),t.forEach((a,o)=>{const c=e[Math.min(o,e.length-1)];this.triggerRelease(a,r+this.toSeconds(c))})):this.triggerRelease(t,r+this.toSeconds(e)),this}add(t,e,n){if(Z(hs(t)||isFinite(t),`note must be a pitch or midi: ${t}`),hs(t)){const s=new Ft(this.context,t).toMidi();this._buffers.add(s,e,n)}else this._buffers.add(t,e,n);return this}get loaded(){return this._buffers.loaded}dispose(){return super.dispose(),this._buffers.dispose(),this._activeSources.forEach(t=>{t.forEach(e=>e.dispose())}),this._activeSources.clear(),this}}re([be(0)],Ye.prototype,"attack",void 0);re([be(0)],Ye.prototype,"release",void 0);class Rs extends ${constructor(){super(Object.assign(B(Rs.getDefaults(),arguments,["pan"]))),this.name="Panner",this._panner=this.context.createStereoPanner(),this.input=this._panner,this.output=this._panner;const t=B(Rs.getDefaults(),arguments,["pan"]);this.pan=new dt({context:this.context,param:this._panner.pan,value:t.pan,minValue:-1,maxValue:1}),this._panner.channelCount=t.channelCount,this._panner.channelCountMode="explicit",yt(this,"pan")}static getDefaults(){return Object.assign($.getDefaults(),{pan:0,channelCount:1})}dispose(){return super.dispose(),this._panner.disconnect(),this.pan.dispose(),this}}const sf="bit-crusher",rf=`
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;Ra(sf,rf);class wt extends ${constructor(){super(B(wt.getDefaults(),arguments,["solo"])),this.name="Solo";const t=B(wt.getDefaults(),arguments,["solo"]);this.input=this.output=new It({context:this.context}),wt._allSolos.has(this.context)||wt._allSolos.set(this.context,new Set),wt._allSolos.get(this.context).add(this),this.solo=t.solo}static getDefaults(){return Object.assign($.getDefaults(),{solo:!1})}get solo(){return this._isSoloed()}set solo(t){t?this._addSolo():this._removeSolo(),wt._allSolos.get(this.context).forEach(e=>e._updateSolo())}get muted(){return this.input.gain.value===0}_addSolo(){wt._soloed.has(this.context)||wt._soloed.set(this.context,new Set),wt._soloed.get(this.context).add(this)}_removeSolo(){wt._soloed.has(this.context)&&wt._soloed.get(this.context).delete(this)}_isSoloed(){return wt._soloed.has(this.context)&&wt._soloed.get(this.context).has(this)}_noSolos(){return!wt._soloed.has(this.context)||wt._soloed.has(this.context)&&wt._soloed.get(this.context).size===0}_updateSolo(){this._isSoloed()?this.input.gain.value=1:this._noSolos()?this.input.gain.value=1:this.input.gain.value=0}dispose(){return super.dispose(),wt._allSolos.get(this.context).delete(this),this._removeSolo(),this}}wt._allSolos=new Map;wt._soloed=new Map;class Ps extends ${constructor(){super(B(Ps.getDefaults(),arguments,["pan","volume"])),this.name="PanVol";const t=B(Ps.getDefaults(),arguments,["pan","volume"]);this._panner=this.input=new Rs({context:this.context,pan:t.pan,channelCount:t.channelCount}),this.pan=this._panner.pan,this._volume=this.output=new Me({context:this.context,volume:t.volume}),this.volume=this._volume.volume,this._panner.connect(this._volume),this.mute=t.mute,yt(this,["pan","volume"])}static getDefaults(){return Object.assign($.getDefaults(),{mute:!1,pan:0,volume:0,channelCount:1})}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}dispose(){return super.dispose(),this._panner.dispose(),this.pan.dispose(),this._volume.dispose(),this.volume.dispose(),this}}class De extends ${constructor(){super(B(De.getDefaults(),arguments,["volume","pan"])),this.name="Channel";const t=B(De.getDefaults(),arguments,["volume","pan"]);this._solo=this.input=new wt({solo:t.solo,context:this.context}),this._panVol=this.output=new Ps({context:this.context,pan:t.pan,volume:t.volume,mute:t.mute,channelCount:t.channelCount}),this.pan=this._panVol.pan,this.volume=this._panVol.volume,this._solo.connect(this._panVol),yt(this,["pan","volume"])}static getDefaults(){return Object.assign($.getDefaults(),{pan:0,volume:0,mute:!1,solo:!1,channelCount:1})}get solo(){return this._solo.solo}set solo(t){this._solo.solo=t}get muted(){return this._solo.muted||this.mute}get mute(){return this._panVol.mute}set mute(t){this._panVol.mute=t}_getBus(t){return De.buses.has(t)||De.buses.set(t,new It({context:this.context})),De.buses.get(t)}send(t,e=0){const n=this._getBus(t),s=new It({context:this.context,units:"decibels",gain:e});return this.connect(s),s.connect(n),s}receive(t){return this._getBus(t).connect(this),this}dispose(){return super.dispose(),this._panVol.dispose(),this.pan.dispose(),this.volume.dispose(),this._solo.dispose(),this}}De.buses=new Map;class af extends ${constructor(){super(...arguments),this.name="Listener",this.positionX=new dt({context:this.context,param:this.context.rawContext.listener.positionX}),this.positionY=new dt({context:this.context,param:this.context.rawContext.listener.positionY}),this.positionZ=new dt({context:this.context,param:this.context.rawContext.listener.positionZ}),this.forwardX=new dt({context:this.context,param:this.context.rawContext.listener.forwardX}),this.forwardY=new dt({context:this.context,param:this.context.rawContext.listener.forwardY}),this.forwardZ=new dt({context:this.context,param:this.context.rawContext.listener.forwardZ}),this.upX=new dt({context:this.context,param:this.context.rawContext.listener.upX}),this.upY=new dt({context:this.context,param:this.context.rawContext.listener.upY}),this.upZ=new dt({context:this.context,param:this.context.rawContext.listener.upZ})}static getDefaults(){return Object.assign($.getDefaults(),{positionX:0,positionY:0,positionZ:0,forwardX:0,forwardY:0,forwardZ:-1,upX:0,upY:1,upZ:0})}dispose(){return super.dispose(),this.positionX.dispose(),this.positionY.dispose(),this.positionZ.dispose(),this.forwardX.dispose(),this.forwardY.dispose(),this.forwardZ.dispose(),this.upX.dispose(),this.upY.dispose(),this.upZ.dispose(),this}}Gs(i=>{i.listener=new af({context:i})});Hs(i=>{i.listener.dispose()});qt().transport;qt().destination;qt().destination;qt().listener;qt().draw;qt();var of=globalThis&&globalThis.__awaiter||function(i,t,e,n){function s(r){return r instanceof e?r:new e(function(a){a(r)})}return new(e||(e=Promise))(function(r,a){function o(u){try{l(n.next(u))}catch(h){a(h)}}function c(u){try{l(n.throw(u))}catch(h){a(h)}}function l(u){u.done?r(u.value):s(u.value).then(o,c)}l((n=n.apply(i,t||[])).next())})};class Xs extends ${constructor(t){super(t),this.name="PianoComponent",this.input=void 0,this.output=new Me({context:this.context}),this._enabled=!1,this.volume=this.output.volume,this._loaded=!1,this.volume.value=t.volume,this._enabled=t.enabled,this.samples=t.samples}get loaded(){return this._loaded}load(){return of(this,void 0,void 0,function*(){if(this._enabled)yield this._internalLoad(),this._loaded=!0;else return Promise.resolve()})}}function Pa(i){return Gd(i,"midi").toNote()}function Ls(i,t){return Math.random()*(t-i)+i}function cf(i){return`rel${i-20}.[mp3|ogg]`}function lf(i){return`harmS${Pa(i).replace("#","s")}.[mp3|ogg]`}function uf(i,t){return`${Pa(i).replace("#","s")}v${t}.[mp3|ogg]`}const hf={1:[8],2:[6,12],3:[1,7,15],4:[1,5,10,15],5:[1,4,8,12,16],6:[1,3,7,10,13,16],7:[1,3,6,9,11,13,16],8:[1,3,5,7,9,11,13,16],9:[1,3,5,7,9,11,13,15,16],10:[1,2,3,5,7,9,11,13,15,16],11:[1,2,3,5,7,9,11,13,14,15,16],12:[1,2,3,4,5,7,9,11,13,14,15,16],13:[1,2,3,4,5,7,9,11,12,13,14,15,16],14:[1,2,3,4,5,6,7,9,11,12,13,14,15,16],15:[1,2,3,4,5,6,7,9,10,11,12,13,14,15,16],16:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]},df=[21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,105,108];function ff(i,t){return df.filter(e=>i<=e&&e<=t)}const gs=[21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87];function pf(i,t){return gs.filter(e=>i<=e&&e<=t)}function mf(i){return gs[0]<=i&&i<=gs[gs.length-1]}class gf extends Xs{constructor(t){super(t),this._urls={};const e=pf(t.minNote,t.maxNote);for(const n of e)this._urls[n]=lf(n)}triggerAttack(t,e,n){this._enabled&&mf(t)&&this._sampler.triggerAttack(zn(t).toNote(),e,n*Ls(.5,1))}_internalLoad(){return new Promise(t=>{this._sampler=new Ye({baseUrl:this.samples,onload:t,urls:this._urls}).connect(this.output)})}}class _f extends Xs{constructor(t){super(t),this._urls={};for(let e=t.minNote;e<=t.maxNote;e++)this._urls[e]=cf(e)}_internalLoad(){return new Promise(t=>{this._buffers=new os(this._urls,t,this.samples)})}start(t,e,n){this._enabled&&this._buffers.has(t)&&new We({url:this._buffers.get(t),context:this.context}).connect(this.output).start(e,0,void 0,.015*n*Ls(.5,1))}}class yf extends Xs{constructor(t){super(t),this._downTime=1/0,this._currentSound=null,this._downTime=1/0}_internalLoad(){return new Promise(t=>{this._buffers=new os({down1:"pedalD1.mp3",down2:"pedalD2.mp3",up1:"pedalU1.mp3",up2:"pedalU2.mp3"},t,this.samples)})}_squash(t){this._currentSound&&this._currentSound.state!=="stopped"&&this._currentSound.stop(t),this._currentSound=null}_playSample(t,e){this._enabled&&(this._currentSound=new We({url:this._buffers.get(`${e}${Math.random()>.5?1:2}`),context:this.context,curve:"exponential",fadeIn:.05,fadeOut:.1}).connect(this.output),this._currentSound.start(t,Ls(0,.01),void 0,.1*Ls(.5,1)))}down(t){this._squash(t),this._downTime=t,this._playSample(t,"down")}up(t){this._squash(t),this._downTime=1/0,this._playSample(t,"up")}isDown(t){return t>this._downTime}}class vf extends ${constructor(t){super(t),this.name="PianoString",this._urls={},t.notes.forEach(e=>this._urls[e]=uf(e,t.velocity)),this.samples=t.samples}load(){return new Promise(t=>{this._sampler=this.output=new Ye({attack:0,baseUrl:this.samples,curve:"exponential",onload:t,release:.4,urls:this._urls,volume:3})})}triggerAttack(t,e,n){this._sampler.triggerAttack(t,e,n)}triggerRelease(t,e){this._sampler.triggerRelease(t,e)}}var wr=globalThis&&globalThis.__awaiter||function(i,t,e,n){function s(r){return r instanceof e?r:new e(function(a){a(r)})}return new(e||(e=Promise))(function(r,a){function o(u){try{l(n.next(u))}catch(h){a(h)}}function c(u){try{l(n.throw(u))}catch(h){a(h)}}function l(u){u.done?r(u.value):s(u.value).then(o,c)}l((n=n.apply(i,t||[])).next())})};class wf extends Xs{constructor(t){super(t);const e=ff(t.minNote,t.maxNote),n=hf[t.velocities].slice();this._strings=n.map(s=>new vf(Object.assign(t,{notes:e,velocity:s}))),this._activeNotes=new Map}scale(t,e,n,s,r){return(t-e)/(n-e)*(r-s)+s}triggerAttack(t,e,n){const s=this.scale(n,0,1,-.5,this._strings.length-.51),r=Math.max(Math.round(s),0);let a=1+s-r;this._strings.length===1&&(a=n);const o=this._strings[r];this._activeNotes.has(t)&&this.triggerRelease(t,e),this._activeNotes.set(t,o),o.triggerAttack(zn(t).toNote(),e,a)}triggerRelease(t,e){this._activeNotes.has(t)&&(this._activeNotes.get(t).triggerRelease(zn(t).toNote(),e),this._activeNotes.delete(t))}_internalLoad(){return wr(this,void 0,void 0,function*(){yield Promise.all(this._strings.map(t=>wr(this,void 0,void 0,function*(){yield t.load(),t.connect(this.output)})))})}}var bf=globalThis&&globalThis.__awaiter||function(i,t,e,n){function s(r){return r instanceof e?r:new e(function(a){a(r)})}return new(e||(e=Promise))(function(r,a){function o(u){try{l(n.next(u))}catch(h){a(h)}}function c(u){try{l(n.throw(u))}catch(h){a(h)}}function l(u){u.done?r(u.value):s(u.value).then(o,c)}l((n=n.apply(i,t||[])).next())})};class Fs extends ${constructor(){super(B(Fs.getDefaults(),arguments)),this.name="Piano",this.input=void 0,this.output=new It({context:this.context}),this._heldNotes=new Map,this._loaded=!1;const t=B(Fs.getDefaults(),arguments);t.url.endsWith("/")||(t.url+="/"),this.maxPolyphony=t.maxPolyphony,this._heldNotes=new Map,this._sustainedNotes=new Map,this._strings=new wf(Object.assign({},t,{enabled:!0,samples:t.url,volume:t.volume.strings})).connect(this.output),this.strings=this._strings.volume,this._pedal=new yf(Object.assign({},t,{enabled:t.pedal,samples:t.url,volume:t.volume.pedal})).connect(this.output),this.pedal=this._pedal.volume,this._keybed=new _f(Object.assign({},t,{enabled:t.release,samples:t.url,volume:t.volume.keybed})).connect(this.output),this.keybed=this._keybed.volume,this._harmonics=new gf(Object.assign({},t,{enabled:t.release,samples:t.url,volume:t.volume.harmonics})).connect(this.output),this.harmonics=this._harmonics.volume}static getDefaults(){return Object.assign($.getDefaults(),{maxNote:108,minNote:21,pedal:!0,release:!1,url:"https://tambien.github.io/Piano/audio/",velocities:1,maxPolyphony:32,volume:{harmonics:0,keybed:0,pedal:0,strings:0}})}load(){return bf(this,void 0,void 0,function*(){yield Promise.all([this._strings.load(),this._pedal.load(),this._keybed.load(),this._harmonics.load()]),this._loaded=!0})}get loaded(){return this._loaded}pedalDown({time:t=this.immediate()}={}){return this.loaded&&(t=this.toSeconds(t),this._pedal.isDown(t)||this._pedal.down(t)),this}pedalUp({time:t=this.immediate()}={}){if(this.loaded){const e=this.toSeconds(t);this._pedal.isDown(e)&&(this._pedal.up(e),this._sustainedNotes.forEach((n,s)=>{this._heldNotes.has(s)||this._strings.triggerRelease(s,e)}),this._sustainedNotes.clear())}return this}keyDown({note:t,midi:e,time:n=this.immediate(),velocity:s=.8}){return this.loaded&&this.maxPolyphony>this._heldNotes.size+this._sustainedNotes.size?(n=this.toSeconds(n),Yt(t)&&(e=Math.round(zn(t).toMidi())),this._heldNotes.has(e)||(this._heldNotes.set(e,{time:n,velocity:s}),this._strings.triggerAttack(e,n,s))):console.warn("samples not loaded"),this}keyUp({note:t,midi:e,time:n=this.immediate(),velocity:s=.8}){if(this.loaded&&(n=this.toSeconds(n),Yt(t)&&(e=Math.round(zn(t).toMidi())),this._heldNotes.has(e))){const r=this._heldNotes.get(e);this._heldNotes.delete(e);const a=Math.pow(Math.max(n-r.time,.1),.7),o=r.velocity;let c=3/a*o*s;c=Math.max(c,.4),c=Math.min(c,4),this._pedal.isDown(n)?this._sustainedNotes.has(e)||this._sustainedNotes.set(e,n):(this._strings.triggerRelease(e,n),this._harmonics.triggerAttack(e,n,c)),this._keybed.start(e,n,s)}return this}stopAll(){return this.pedalUp(),this._heldNotes.forEach((t,e)=>{this.keyUp({midi:e})}),this}}var ji={exports:{}},dn=typeof Reflect=="object"?Reflect:null,br=dn&&typeof dn.apply=="function"?dn.apply:function(t,e,n){return Function.prototype.apply.call(t,e,n)},_s;dn&&typeof dn.ownKeys=="function"?_s=dn.ownKeys:Object.getOwnPropertySymbols?_s=function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:_s=function(t){return Object.getOwnPropertyNames(t)};function Tf(i){console&&console.warn&&console.warn(i)}var La=Number.isNaN||function(t){return t!==t};function rt(){rt.init.call(this)}ji.exports=rt;ji.exports.once=xf;rt.EventEmitter=rt;rt.prototype._events=void 0;rt.prototype._eventsCount=0;rt.prototype._maxListeners=void 0;var Tr=10;function Zs(i){if(typeof i!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof i)}Object.defineProperty(rt,"defaultMaxListeners",{enumerable:!0,get:function(){return Tr},set:function(i){if(typeof i!="number"||i<0||La(i))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+i+".");Tr=i}});rt.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};rt.prototype.setMaxListeners=function(t){if(typeof t!="number"||t<0||La(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this};function Fa(i){return i._maxListeners===void 0?rt.defaultMaxListeners:i._maxListeners}rt.prototype.getMaxListeners=function(){return Fa(this)};rt.prototype.emit=function(t){for(var e=[],n=1;n<arguments.length;n++)e.push(arguments[n]);var s=t==="error",r=this._events;if(r!==void 0)s=s&&r.error===void 0;else if(!s)return!1;if(s){var a;if(e.length>0&&(a=e[0]),a instanceof Error)throw a;var o=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw o.context=a,o}var c=r[t];if(c===void 0)return!1;if(typeof c=="function")br(c,this,e);else for(var l=c.length,u=qa(c,l),n=0;n<l;++n)br(u[n],this,e);return!0};function Va(i,t,e,n){var s,r,a;if(Zs(e),r=i._events,r===void 0?(r=i._events=Object.create(null),i._eventsCount=0):(r.newListener!==void 0&&(i.emit("newListener",t,e.listener?e.listener:e),r=i._events),a=r[t]),a===void 0)a=r[t]=e,++i._eventsCount;else if(typeof a=="function"?a=r[t]=n?[e,a]:[a,e]:n?a.unshift(e):a.push(e),s=Fa(i),s>0&&a.length>s&&!a.warned){a.warned=!0;var o=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");o.name="MaxListenersExceededWarning",o.emitter=i,o.type=t,o.count=a.length,Tf(o)}return i}rt.prototype.addListener=function(t,e){return Va(this,t,e,!1)};rt.prototype.on=rt.prototype.addListener;rt.prototype.prependListener=function(t,e){return Va(this,t,e,!0)};function Ef(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function Ba(i,t,e){var n={fired:!1,wrapFn:void 0,target:i,type:t,listener:e},s=Ef.bind(n);return s.listener=e,n.wrapFn=s,s}rt.prototype.once=function(t,e){return Zs(e),this.on(t,Ba(this,t,e)),this};rt.prototype.prependOnceListener=function(t,e){return Zs(e),this.prependListener(t,Ba(this,t,e)),this};rt.prototype.removeListener=function(t,e){var n,s,r,a,o;if(Zs(e),s=this._events,s===void 0)return this;if(n=s[t],n===void 0)return this;if(n===e||n.listener===e)--this._eventsCount===0?this._events=Object.create(null):(delete s[t],s.removeListener&&this.emit("removeListener",t,n.listener||e));else if(typeof n!="function"){for(r=-1,a=n.length-1;a>=0;a--)if(n[a]===e||n[a].listener===e){o=n[a].listener,r=a;break}if(r<0)return this;r===0?n.shift():Sf(n,r),n.length===1&&(s[t]=n[0]),s.removeListener!==void 0&&this.emit("removeListener",t,o||e)}return this};rt.prototype.off=rt.prototype.removeListener;rt.prototype.removeAllListeners=function(t){var e,n,s;if(n=this._events,n===void 0)return this;if(n.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):n[t]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete n[t]),this;if(arguments.length===0){var r=Object.keys(n),a;for(s=0;s<r.length;++s)a=r[s],a!=="removeListener"&&this.removeAllListeners(a);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(e=n[t],typeof e=="function")this.removeListener(t,e);else if(e!==void 0)for(s=e.length-1;s>=0;s--)this.removeListener(t,e[s]);return this};function za(i,t,e){var n=i._events;if(n===void 0)return[];var s=n[t];return s===void 0?[]:typeof s=="function"?e?[s.listener||s]:[s]:e?Nf(s):qa(s,s.length)}rt.prototype.listeners=function(t){return za(this,t,!0)};rt.prototype.rawListeners=function(t){return za(this,t,!1)};rt.listenerCount=function(i,t){return typeof i.listenerCount=="function"?i.listenerCount(t):Ua.call(i,t)};rt.prototype.listenerCount=Ua;function Ua(i){var t=this._events;if(t!==void 0){var e=t[i];if(typeof e=="function")return 1;if(e!==void 0)return e.length}return 0}rt.prototype.eventNames=function(){return this._eventsCount>0?_s(this._events):[]};function qa(i,t){for(var e=new Array(t),n=0;n<t;++n)e[n]=i[n];return e}function Sf(i,t){for(;t+1<i.length;t++)i[t]=i[t+1];i.pop()}function Nf(i){for(var t=new Array(i.length),e=0;e<t.length;++e)t[e]=i[e].listener||i[e];return t}function xf(i,t){return new Promise(function(e,n){function s(a){i.removeListener(t,r),n(a)}function r(){typeof i.removeListener=="function"&&i.removeListener("error",s),e([].slice.call(arguments))}Wa(i,t,r,{once:!0}),t!=="error"&&Af(i,s,{once:!0})})}function Af(i,t,e){typeof i.on=="function"&&Wa(i,"error",t,e)}function Wa(i,t,e,n){if(typeof i.on=="function")n.once?i.once(t,e):i.on(t,e);else if(typeof i.addEventListener=="function")i.addEventListener(t,function s(r){n.once&&i.removeEventListener(t,s),e(r)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof i)}class te{constructor(t=!1){this.eventMap={},this.eventsSuspended=t==1}addListener(t,e,n={}){if(typeof t=="string"&&t.length<1||t instanceof String&&t.length<1||typeof t!="string"&&!(t instanceof String)&&t!==te.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if(typeof e!="function")throw new TypeError("The callback must be a function.");const s=new Er(t,this,e,n);return this.eventMap[t]||(this.eventMap[t]=[]),n.prepend?this.eventMap[t].unshift(s):this.eventMap[t].push(s),s}addOneTimeListener(t,e,n={}){n.remaining=1,this.addListener(t,e,n)}static get ANY_EVENT(){return Symbol.for("Any event")}hasListener(t,e){return t===void 0?!!(this.eventMap[te.ANY_EVENT]&&this.eventMap[te.ANY_EVENT].length>0)||Object.entries(this.eventMap).some(([,n])=>n.length>0):this.eventMap[t]&&this.eventMap[t].length>0?e instanceof Er?this.eventMap[t].filter(n=>n===e).length>0:typeof e=="function"?this.eventMap[t].filter(n=>n.callback===e).length>0:e==null:!1}get eventNames(){return Object.keys(this.eventMap)}getListeners(t){return this.eventMap[t]||[]}suspendEvent(t){this.getListeners(t).forEach(e=>{e.suspended=!0})}unsuspendEvent(t){this.getListeners(t).forEach(e=>{e.suspended=!1})}getListenerCount(t){return this.getListeners(t).length}emit(t,...e){if(typeof t!="string"&&!(t instanceof String))throw new TypeError("The 'event' parameter must be a string.");if(this.eventsSuspended)return;let n=[],s=this.eventMap[te.ANY_EVENT]||[];return this.eventMap[t]&&(s=s.concat(this.eventMap[t])),s.forEach(r=>{if(r.suspended)return;let a=[...e];Array.isArray(r.arguments)&&(a=a.concat(r.arguments)),r.remaining>0&&(n.push(r.callback.apply(r.context,a)),r.count++),--r.remaining<1&&r.remove()}),n}removeListener(t,e,n={}){if(t===void 0)return void(this.eventMap={});if(!this.eventMap[t])return;let s=this.eventMap[t].filter(r=>e&&r.callback!==e||n.remaining&&n.remaining!==r.remaining||n.context&&n.context!==r.context);s.length?this.eventMap[t]=s:delete this.eventMap[t]}async waitFor(t,e={}){return e.duration=parseInt(e.duration),(isNaN(e.duration)||e.duration<=0)&&(e.duration=1/0),new Promise((n,s)=>{let r,a=this.addListener(t,()=>{clearTimeout(r),n()},{remaining:1});e.duration!==1/0&&(r=setTimeout(()=>{a.remove(),s("The duration expired before the event was emitted.")},e.duration))})}get eventCount(){return Object.keys(this.eventMap).length}}class Er{constructor(t,e,n,s={}){if(typeof t!="string"&&!(t instanceof String)&&t!==te.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if(!e)throw new ReferenceError("The 'target' parameter is mandatory.");if(typeof n!="function")throw new TypeError("The 'callback' must be a function.");s.arguments===void 0||Array.isArray(s.arguments)||(s.arguments=[s.arguments]),(s=Object.assign({context:e,remaining:1/0,arguments:void 0,duration:1/0},s)).duration!==1/0&&setTimeout(()=>this.remove(),s.duration),this.arguments=s.arguments,this.callback=n,this.context=s.context,this.count=0,this.event=t,this.remaining=parseInt(s.remaining)>=1?parseInt(s.remaining):1/0,this.suspended=!1,this.target=e}remove(){this.target.removeListener(this.event,this.callback,{context:this.context,remaining:this.remaining})}}/**
 * The `Enumerations` class contains enumerations and arrays of elements used throughout the
 * library. All properties are static and should be referenced using the class name. For example:
 * `Enumerations.MIDI_CHANNEL_MESSAGES`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */class I{static get MIDI_CHANNEL_MESSAGES(){return{noteoff:8,noteon:9,keyaftertouch:10,controlchange:11,programchange:12,channelaftertouch:13,pitchbend:14}}static get MIDI_CHANNEL_NUMBERS(){return[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]}static get MIDI_CHANNEL_MODE_MESSAGES(){return{allsoundoff:120,resetallcontrollers:121,localcontrol:122,allnotesoff:123,omnimodeoff:124,omnimodeon:125,monomodeon:126,polymodeon:127}}static get MIDI_CONTROL_CHANGE_MESSAGES(){return{bankselectcoarse:0,modulationwheelcoarse:1,breathcontrollercoarse:2,controller3:3,footcontrollercoarse:4,portamentotimecoarse:5,dataentrycoarse:6,volumecoarse:7,balancecoarse:8,controller9:9,pancoarse:10,expressioncoarse:11,effectcontrol1coarse:12,effectcontrol2coarse:13,controller14:14,controller15:15,generalpurposeslider1:16,generalpurposeslider2:17,generalpurposeslider3:18,generalpurposeslider4:19,controller20:20,controller21:21,controller22:22,controller23:23,controller24:24,controller25:25,controller26:26,controller27:27,controller28:28,controller29:29,controller30:30,controller31:31,bankselectfine:32,modulationwheelfine:33,breathcontrollerfine:34,controller35:35,footcontrollerfine:36,portamentotimefine:37,dataentryfine:38,volumefine:39,balancefine:40,controller41:41,panfine:42,expressionfine:43,effectcontrol1fine:44,effectcontrol2fine:45,controller46:46,controller47:47,controller48:48,controller49:49,controller50:50,controller51:51,controller52:52,controller53:53,controller54:54,controller55:55,controller56:56,controller57:57,controller58:58,controller59:59,controller60:60,controller61:61,controller62:62,controller63:63,holdpedal:64,portamento:65,sustenutopedal:66,softpedal:67,legatopedal:68,hold2pedal:69,soundvariation:70,resonance:71,soundreleasetime:72,soundattacktime:73,brightness:74,soundcontrol6:75,soundcontrol7:76,soundcontrol8:77,soundcontrol9:78,soundcontrol10:79,generalpurposebutton1:80,generalpurposebutton2:81,generalpurposebutton3:82,generalpurposebutton4:83,controller84:84,controller85:85,controller86:86,controller87:87,controller88:88,controller89:89,controller90:90,reverblevel:91,tremololevel:92,choruslevel:93,celestelevel:94,phaserlevel:95,databuttonincrement:96,databuttondecrement:97,nonregisteredparametercoarse:98,nonregisteredparameterfine:99,registeredparametercoarse:100,registeredparameterfine:101,controller102:102,controller103:103,controller104:104,controller105:105,controller106:106,controller107:107,controller108:108,controller109:109,controller110:110,controller111:111,controller112:112,controller113:113,controller114:114,controller115:115,controller116:116,controller117:117,controller118:118,controller119:119,allsoundoff:120,resetallcontrollers:121,localcontrol:122,allnotesoff:123,omnimodeoff:124,omnimodeon:125,monomodeon:126,polymodeon:127}}static get MIDI_REGISTERED_PARAMETERS(){return{pitchbendrange:[0,0],channelfinetuning:[0,1],channelcoarsetuning:[0,2],tuningprogram:[0,3],tuningbank:[0,4],modulationrange:[0,5],azimuthangle:[61,0],elevationangle:[61,1],gain:[61,2],distanceratio:[61,3],maximumdistance:[61,4],maximumdistancegain:[61,5],referencedistanceratio:[61,6],panspreadangle:[61,7],rollangle:[61,8]}}static get MIDI_SYSTEM_MESSAGES(){return{sysex:240,timecode:241,songposition:242,songselect:243,tunerequest:246,tuningrequest:246,sysexend:247,clock:248,start:250,continue:251,stop:252,activesensing:254,reset:255,midimessage:0,unknownsystemmessage:-1}}static get CHANNEL_EVENTS(){return["noteoff","controlchange","noteon","keyaftertouch","programchange","channelaftertouch","pitchbend","allnotesoff","allsoundoff","localcontrol","monomode","omnimode","resetallcontrollers","nrpn","nrpn-dataentrycoarse","nrpn-dataentryfine","nrpn-databuttonincrement","nrpn-databuttondecrement","rpn","rpn-dataentrycoarse","rpn-dataentryfine","rpn-databuttonincrement","rpn-databuttondecrement"]}}/**
 * The `Note` class represents a single musical note such as `"D3"`, `"G#4"`, `"F-1"`, `"Gb7"`, etc.
 *
 * `Note` objects can be played back on a single channel by calling
 * [`OutputChannel.playNote()`]{@link OutputChannel#playNote} or, on multiple channels of the same
 * output, by calling [`Output.playNote()`]{@link Output#playNote}.
 *
 * The note has [`attack`](#attack) and [`release`](#release) velocities set at `0.5` by default.
 * These can be changed by passing in the appropriate option. It is also possible to set a
 * system-wide default for attack and release velocities by using the
 * [`WebMidi.defaults`](WebMidi#defaults) property.
 *
 * If you prefer to work with raw MIDI values (`0` to `127`), you can use [`rawAttack`](#rawAttack) and
 * [`rawRelease`](#rawRelease) to both get and set the values.
 *
 * The note may have a [`duration`](#duration). If it does, playback will be automatically stopped
 * when the duration has elapsed by sending a `"noteoff"` event. By default, the duration is set to
 * `Infinity`. In this case, it will never stop playing unless explicitly stopped by calling a
 * method such as [`OutputChannel.stopNote()`]{@link OutputChannel#stopNote},
 * [`Output.stopNote()`]{@link Output#stopNote} or similar.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */class an{constructor(t,e={}){this.duration=L.defaults.note.duration,this.attack=L.defaults.note.attack,this.release=L.defaults.note.release,e.duration!=null&&(this.duration=e.duration),e.attack!=null&&(this.attack=e.attack),e.rawAttack!=null&&(this.attack=R.from7bitToFloat(e.rawAttack)),e.release!=null&&(this.release=e.release),e.rawRelease!=null&&(this.release=R.from7bitToFloat(e.rawRelease)),Number.isInteger(t)?this.identifier=R.toNoteIdentifier(t):this.identifier=t}get identifier(){return this._name+(this._accidental||"")+this._octave}set identifier(t){const e=R.getNoteDetails(t);if(L.validation&&!t)throw new Error("Invalid note identifier");this._name=e.name,this._accidental=e.accidental,this._octave=e.octave}get name(){return this._name}set name(t){if(L.validation&&(t=t.toUpperCase(),!["C","D","E","F","G","A","B"].includes(t)))throw new Error("Invalid name value");this._name=t}get accidental(){return this._accidental}set accidental(t){if(L.validation&&(t=t.toLowerCase(),!["#","##","b","bb"].includes(t)))throw new Error("Invalid accidental value");this._accidental=t}get octave(){return this._octave}set octave(t){if(L.validation&&(t=parseInt(t),isNaN(t)))throw new Error("Invalid octave value");this._octave=t}get duration(){return this._duration}set duration(t){if(L.validation&&(t=parseFloat(t),isNaN(t)||t===null||t<0))throw new RangeError("Invalid duration value.");this._duration=t}get attack(){return this._attack}set attack(t){if(L.validation&&(t=parseFloat(t),isNaN(t)||!(t>=0&&t<=1)))throw new RangeError("Invalid attack value.");this._attack=t}get release(){return this._release}set release(t){if(L.validation&&(t=parseFloat(t),isNaN(t)||!(t>=0&&t<=1)))throw new RangeError("Invalid release value.");this._release=t}get rawAttack(){return R.fromFloatTo7Bit(this._attack)}set rawAttack(t){this._attack=R.from7bitToFloat(t)}get rawRelease(){return R.fromFloatTo7Bit(this._release)}set rawRelease(t){this._release=R.from7bitToFloat(t)}get number(){return R.toNoteNumber(this.identifier)}getOffsetNumber(t=0,e=0){return L.validation&&(t=parseInt(t)||0,e=parseInt(e)||0),Math.min(Math.max(this.number+12*t+e,0),127)}}/**
 * The `Utilities` class contains general-purpose utility methods. All methods are static and
 * should be called using the class name. For example: `Utilities.getNoteDetails("C4")`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */class R{static toNoteNumber(t,e=0){if(e=e==null?0:parseInt(e),isNaN(e))throw new RangeError("Invalid 'octaveOffset' value");typeof t!="string"&&(t="");const n=this.getNoteDetails(t);if(!n)throw new TypeError("Invalid note identifier");let s=12*(n.octave+1+e);if(s+={C:0,D:2,E:4,F:5,G:7,A:9,B:11}[n.name],n.accidental&&(n.accidental.startsWith("b")?s-=n.accidental.length:s+=n.accidental.length),s<0||s>127)throw new RangeError("Invalid octaveOffset value");return s}static getNoteDetails(t){Number.isInteger(t)&&(t=this.toNoteIdentifier(t));const e=t.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)$/i);if(!e)throw new TypeError("Invalid note identifier");const n=e[1].toUpperCase(),s=parseInt(e[3]);let r=e[2].toLowerCase();return r=r===""?void 0:r,{accidental:r,identifier:n+(r||"")+s,name:n,octave:s}}static sanitizeChannels(t){let e;if(this.validation){if(t==="all")e=["all"];else if(t==="none")return[]}return e=Array.isArray(t)?t:[t],e.indexOf("all")>-1&&(e=I.MIDI_CHANNEL_NUMBERS),e.map(function(n){return parseInt(n)}).filter(function(n){return n>=1&&n<=16})}static toTimestamp(t){let e=!1;const n=parseFloat(t);return!isNaN(n)&&(typeof t=="string"&&t.substring(0,1)==="+"?n>=0&&(e=L.time+n):n>=0&&(e=n),e)}static guessNoteNumber(t,e){e=parseInt(e)||0;let n=!1;if(Number.isInteger(t)&&t>=0&&t<=127)n=parseInt(t);else if(parseInt(t)>=0&&parseInt(t)<=127)n=parseInt(t);else if(typeof t=="string"||t instanceof String)try{n=this.toNoteNumber(t.trim(),e)}catch{return!1}return n}static toNoteIdentifier(t,e){if(t=parseInt(t),isNaN(t)||t<0||t>127)throw new RangeError("Invalid note number");if(e=e==null?0:parseInt(e),isNaN(e))throw new RangeError("Invalid octaveOffset value");const n=Math.floor(t/12-1)+e;return["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][t%12]+n.toString()}static buildNote(t,e={}){if(e.octaveOffset=parseInt(e.octaveOffset)||0,t instanceof an)return t;let n=this.guessNoteNumber(t,e.octaveOffset);if(n===!1)throw new TypeError(`The input could not be parsed as a note (${t})`);return e.octaveOffset=void 0,new an(n,e)}static buildNoteArray(t,e={}){let n=[];return Array.isArray(t)||(t=[t]),t.forEach(s=>{n.push(this.buildNote(s,e))}),n}static from7bitToFloat(t){return t===1/0&&(t=127),t=parseInt(t)||0,Math.min(Math.max(t/127,0),1)}static fromFloatTo7Bit(t){return t===1/0&&(t=1),t=parseFloat(t)||0,Math.min(Math.max(Math.round(127*t),0),127)}static fromMsbLsbToFloat(t,e=0){L.validation&&(t=Math.min(Math.max(parseInt(t)||0,0),127),e=Math.min(Math.max(parseInt(e)||0,0),127));const n=((t<<7)+e)/16383;return Math.min(Math.max(n,0),1)}static fromFloatToMsbLsb(t){L.validation&&(t=Math.min(Math.max(parseFloat(t)||0,0),1));const e=Math.round(16383*t);return{msb:e>>7,lsb:127&e}}static offsetNumber(t,e=0,n=0){if(L.validation){if(t=parseInt(t),isNaN(t))throw new Error("Invalid note number");e=parseInt(e)||0,n=parseInt(n)||0}return Math.min(Math.max(t+12*e+n,0),127)}static getPropertyByValue(t,e){return Object.keys(t).find(n=>t[n]===e)}static getCcNameByNumber(t){return R.getPropertyByValue(I.MIDI_CONTROL_CHANGE_MESSAGES,t)}static getChannelModeByNumber(t){if(!(t>=120&&t<=127))return!1;for(let e in I.MIDI_CHANNEL_MODE_MESSAGES)if(I.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(e)&&t===I.MIDI_CHANNEL_MODE_MESSAGES[e])return e;return!1}static get isNode(){return new Function("try { return this === global; } catch(e) { return false; }")()}static get isBrowser(){return new Function("try { return this === window; } catch(e) { return false; }")()}}/**
 * The `OutputChannel` class represents a single output MIDI channel. `OutputChannel` objects are
 * provided by an [`Output`](Output) port which, itself, is made available by a device. The
 * `OutputChannel` object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `OutputChannel` objects can be found inside the parent output's
 * [`channels`]{@link Output#channels} property.
 *
 * @param {Output} output The [`Output`](Output) this channel belongs to.
 * @param {number} number The MIDI channel number (`1` - `16`).
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */class Cf extends te{constructor(t,e){super(),this._output=t,this._number=e,this._octaveOffset=0}destroy(){this._output=null,this._number=null,this._octaveOffset=0,this.removeListener()}send(t,e={time:0}){return this.output.send(t,e),this}sendKeyAftertouch(t,e,n={}){if(L.validation){if(n.useRawValue&&(n.rawValue=n.useRawValue),isNaN(parseFloat(e)))throw new RangeError("Invalid key aftertouch value.");if(n.rawValue){if(!(e>=0&&e<=127&&Number.isInteger(e)))throw new RangeError("Key aftertouch raw value must be an integer between 0 and 127.")}else if(!(e>=0&&e<=1))throw new RangeError("Key aftertouch value must be a float between 0 and 1.")}n.rawValue||(e=R.fromFloatTo7Bit(e));const s=L.octaveOffset+this.output.octaveOffset+this.octaveOffset;return Array.isArray(t)||(t=[t]),R.buildNoteArray(t).forEach(r=>{this.send([(I.MIDI_CHANNEL_MESSAGES.keyaftertouch<<4)+(this.number-1),r.getOffsetNumber(s),e],{time:R.toTimestamp(n.time)})}),this}sendControlChange(t,e,n={}){if(typeof t=="string"&&(t=I.MIDI_CONTROL_CHANGE_MESSAGES[t]),Array.isArray(e)||(e=[e]),L.validation){if(t===void 0)throw new TypeError("Control change must be identified with a valid name or an integer between 0 and 127.");if(!Number.isInteger(t)||!(t>=0&&t<=127))throw new TypeError("Control change number must be an integer between 0 and 127.");if((e=e.map(s=>{const r=Math.min(Math.max(parseInt(s),0),127);if(isNaN(r))throw new TypeError("Values must be integers between 0 and 127");return r})).length===2&&t>=32)throw new TypeError("To use a value array, the controller must be between 0 and 31")}return e.forEach((s,r)=>{this.send([(I.MIDI_CHANNEL_MESSAGES.controlchange<<4)+(this.number-1),t+32*r,e[r]],{time:R.toTimestamp(n.time)})}),this}_selectNonRegisteredParameter(t,e={}){return this.sendControlChange(99,t[0],e),this.sendControlChange(98,t[1],e),this}_deselectRegisteredParameter(t={}){return this.sendControlChange(101,127,t),this.sendControlChange(100,127,t),this}_deselectNonRegisteredParameter(t={}){return this.sendControlChange(101,127,t),this.sendControlChange(100,127,t),this}_selectRegisteredParameter(t,e={}){return this.sendControlChange(101,t[0],e),this.sendControlChange(100,t[1],e),this}_setCurrentParameter(t,e={}){return t=[].concat(t),this.sendControlChange(6,t[0],e),t.length<2||this.sendControlChange(38,t[1],e),this}sendRpnDecrement(t,e={}){if(Array.isArray(t)||(t=I.MIDI_REGISTERED_PARAMETERS[t]),L.validation){if(t===void 0)throw new TypeError("The specified registered parameter is invalid.");let n=!1;if(Object.getOwnPropertyNames(I.MIDI_REGISTERED_PARAMETERS).forEach(s=>{I.MIDI_REGISTERED_PARAMETERS[s][0]===t[0]&&I.MIDI_REGISTERED_PARAMETERS[s][1]===t[1]&&(n=!0)}),!n)throw new TypeError("The specified registered parameter is invalid.")}return this._selectRegisteredParameter(t,e),this.sendControlChange(97,0,e),this._deselectRegisteredParameter(e),this}sendRpnIncrement(t,e={}){if(Array.isArray(t)||(t=I.MIDI_REGISTERED_PARAMETERS[t]),L.validation){if(t===void 0)throw new TypeError("The specified registered parameter is invalid.");let n=!1;if(Object.getOwnPropertyNames(I.MIDI_REGISTERED_PARAMETERS).forEach(s=>{I.MIDI_REGISTERED_PARAMETERS[s][0]===t[0]&&I.MIDI_REGISTERED_PARAMETERS[s][1]===t[1]&&(n=!0)}),!n)throw new TypeError("The specified registered parameter is invalid.")}return this._selectRegisteredParameter(t,e),this.sendControlChange(96,0,e),this._deselectRegisteredParameter(e),this}playNote(t,e={}){if(this.sendNoteOn(t,e),e.duration>0&&isFinite(String(e.duration).trim()||NaN)){let n={time:(R.toTimestamp(e.time)||L.time)+e.duration,release:e.release,rawRelease:e.rawRelease};this.sendNoteOff(t,n)}return this}sendNoteOff(t,e={}){if(L.validation){if(e.rawRelease!=null&&!(e.rawRelease>=0&&e.rawRelease<=127))throw new RangeError("The 'rawRelease' option must be an integer between 0 and 127");if(e.release!=null&&!(e.release>=0&&e.release<=1))throw new RangeError("The 'release' option must be an number between 0 and 1");e.rawVelocity&&(e.rawRelease=e.velocity,console.warn("The 'rawVelocity' option is deprecated. Use 'rawRelease' instead.")),e.velocity&&(e.release=e.velocity,console.warn("The 'velocity' option is deprecated. Use 'attack' instead."))}let n=64;e.rawRelease!=null?n=e.rawRelease:isNaN(e.release)||(n=Math.round(127*e.release));const s=L.octaveOffset+this.output.octaveOffset+this.octaveOffset;return R.buildNoteArray(t,{rawRelease:parseInt(n)}).forEach(r=>{this.send([(I.MIDI_CHANNEL_MESSAGES.noteoff<<4)+(this.number-1),r.getOffsetNumber(s),r.rawRelease],{time:R.toTimestamp(e.time)})}),this}stopNote(t,e={}){return this.sendNoteOff(t,e)}sendNoteOn(t,e={}){if(L.validation){if(e.rawAttack!=null&&!(e.rawAttack>=0&&e.rawAttack<=127))throw new RangeError("The 'rawAttack' option must be an integer between 0 and 127");if(e.attack!=null&&!(e.attack>=0&&e.attack<=1))throw new RangeError("The 'attack' option must be an number between 0 and 1");e.rawVelocity&&(e.rawAttack=e.velocity,e.rawRelease=e.release,console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' or 'rawRelease'.")),e.velocity&&(e.attack=e.velocity,console.warn("The 'velocity' option is deprecated. Use 'attack' instead."))}let n=64;e.rawAttack!=null?n=e.rawAttack:isNaN(e.attack)||(n=Math.round(127*e.attack));const s=L.octaveOffset+this.output.octaveOffset+this.octaveOffset;return R.buildNoteArray(t,{rawAttack:n}).forEach(r=>{this.send([(I.MIDI_CHANNEL_MESSAGES.noteon<<4)+(this.number-1),r.getOffsetNumber(s),r.rawAttack],{time:R.toTimestamp(e.time)})}),this}sendChannelMode(t,e=0,n={}){if(typeof t=="string"&&(t=I.MIDI_CHANNEL_MODE_MESSAGES[t]),L.validation){if(t===void 0)throw new TypeError("Invalid channel mode message name or number.");if(isNaN(t)||!(t>=120&&t<=127))throw new TypeError("Invalid channel mode message number.");if(isNaN(parseInt(e))||e<0||e>127)throw new RangeError("Value must be an integer between 0 and 127.")}return this.send([(I.MIDI_CHANNEL_MESSAGES.controlchange<<4)+(this.number-1),t,e],{time:R.toTimestamp(n.time)}),this}sendOmniMode(t,e={}){return t===void 0||t?this.sendChannelMode("omnimodeon",0,e):this.sendChannelMode("omnimodeoff",0,e),this}sendChannelAftertouch(t,e={}){if(L.validation){if(isNaN(parseFloat(t)))throw new RangeError("Invalid channel aftertouch value.");if(e.rawValue){if(!(t>=0&&t<=127&&Number.isInteger(t)))throw new RangeError("Channel aftertouch raw value must be an integer between 0 and 127.")}else if(!(t>=0&&t<=1))throw new RangeError("Channel aftertouch value must be a float between 0 and 1.")}return this.send([(I.MIDI_CHANNEL_MESSAGES.channelaftertouch<<4)+(this.number-1),Math.round(127*t)],{time:R.toTimestamp(e.time)}),this}sendMasterTuning(t,e={}){if(t=parseFloat(t)||0,L.validation&&!(t>-65&&t<64))throw new RangeError("The value must be a decimal number larger than -65 and smaller than 64.");let n=Math.floor(t)+64,s=t-Math.floor(t);s=Math.round((s+1)/2*16383);let r=s>>7&127,a=127&s;return this.sendRpnValue("channelcoarsetuning",n,e),this.sendRpnValue("channelfinetuning",[r,a],e),this}sendModulationRange(t,e,n={}){if(L.validation){if(!Number.isInteger(t)||!(t>=0&&t<=127))throw new RangeError("The semitones value must be an integer between 0 and 127.");if(!(e==null||Number.isInteger(e)&&e>=0&&e<=127))throw new RangeError("If specified, the cents value must be an integer between 0 and 127.")}return e>=0&&e<=127||(e=0),this.sendRpnValue("modulationrange",[t,e],n),this}sendNrpnValue(t,e,n={}){if(e=[].concat(e),L.validation){if(!Array.isArray(t)||!Number.isInteger(t[0])||!Number.isInteger(t[1]))throw new TypeError("The specified NRPN is invalid.");if(!(t[0]>=0&&t[0]<=127))throw new RangeError("The first byte of the NRPN must be between 0 and 127.");if(!(t[1]>=0&&t[1]<=127))throw new RangeError("The second byte of the NRPN must be between 0 and 127.");e.forEach(s=>{if(!(s>=0&&s<=127))throw new RangeError("The data bytes of the NRPN must be between 0 and 127.")})}return this._selectNonRegisteredParameter(t,n),this._setCurrentParameter(e,n),this._deselectNonRegisteredParameter(n),this}sendPitchBend(t,e={}){if(L.validation)if(e.rawValue&&Array.isArray(t)){if(!(t[0]>=0&&t[0]<=127))throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");if(!(t[1]>=0&&t[1]<=127))throw new RangeError("The pitch bend LSB must be an integer between 0 and 127.")}else if(e.rawValue&&!Array.isArray(t)){if(!(t>=0&&t<=127))throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.")}else{if(isNaN(t)||t===null)throw new RangeError("Invalid pitch bend value.");if(!(t>=-1&&t<=1))throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.")}let n=0,s=0;if(e.rawValue&&Array.isArray(t))n=t[0],s=t[1];else if(e.rawValue&&!Array.isArray(t))n=t;else{const r=R.fromFloatToMsbLsb((t+1)/2);n=r.msb,s=r.lsb}return this.send([(I.MIDI_CHANNEL_MESSAGES.pitchbend<<4)+(this.number-1),s,n],{time:R.toTimestamp(e.time)}),this}sendPitchBendRange(t,e,n={}){if(L.validation){if(!Number.isInteger(t)||!(t>=0&&t<=127))throw new RangeError("The semitones value must be an integer between 0 and 127.");if(!Number.isInteger(e)||!(e>=0&&e<=127))throw new RangeError("The cents value must be an integer between 0 and 127.")}return this.sendRpnValue("pitchbendrange",[t,e],n),this}sendProgramChange(t,e={}){if(t=parseInt(t)||0,L.validation&&!(t>=0&&t<=127))throw new RangeError("The program number must be between 0 and 127.");return this.send([(I.MIDI_CHANNEL_MESSAGES.programchange<<4)+(this.number-1),t],{time:R.toTimestamp(e.time)}),this}sendRpnValue(t,e,n={}){if(Array.isArray(t)||(t=I.MIDI_REGISTERED_PARAMETERS[t]),L.validation){if(!Number.isInteger(t[0])||!Number.isInteger(t[1]))throw new TypeError("The specified NRPN is invalid.");if(!(t[0]>=0&&t[0]<=127))throw new RangeError("The first byte of the RPN must be between 0 and 127.");if(!(t[1]>=0&&t[1]<=127))throw new RangeError("The second byte of the RPN must be between 0 and 127.");[].concat(e).forEach(s=>{if(!(s>=0&&s<=127))throw new RangeError("The data bytes of the RPN must be between 0 and 127.")})}return this._selectRegisteredParameter(t,n),this._setCurrentParameter(e,n),this._deselectRegisteredParameter(n),this}sendTuningBank(t,e={}){if(L.validation&&(!Number.isInteger(t)||!(t>=0&&t<=127)))throw new RangeError("The tuning bank number must be between 0 and 127.");return this.sendRpnValue("tuningbank",t,e),this}sendTuningProgram(t,e={}){if(L.validation&&(!Number.isInteger(t)||!(t>=0&&t<=127)))throw new RangeError("The tuning program number must be between 0 and 127.");return this.sendRpnValue("tuningprogram",t,e),this}sendLocalControl(t,e={}){return t?this.sendChannelMode("localcontrol",127,e):this.sendChannelMode("localcontrol",0,e)}sendAllNotesOff(t={}){return this.sendChannelMode("allnotesoff",0,t)}sendAllSoundOff(t={}){return this.sendChannelMode("allsoundoff",0,t)}sendResetAllControllers(t={}){return this.sendChannelMode("resetallcontrollers",0,t)}sendPolyphonicMode(t,e={}){return t==="mono"?this.sendChannelMode("monomodeon",0,e):this.sendChannelMode("polymodeon",0,e)}get octaveOffset(){return this._octaveOffset}set octaveOffset(t){if(this.validation&&(t=parseInt(t),isNaN(t)))throw new TypeError("The 'octaveOffset' property must be an integer.");this._octaveOffset=t}get output(){return this._output}get number(){return this._number}}/**
 * The `Output` class represents a single MIDI output port (not to be confused with a MIDI channel).
 * A port is made available by a MIDI device. A MIDI device can advertise several input and output
 * ports. Each port has 16 MIDI channels which can be accessed via the [`channels`](#channels)
 * property.
 *
 * The `Output` object is automatically instantiated by the library according to the host's MIDI
 * subsystem and should not be directly instantiated.
 *
 * You can access all available `Output` objects by referring to the
 * [`WebMidi.outputs`](WebMidi#outputs) array or by using methods such as
 * [`WebMidi.getOutputByName()`](WebMidi#getOutputByName) or
 * [`WebMidi.getOutputById()`](WebMidi#getOutputById).
 *
 * @fires Output#opened
 * @fires Output#disconnected
 * @fires Output#closed
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */class fi extends te{constructor(t){super(),this._midiOutput=t,this._octaveOffset=0,this.channels=[];for(let e=1;e<=16;e++)this.channels[e]=new Cf(this,e);this._midiOutput.onstatechange=this._onStateChange.bind(this)}async destroy(){this.removeListener(),this.channels.forEach(t=>t.destroy()),this.channels=[],this._midiOutput.onstatechange=null,await this.close(),this._midiOutput=null}_onStateChange(t){let e={timestamp:L.time};t.port.connection==="open"?(e.type="opened",e.target=this,e.port=e.target,this.emit("opened",e)):t.port.connection==="closed"&&t.port.state==="connected"?(e.type="closed",e.target=this,e.port=e.target,this.emit("closed",e)):t.port.connection==="closed"&&t.port.state==="disconnected"?(e.type="disconnected",e.port={connection:t.port.connection,id:t.port.id,manufacturer:t.port.manufacturer,name:t.port.name,state:t.port.state,type:t.port.type},this.emit("disconnected",e)):t.port.connection==="pending"&&t.port.state==="disconnected"||console.warn("This statechange event was not caught:",t.port.connection,t.port.state)}async open(){try{return await this._midiOutput.open(),Promise.resolve(this)}catch(t){return Promise.reject(t)}}async close(){this._midiOutput?await this._midiOutput.close():await Promise.resolve()}send(t,e={time:0},n=0){if(t instanceof ja&&(t=R.isNode?t.data:t.rawData),t instanceof Uint8Array&&R.isNode&&(t=Array.from(t)),L.validation){if(Array.isArray(t)||t instanceof Uint8Array||(t=[t],Array.isArray(e)&&(t=t.concat(e)),e=isNaN(n)?{time:0}:{time:n}),!(parseInt(t[0])>=128&&parseInt(t[0])<=255))throw new RangeError("The first byte (status) must be an integer between 128 and 255.");t.slice(1).forEach(s=>{if(!((s=parseInt(s))>=0&&s<=255))throw new RangeError("Data bytes must be integers between 0 and 255.")}),e||(e={time:0})}return this._midiOutput.send(t,R.toTimestamp(e.time)),this}sendSysex(t,e=[],n={}){if(t=[].concat(t),e instanceof Uint8Array){const s=new Uint8Array(1+t.length+e.length+1);s[0]=I.MIDI_SYSTEM_MESSAGES.sysex,s.set(Uint8Array.from(t),1),s.set(e,1+t.length),s[s.length-1]=I.MIDI_SYSTEM_MESSAGES.sysexend,this.send(s,{time:n.time})}else{const s=t.concat(e,I.MIDI_SYSTEM_MESSAGES.sysexend);this.send([I.MIDI_SYSTEM_MESSAGES.sysex].concat(s),{time:n.time})}return this}clear(){return this._midiOutput.clear?this._midiOutput.clear():L.validation&&console.warn("The 'clear()' method has not yet been implemented in your environment."),this}sendTimecodeQuarterFrame(t,e={}){if(L.validation&&(t=parseInt(t),isNaN(t)||!(t>=0&&t<=127)))throw new RangeError("The value must be an integer between 0 and 127.");return this.send([I.MIDI_SYSTEM_MESSAGES.timecode,t],{time:e.time}),this}sendSongPosition(t=0,e={}){var n=(t=Math.floor(t)||0)>>7&127,s=127&t;return this.send([I.MIDI_SYSTEM_MESSAGES.songposition,n,s],{time:e.time}),this}sendSongSelect(t=0,e={}){if(L.validation&&(t=parseInt(t),isNaN(t)||!(t>=0&&t<=127)))throw new RangeError("The program value must be between 0 and 127");return this.send([I.MIDI_SYSTEM_MESSAGES.songselect,t],{time:e.time}),this}sendTuneRequest(t={}){return this.send([I.MIDI_SYSTEM_MESSAGES.tunerequest],{time:t.time}),this}sendClock(t={}){return this.send([I.MIDI_SYSTEM_MESSAGES.clock],{time:t.time}),this}sendStart(t={}){return this.send([I.MIDI_SYSTEM_MESSAGES.start],{time:t.time}),this}sendContinue(t={}){return this.send([I.MIDI_SYSTEM_MESSAGES.continue],{time:t.time}),this}sendStop(t={}){return this.send([I.MIDI_SYSTEM_MESSAGES.stop],{time:t.time}),this}sendActiveSensing(t={}){return this.send([I.MIDI_SYSTEM_MESSAGES.activesensing],{time:t.time}),this}sendReset(t={}){return this.send([I.MIDI_SYSTEM_MESSAGES.reset],{time:t.time}),this}sendTuningRequest(t={}){return L.validation&&console.warn("The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead."),this.sendTuneRequest(t)}sendKeyAftertouch(t,e,n={}){return n.channels==null&&(n.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(n.channels).forEach(s=>{this.channels[s].sendKeyAftertouch(t,e,n)}),this}sendControlChange(t,e,n={},s={}){if(L.validation&&(Array.isArray(n)||Number.isInteger(n)||n==="all")){const r=n;(n=s).channels=r,n.channels==="all"&&(n.channels=I.MIDI_CHANNEL_NUMBERS)}return n.channels==null&&(n.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(n.channels).forEach(r=>{this.channels[r].sendControlChange(t,e,n)}),this}sendPitchBendRange(t=0,e=0,n={}){return n.channels==null&&(n.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(n.channels).forEach(s=>{this.channels[s].sendPitchBendRange(t,e,n)}),this}setPitchBendRange(t=0,e=0,n="all",s={}){return L.validation&&(console.warn("The setPitchBendRange() method is deprecated. Use sendPitchBendRange() instead."),s.channels=n,s.channels==="all"&&(s.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendPitchBendRange(t,e,s)}sendRpnValue(t,e,n={}){return n.channels==null&&(n.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(n.channels).forEach(s=>{this.channels[s].sendRpnValue(t,e,n)}),this}setRegisteredParameter(t,e=[],n="all",s={}){return L.validation&&(console.warn("The setRegisteredParameter() method is deprecated. Use sendRpnValue() instead."),s.channels=n,s.channels==="all"&&(s.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendRpnValue(t,e,s)}sendChannelAftertouch(t,e={},n={}){if(L.validation&&(Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].sendChannelAftertouch(t,e)}),this}sendPitchBend(t,e={},n={}){if(L.validation&&(Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].sendPitchBend(t,e)}),this}sendProgramChange(t=0,e={},n={}){if(L.validation&&(Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].sendProgramChange(t,e)}),this}sendModulationRange(t,e,n={}){return n.channels==null&&(n.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(n.channels).forEach(s=>{this.channels[s].sendModulationRange(t,e,n)}),this}setModulationRange(t=0,e=0,n="all",s={}){return L.validation&&(console.warn("The setModulationRange() method is deprecated. Use sendModulationRange() instead."),s.channels=n,s.channels==="all"&&(s.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendModulationRange(t,e,s)}sendMasterTuning(t,e={}){return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(n=>{this.channels[n].sendMasterTuning(t,e)}),this}setMasterTuning(t,e={},n={}){return L.validation&&(console.warn("The setMasterTuning() method is deprecated. Use sendMasterTuning() instead."),n.channels=e,n.channels==="all"&&(n.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendMasterTuning(t,n)}sendTuningProgram(t,e={}){return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(n=>{this.channels[n].sendTuningProgram(t,e)}),this}setTuningProgram(t,e="all",n={}){return L.validation&&(console.warn("The setTuningProgram() method is deprecated. Use sendTuningProgram() instead."),n.channels=e,n.channels==="all"&&(n.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendTuningProgram(t,n)}sendTuningBank(t=0,e={}){return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(n=>{this.channels[n].sendTuningBank(t,e)}),this}setTuningBank(t,e="all",n={}){return L.validation&&(console.warn("The setTuningBank() method is deprecated. Use sendTuningBank() instead."),n.channels=e,n.channels==="all"&&(n.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendTuningBank(t,n)}sendChannelMode(t,e=0,n={},s={}){if(L.validation&&(Array.isArray(n)||Number.isInteger(n)||n==="all")){const r=n;(n=s).channels=r,n.channels==="all"&&(n.channels=I.MIDI_CHANNEL_NUMBERS)}return n.channels==null&&(n.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(n.channels).forEach(r=>{this.channels[r].sendChannelMode(t,e,n)}),this}sendAllSoundOff(t={}){return t.channels==null&&(t.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(t.channels).forEach(e=>{this.channels[e].sendAllSoundOff(t)}),this}sendAllNotesOff(t={}){return t.channels==null&&(t.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(t.channels).forEach(e=>{this.channels[e].sendAllNotesOff(t)}),this}sendResetAllControllers(t={},e={}){if(L.validation&&(Array.isArray(t)||Number.isInteger(t)||t==="all")){const n=t;(t=e).channels=n,t.channels==="all"&&(t.channels=I.MIDI_CHANNEL_NUMBERS)}return t.channels==null&&(t.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(t.channels).forEach(n=>{this.channels[n].sendResetAllControllers(t)}),this}sendPolyphonicMode(t,e={},n={}){if(L.validation&&(Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].sendPolyphonicMode(t,e)}),this}sendLocalControl(t,e={},n={}){if(L.validation&&(Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].sendLocalControl(t,e)}),this}sendOmniMode(t,e={},n={}){if(L.validation&&(Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].sendOmniMode(t,e)}),this}sendNrpnValue(t,e,n={}){return n.channels==null&&(n.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(n.channels).forEach(s=>{this.channels[s].sendNrpnValue(t,e,n)}),this}setNonRegisteredParameter(t,e=[],n="all",s={}){return L.validation&&(console.warn("The setNonRegisteredParameter() method is deprecated. Use sendNrpnValue() instead."),s.channels=n,s.channels==="all"&&(s.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendNrpnValue(t,e,s)}sendRpnIncrement(t,e={}){return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(n=>{this.channels[n].sendRpnIncrement(t,e)}),this}incrementRegisteredParameter(t,e="all",n={}){return L.validation&&(console.warn("The incrementRegisteredParameter() method is deprecated. Use sendRpnIncrement() instead."),n.channels=e,n.channels==="all"&&(n.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendRpnIncrement(t,n)}sendRpnDecrement(t,e={}){return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(n=>{this.channels[n].sendRpnDecrement(t,e)}),this}decrementRegisteredParameter(t,e="all",n={}){return L.validation&&(console.warn("The decrementRegisteredParameter() method is deprecated. Use sendRpnDecrement() instead."),n.channels=e,n.channels==="all"&&(n.channels=I.MIDI_CHANNEL_NUMBERS)),this.sendRpnDecrement(t,n)}sendNoteOff(t,e={},n={}){if(L.validation&&(Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].sendNoteOff(t,e)}),this}stopNote(t,e){return this.sendNoteOff(t,e)}playNote(t,e={},n={}){if(L.validation&&(e.rawVelocity&&console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' instead."),e.velocity&&console.warn("The 'velocity' option is deprecated. Use 'velocity' instead."),Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].playNote(t,e)}),this}sendNoteOn(t,e={},n={}){if(L.validation&&(Array.isArray(e)||Number.isInteger(e)||e==="all")){const s=e;(e=n).channels=s,e.channels==="all"&&(e.channels=I.MIDI_CHANNEL_NUMBERS)}return e.channels==null&&(e.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(e.channels).forEach(s=>{this.channels[s].sendNoteOn(t,e)}),this}get name(){return this._midiOutput.name}get id(){return this._midiOutput.id}get connection(){return this._midiOutput.connection}get manufacturer(){return this._midiOutput.manufacturer}get state(){return this._midiOutput.state}get type(){return this._midiOutput.type}get octaveOffset(){return this._octaveOffset}set octaveOffset(t){if(this.validation&&(t=parseInt(t),isNaN(t)))throw new TypeError("The 'octaveOffset' property must be an integer.");this._octaveOffset=t}}/**
 * The `Forwarder` class allows the forwarding of MIDI messages to predetermined outputs. When you
 * call its [`forward()`](#forward) method, it will send the specified [`Message`](Message) object
 * to all the outputs listed in its [`destinations`](#destinations) property.
 *
 * If specific channels or message types have been defined in the [`channels`](#channels) or
 * [`types`](#types) properties, only messages matching the channels/types will be forwarded.
 *
 * While it can be manually instantiated, you are more likely to come across a `Forwarder` object as
 * the return value of the [`Input.addForwarder()`](Input#addForwarder) method.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */class Sr{constructor(t=[],e={}){this.destinations=[],this.types=[...Object.keys(I.MIDI_SYSTEM_MESSAGES),...Object.keys(I.MIDI_CHANNEL_MESSAGES)],this.channels=I.MIDI_CHANNEL_NUMBERS,this.suspended=!1,Array.isArray(t)||(t=[t]),e.types&&!Array.isArray(e.types)&&(e.types=[e.types]),e.channels&&!Array.isArray(e.channels)&&(e.channels=[e.channels]),L.validation&&(t.forEach(n=>{if(!(n instanceof fi))throw new TypeError("Destinations must be of type 'Output'.")}),e.types!==void 0&&e.types.forEach(n=>{if(!I.MIDI_SYSTEM_MESSAGES.hasOwnProperty(n)&&!I.MIDI_CHANNEL_MESSAGES.hasOwnProperty(n))throw new TypeError("Type must be a valid message type.")}),e.channels!==void 0&&e.channels.forEach(n=>{if(!I.MIDI_CHANNEL_NUMBERS.includes(n))throw new TypeError("MIDI channel must be between 1 and 16.")})),this.destinations=t,e.types&&(this.types=e.types),e.channels&&(this.channels=e.channels)}forward(t){this.suspended||this.types.includes(t.type)&&(t.channel&&!this.channels.includes(t.channel)||this.destinations.forEach(e=>{(!L.validation||e instanceof fi)&&e.send(t)}))}}/**
 * The `InputChannel` class represents a single MIDI input channel (1-16) from a single input
 * device. This object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `InputChannel` objects can be found inside the input's [`channels`](Input#channels)
 * property.
 *
 * @fires InputChannel#midimessage
 * @fires InputChannel#unknownmessage
 *
 * @fires InputChannel#noteoff
 * @fires InputChannel#noteon
 * @fires InputChannel#keyaftertouch
 * @fires InputChannel#programchange
 * @fires InputChannel#event:controlchange-controllerxxx
 * @fires InputChannel#channelaftertouch
 * @fires InputChannel#pitchbend
 * @fires InputChannel#controlchange
 *
 * @fires InputChannel#allnotesoff
 * @fires InputChannel#allsoundoff
 * @fires InputChannel#localcontrol
 * @fires InputChannel#monomode
 * @fires InputChannel#omnimode
 * @fires InputChannel#resetallcontrollers
 *
 * @fires InputChannel#event:nrpn
 * @fires InputChannel#event:nrpn-dataentrycoarse
 * @fires InputChannel#event:nrpn-dataentryfine
 * @fires InputChannel#event:nrpn-databuttonincrement
 * @fires InputChannel#event:nrpn-databuttondecrement
 * @fires InputChannel#event:rpn
 * @fires InputChannel#event:rpn-dataentrycoarse
 * @fires InputChannel#event:rpn-dataentryfine
 * @fires InputChannel#event:rpn-databuttonincrement
 * @fires InputChannel#event:rpn-databuttondecrement
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */class Mf extends te{constructor(t,e){super(),this._input=t,this._number=e,this._octaveOffset=0,this._nrpnBuffer=[],this._rpnBuffer=[],this.parameterNumberEventsEnabled=!0,this.notesState=new Array(128).fill(!1)}destroy(){this._input=null,this._number=null,this._octaveOffset=0,this._nrpnBuffer=[],this.notesState=new Array(128).fill(!1),this.parameterNumberEventsEnabled=!1,this.removeListener()}_processMidiMessageEvent(t){const e=Object.assign({},t);e.port=this.input,e.target=this,e.type="midimessage",this.emit(e.type,e),this._parseEventForStandardMessages(e)}_parseEventForStandardMessages(t){const e=Object.assign({},t);e.type=e.message.type||"unknownmessage";const n=t.message.dataBytes[0],s=t.message.dataBytes[1];if(e.type==="noteoff"||e.type==="noteon"&&s===0)this.notesState[n]=!1,e.type="noteoff",e.note=new an(R.offsetNumber(n,this.octaveOffset+this.input.octaveOffset+L.octaveOffset),{rawAttack:0,rawRelease:s}),e.value=R.from7bitToFloat(s),e.rawValue=s,e.velocity=e.note.release,e.rawVelocity=e.note.rawRelease;else if(e.type==="noteon")this.notesState[n]=!0,e.note=new an(R.offsetNumber(n,this.octaveOffset+this.input.octaveOffset+L.octaveOffset),{rawAttack:s}),e.value=R.from7bitToFloat(s),e.rawValue=s,e.velocity=e.note.attack,e.rawVelocity=e.note.rawAttack;else if(e.type==="keyaftertouch")e.note=new an(R.offsetNumber(n,this.octaveOffset+this.input.octaveOffset+L.octaveOffset)),e.value=R.from7bitToFloat(s),e.rawValue=s,e.identifier=e.note.identifier,e.key=e.note.number,e.rawKey=n;else if(e.type==="controlchange"){e.controller={number:n,name:R.getCcNameByNumber(n)},e.subtype=e.controller.name||"controller"+n,e.value=R.from7bitToFloat(s),e.rawValue=s;const r=Object.assign({},e);r.type=`${e.type}-controller${n}`,delete r.subtype,this.emit(r.type,r),e.message.dataBytes[0]>=120&&this._parseChannelModeMessage(e),this.parameterNumberEventsEnabled&&this._isRpnOrNrpnController(e.message.dataBytes[0])&&this._parseEventForParameterNumber(e)}else e.type==="programchange"?(e.value=n,e.rawValue=e.value):e.type==="channelaftertouch"?(e.value=R.from7bitToFloat(n),e.rawValue=n):e.type==="pitchbend"?(e.value=((s<<7)+n-8192)/8192,e.rawValue=(s<<7)+n):e.type="unknownmessage";this.emit(e.type,e)}_parseChannelModeMessage(t){const e=Object.assign({},t);e.type=e.controller.name,e.type==="localcontrol"&&(e.value=e.message.data[2]===127,e.rawValue=e.message.data[2]),e.type==="omnimodeon"?(e.type="omnimode",e.value=!0,e.rawValue=e.message.data[2]):e.type==="omnimodeoff"&&(e.type="omnimode",e.value=!1,e.rawValue=e.message.data[2]),e.type==="monomodeon"?(e.type="monomode",e.value=!0,e.rawValue=e.message.data[2]):e.type==="polymodeon"&&(e.type="monomode",e.value=!1,e.rawValue=e.message.data[2]),this.emit(e.type,e)}_parseEventForParameterNumber(t){const e=t.message.dataBytes[0],n=t.message.dataBytes[1],s=I.MIDI_CONTROL_CHANGE_MESSAGES;e===s.nonregisteredparameterfine||e===s.registeredparameterfine?(this._nrpnBuffer=[],this._rpnBuffer=[],e===s.nonregisteredparameterfine?this._nrpnBuffer=[t.message]:n!==127&&(this._rpnBuffer=[t.message])):e===s.nonregisteredparametercoarse||e===s.registeredparametercoarse?e===s.nonregisteredparametercoarse?(this._rpnBuffer=[],this._nrpnBuffer.length===1?this._nrpnBuffer.push(t.message):this._nrpnBuffer=[]):(this._nrpnBuffer=[],this._rpnBuffer.length===1&&n!==127?this._rpnBuffer.push(t.message):this._rpnBuffer=[]):e!==s.dataentrycoarse&&e!==s.dataentryfine&&e!==s.databuttonincrement&&e!==s.databuttondecrement||(this._rpnBuffer.length===2?this._dispatchParameterNumberEvent("rpn",this._rpnBuffer[0].dataBytes[1],this._rpnBuffer[1].dataBytes[1],t):this._nrpnBuffer.length===2?this._dispatchParameterNumberEvent("nrpn",this._nrpnBuffer[0].dataBytes[1],this._nrpnBuffer[1].dataBytes[1],t):(this._nrpnBuffer=[],this._rpnBuffer=[]))}_isRpnOrNrpnController(t){return t===I.MIDI_CONTROL_CHANGE_MESSAGES.dataentrycoarse||t===I.MIDI_CONTROL_CHANGE_MESSAGES.dataentryfine||t===I.MIDI_CONTROL_CHANGE_MESSAGES.databuttonincrement||t===I.MIDI_CONTROL_CHANGE_MESSAGES.databuttondecrement||t===I.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparametercoarse||t===I.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparameterfine||t===I.MIDI_CONTROL_CHANGE_MESSAGES.registeredparametercoarse||t===I.MIDI_CONTROL_CHANGE_MESSAGES.registeredparameterfine}_dispatchParameterNumberEvent(t,e,n,s){t=t==="nrpn"?"nrpn":"rpn";const r={target:s.target,timestamp:s.timestamp,message:s.message,parameterMsb:e,parameterLsb:n,value:R.from7bitToFloat(s.message.dataBytes[1]),rawValue:s.message.dataBytes[1]};r.parameter=t==="rpn"?Object.keys(I.MIDI_REGISTERED_PARAMETERS).find(o=>I.MIDI_REGISTERED_PARAMETERS[o][0]===e&&I.MIDI_REGISTERED_PARAMETERS[o][1]===n):(e<<7)+n;const a=R.getPropertyByValue(I.MIDI_CONTROL_CHANGE_MESSAGES,s.message.dataBytes[0]);r.type=`${t}-${a}`,this.emit(r.type,r),r.type=t,r.subtype=a,this.emit(r.type,r)}getChannelModeByNumber(t){return L.validation&&(console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class."),t=Math.floor(t)),R.getChannelModeByNumber(t)}getCcNameByNumber(t){if(L.validation&&(console.warn("The 'getCcNameByNumber()' method has been moved to the 'Utilities' class."),!((t=parseInt(t))>=0&&t<=127)))throw new RangeError("Invalid control change number.");return R.getCcNameByNumber(t)}getNoteState(t){t instanceof an&&(t=t.identifier);const e=R.guessNoteNumber(t,L.octaveOffset+this.input.octaveOffset+this.octaveOffset);return this.notesState[e]}get octaveOffset(){return this._octaveOffset}set octaveOffset(t){if(this.validation&&(t=parseInt(t),isNaN(t)))throw new TypeError("The 'octaveOffset' property must be an integer.");this._octaveOffset=t}get input(){return this._input}get number(){return this._number}get nrpnEventsEnabled(){return this.parameterNumberEventsEnabled}set nrpnEventsEnabled(t){this.validation&&(t=!!t),this.parameterNumberEventsEnabled=t}}/**
 * The `Message` class represents a single MIDI message. It has several properties that make it
 * easy to make sense of the binary data it contains.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */class ja{constructor(t){this.rawData=t,this.data=Array.from(this.rawData),this.statusByte=this.rawData[0],this.rawDataBytes=this.rawData.slice(1),this.dataBytes=this.data.slice(1),this.isChannelMessage=!1,this.isSystemMessage=!1,this.command=void 0,this.channel=void 0,this.manufacturerId=void 0,this.type=void 0,this.statusByte<240?(this.isChannelMessage=!0,this.command=this.statusByte>>4,this.channel=1+(15&this.statusByte)):(this.isSystemMessage=!0,this.command=this.statusByte),this.isChannelMessage?this.type=R.getPropertyByValue(I.MIDI_CHANNEL_MESSAGES,this.command):this.isSystemMessage&&(this.type=R.getPropertyByValue(I.MIDI_SYSTEM_MESSAGES,this.command)),this.statusByte===I.MIDI_SYSTEM_MESSAGES.sysex&&(this.dataBytes[0]===0?(this.manufacturerId=this.dataBytes.slice(0,3),this.dataBytes=this.dataBytes.slice(3,this.rawDataBytes.length-1),this.rawDataBytes=this.rawDataBytes.slice(3,this.rawDataBytes.length-1)):(this.manufacturerId=[this.dataBytes[0]],this.dataBytes=this.dataBytes.slice(1,this.dataBytes.length-1),this.rawDataBytes=this.rawDataBytes.slice(1,this.rawDataBytes.length-1)))}}/**
 * The `Input` class represents a single MIDI input port. This object is automatically instantiated
 * by the library according to the host's MIDI subsystem and does not need to be directly
 * instantiated. Instead, you can access all `Input` objects by referring to the
 * [`WebMidi.inputs`](WebMidi#inputs) array. You can also retrieve inputs by using methods such as
 * [`WebMidi.getInputByName()`](WebMidi#getInputByName) and
 * [`WebMidi.getInputById()`](WebMidi#getInputById).
 *
 * Note that a single MIDI device may expose several inputs and/or outputs.
 *
 * **Important**: the `Input` class does not directly fire channel-specific MIDI messages
 * (such as [`noteon`](InputChannel#event:noteon) or
 * [`controlchange`](InputChannel#event:controlchange), etc.). The [`InputChannel`](InputChannel)
 * object does that. However, you can still use the
 * [`Input.addListener()`](#addListener) method to listen to channel-specific events on multiple
 * [`InputChannel`](InputChannel) objects at once.
 *
 * @fires Input#opened
 * @fires Input#disconnected
 * @fires Input#closed
 * @fires Input#midimessage
 *
 * @fires Input#sysex
 * @fires Input#timecode
 * @fires Input#songposition
 * @fires Input#songselect
 * @fires Input#tunerequest
 * @fires Input#clock
 * @fires Input#start
 * @fires Input#continue
 * @fires Input#stop
 * @fires Input#activesensing
 * @fires Input#reset
 *
 * @fires Input#unknownmidimessage
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */class If extends te{constructor(t){super(),this._midiInput=t,this._octaveOffset=0,this.channels=[];for(let e=1;e<=16;e++)this.channels[e]=new Mf(this,e);this._forwarders=[],this._midiInput.onstatechange=this._onStateChange.bind(this),this._midiInput.onmidimessage=this._onMidiMessage.bind(this)}async destroy(){this.removeListener(),this.channels.forEach(t=>t.destroy()),this.channels=[],this._forwarders=[],this._midiInput&&(this._midiInput.onstatechange=null,this._midiInput.onmidimessage=null),await this.close(),this._midiInput=null}_onStateChange(t){let e={timestamp:L.time,target:this,port:this};t.port.connection==="open"?(e.type="opened",this.emit("opened",e)):t.port.connection==="closed"&&t.port.state==="connected"?(e.type="closed",this.emit("closed",e)):t.port.connection==="closed"&&t.port.state==="disconnected"?(e.type="disconnected",e.port={connection:t.port.connection,id:t.port.id,manufacturer:t.port.manufacturer,name:t.port.name,state:t.port.state,type:t.port.type},this.emit("disconnected",e)):t.port.connection==="pending"&&t.port.state==="disconnected"||console.warn("This statechange event was not caught: ",t.port.connection,t.port.state)}_onMidiMessage(t){const e=new ja(t.data),n={port:this,target:this,message:e,timestamp:t.timeStamp,type:"midimessage",data:e.data,rawData:e.data,statusByte:e.data[0],dataBytes:e.dataBytes};this.emit("midimessage",n),e.isSystemMessage?this._parseEvent(n):e.isChannelMessage&&this.channels[e.channel]._processMidiMessageEvent(n),this._forwarders.forEach(s=>s.forward(e))}_parseEvent(t){const e=Object.assign({},t);e.type=e.message.type||"unknownmidimessage",e.type==="songselect"&&(e.song=t.data[1]+1,e.value=t.data[1],e.rawValue=e.value),this.emit(e.type,e)}async open(){try{await this._midiInput.open()}catch(t){return Promise.reject(t)}return Promise.resolve(this)}async close(){if(!this._midiInput)return Promise.resolve(this);try{await this._midiInput.close()}catch(t){return Promise.reject(t)}return Promise.resolve(this)}getChannelModeByNumber(){L.validation&&console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class.")}addListener(t,e,n={}){if(L.validation&&typeof n=="function"){let s=e!=null?[].concat(e):void 0;e=n,n={channels:s}}if(I.CHANNEL_EVENTS.includes(t)){n.channels===void 0&&(n.channels=I.MIDI_CHANNEL_NUMBERS);let s=[];return R.sanitizeChannels(n.channels).forEach(r=>{s.push(this.channels[r].addListener(t,e,n))}),s}return super.addListener(t,e,n)}addOneTimeListener(t,e,n={}){return n.remaining=1,this.addListener(t,e,n)}on(t,e,n,s){return this.addListener(t,e,n,s)}hasListener(t,e,n={}){if(L.validation&&typeof n=="function"){let s=[].concat(e);e=n,n={channels:s}}return I.CHANNEL_EVENTS.includes(t)?(n.channels===void 0&&(n.channels=I.MIDI_CHANNEL_NUMBERS),R.sanitizeChannels(n.channels).every(s=>this.channels[s].hasListener(t,e))):super.hasListener(t,e)}removeListener(t,e,n={}){if(L.validation&&typeof n=="function"){let s=[].concat(e);e=n,n={channels:s}}if(n.channels===void 0&&(n.channels=I.MIDI_CHANNEL_NUMBERS),t==null)return R.sanitizeChannels(n.channels).forEach(s=>{this.channels[s]&&this.channels[s].removeListener()}),super.removeListener();I.CHANNEL_EVENTS.includes(t)?R.sanitizeChannels(n.channels).forEach(s=>{this.channels[s].removeListener(t,e,n)}):super.removeListener(t,e,n)}addForwarder(t,e={}){let n;return n=t instanceof Sr?t:new Sr(t,e),this._forwarders.push(n),n}removeForwarder(t){this._forwarders=this._forwarders.filter(e=>e!==t)}hasForwarder(t){return this._forwarders.includes(t)}get name(){return this._midiInput.name}get id(){return this._midiInput.id}get connection(){return this._midiInput.connection}get manufacturer(){return this._midiInput.manufacturer}get octaveOffset(){return this._octaveOffset}set octaveOffset(t){if(this.validation&&(t=parseInt(t),isNaN(t)))throw new TypeError("The 'octaveOffset' property must be an integer.");this._octaveOffset=t}get state(){return this._midiInput.state}get type(){return this._midiInput.type}get nrpnEventsEnabled(){return L.validation&&console.warn("The 'nrpnEventsEnabled' property has been moved to the 'InputChannel' class."),!1}}/**
 * The `WebMidi` object makes it easier to work with the low-level Web MIDI API. Basically, it
 * simplifies sending outgoing MIDI messages and reacting to incoming MIDI messages.
 *
 * When using the WebMidi.js library, you should know that the `WebMidi` class has already been
 * instantiated. You cannot instantiate it yourself. If you use the **IIFE** version, you should
 * simply use the global object called `WebMidi`. If you use the **CJS** (CommonJS) or **ESM** (ES6
 * module) version, you get an already-instantiated object when you import the module.
 *
 * @fires WebMidi#connected
 * @fires WebMidi#disabled
 * @fires WebMidi#disconnected
 * @fires WebMidi#enabled
 * @fires WebMidi#error
 * @fires WebMidi#midiaccessgranted
 * @fires WebMidi#portschanged
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */const L=new class extends te{constructor(){super(),this.defaults={note:{attack:R.from7bitToFloat(64),release:R.from7bitToFloat(64),duration:1/0}},this.interface=null,this.validation=!0,this._inputs=[],this._disconnectedInputs=[],this._outputs=[],this._disconnectedOutputs=[],this._stateChangeQueue=[],this._octaveOffset=0}async enable(i={},t=!1){if(R.isNode){try{window.navigator}catch{global.navigator=await Object.getPrototypeOf(async function(){}).constructor(`
        let jzz = await import("jzz");
        return jzz.default;
        `)()}try{}catch{global.performance=await Object.getPrototypeOf(async function(){}).constructor(`
        let perf_hooks = await import("perf_hooks");
        return perf_hooks.performance;
        `)()}}if(this.validation=i.validation!==!1,this.validation&&(typeof i=="function"&&(i={callback:i,sysex:t}),t&&(i.sysex=!0)),this.enabled)return typeof i.callback=="function"&&i.callback(),Promise.resolve();const e={timestamp:this.time,target:this,type:"error",error:void 0},n={timestamp:this.time,target:this,type:"midiaccessgranted"},s={timestamp:this.time,target:this,type:"enabled"};try{typeof i.requestMIDIAccessFunction=="function"?this.interface=await i.requestMIDIAccessFunction({sysex:i.sysex,software:i.software}):this.interface=await navigator.requestMIDIAccess({sysex:i.sysex,software:i.software})}catch(r){return e.error=r,this.emit("error",e),typeof i.callback=="function"&&i.callback(r),Promise.reject(r)}this.emit("midiaccessgranted",n),this.interface.onstatechange=this._onInterfaceStateChange.bind(this);try{await this._updateInputsAndOutputs()}catch(r){return e.error=r,this.emit("error",e),typeof i.callback=="function"&&i.callback(r),Promise.reject(r)}return this.emit("enabled",s),typeof i.callback=="function"&&i.callback(),Promise.resolve(this)}async disable(){return this._destroyInputsAndOutputs().then(()=>{navigator&&typeof navigator.close=="function"&&navigator.close(),this.interface&&(this.interface.onstatechange=void 0),this.interface=null;let i={timestamp:this.time,target:this,type:"disabled"};this.emit("disabled",i),this.removeListener()})}getInputById(i,t={disconnected:!1}){if(this.validation){if(!this.enabled)throw new Error("WebMidi is not enabled.");if(!i)return}if(t.disconnected){for(let e=0;e<this._disconnectedInputs.length;e++)if(this._disconnectedInputs[e].id===i.toString())return this._disconnectedInputs[e]}else for(let e=0;e<this.inputs.length;e++)if(this.inputs[e].id===i.toString())return this.inputs[e]}getInputByName(i,t={disconnected:!1}){if(this.validation){if(!this.enabled)throw new Error("WebMidi is not enabled.");if(!i)return;i=i.toString()}if(t.disconnected){for(let e=0;e<this._disconnectedInputs.length;e++)if(~this._disconnectedInputs[e].name.indexOf(i))return this._disconnectedInputs[e]}else for(let e=0;e<this.inputs.length;e++)if(~this.inputs[e].name.indexOf(i))return this.inputs[e]}getOutputByName(i,t={disconnected:!1}){if(this.validation){if(!this.enabled)throw new Error("WebMidi is not enabled.");if(!i)return;i=i.toString()}if(t.disconnected){for(let e=0;e<this._disconnectedOutputs.length;e++)if(~this._disconnectedOutputs[e].name.indexOf(i))return this._disconnectedOutputs[e]}else for(let e=0;e<this.outputs.length;e++)if(~this.outputs[e].name.indexOf(i))return this.outputs[e]}getOutputById(i,t={disconnected:!1}){if(this.validation){if(!this.enabled)throw new Error("WebMidi is not enabled.");if(!i)return}if(t.disconnected){for(let e=0;e<this._disconnectedOutputs.length;e++)if(this._disconnectedOutputs[e].id===i.toString())return this._disconnectedOutputs[e]}else for(let e=0;e<this.outputs.length;e++)if(this.outputs[e].id===i.toString())return this.outputs[e]}noteNameToNumber(i){return this.validation&&console.warn("The noteNameToNumber() method is deprecated. Use Utilities.toNoteNumber() instead."),R.toNoteNumber(i,this.octaveOffset)}getOctave(i){return this.validation&&(console.warn("The getOctave()is deprecated. Use Utilities.getNoteDetails() instead"),i=parseInt(i)),!isNaN(i)&&i>=0&&i<=127&&R.getNoteDetails(R.offsetNumber(i,this.octaveOffset)).octave}sanitizeChannels(i){return this.validation&&console.warn("The sanitizeChannels() method has been moved to the utilities class."),R.sanitizeChannels(i)}toMIDIChannels(i){return this.validation&&console.warn("The toMIDIChannels() method has been deprecated. Use Utilities.sanitizeChannels() instead."),R.sanitizeChannels(i)}guessNoteNumber(i){return this.validation&&console.warn("The guessNoteNumber() method has been deprecated. Use Utilities.guessNoteNumber() instead."),R.guessNoteNumber(i,this.octaveOffset)}getValidNoteArray(i,t={}){return this.validation&&console.warn("The getValidNoteArray() method has been moved to the Utilities.buildNoteArray()"),R.buildNoteArray(i,t)}convertToTimestamp(i){return this.validation&&console.warn("The convertToTimestamp() method has been moved to Utilities.toTimestamp()."),R.toTimestamp(i)}async _destroyInputsAndOutputs(){let i=[];return this.inputs.forEach(t=>i.push(t.destroy())),this.outputs.forEach(t=>i.push(t.destroy())),Promise.all(i).then(()=>{this._inputs=[],this._outputs=[]})}_onInterfaceStateChange(i){this._updateInputsAndOutputs();let t={timestamp:i.timeStamp,type:i.port.state,target:this};if(i.port.state==="connected"&&i.port.connection==="open"){i.port.type==="output"?t.port=this.getOutputById(i.port.id):i.port.type==="input"&&(t.port=this.getInputById(i.port.id)),this.emit(i.port.state,t);const e=Object.assign({},t);e.type="portschanged",this.emit(e.type,e)}else if(i.port.state==="disconnected"&&i.port.connection==="pending"){i.port.type==="input"?t.port=this.getInputById(i.port.id,{disconnected:!0}):i.port.type==="output"&&(t.port=this.getOutputById(i.port.id,{disconnected:!0})),this.emit(i.port.state,t);const e=Object.assign({},t);e.type="portschanged",this.emit(e.type,e)}}async _updateInputsAndOutputs(){return Promise.all([this._updateInputs(),this._updateOutputs()])}async _updateInputs(){if(!this.interface)return;for(let t=this._inputs.length-1;t>=0;t--){const e=this._inputs[t];Array.from(this.interface.inputs.values()).find(n=>n===e._midiInput)||(this._disconnectedInputs.push(e),this._inputs.splice(t,1))}let i=[];return this.interface.inputs.forEach(t=>{if(!this._inputs.find(e=>e._midiInput===t)){let e=this._disconnectedInputs.find(n=>n._midiInput===t);e||(e=new If(t)),this._inputs.push(e),i.push(e.open())}}),Promise.all(i)}async _updateOutputs(){if(!this.interface)return;for(let t=this._outputs.length-1;t>=0;t--){const e=this._outputs[t];Array.from(this.interface.outputs.values()).find(n=>n===e._midiOutput)||(this._disconnectedOutputs.push(e),this._outputs.splice(t,1))}let i=[];return this.interface.outputs.forEach(t=>{if(!this._outputs.find(e=>e._midiOutput===t)){let e=this._disconnectedOutputs.find(n=>n._midiOutput===t);e||(e=new fi(t)),this._outputs.push(e),i.push(e.open())}}),Promise.all(i)}get enabled(){return this.interface!==null}get inputs(){return this._inputs}get isNode(){return this.validation&&console.warn("WebMidi.isNode has been deprecated. Use Utilities.isNode instead."),R.isNode}get isBrowser(){return this.validation&&console.warn("WebMidi.isBrowser has been deprecated. Use Utilities.isBrowser instead."),R.isBrowser}get octaveOffset(){return this._octaveOffset}set octaveOffset(i){if(this.validation&&(i=parseInt(i),isNaN(i)))throw new TypeError("The 'octaveOffset' property must be an integer.");this._octaveOffset=i}get outputs(){return this._outputs}get supported(){return typeof navigator!="undefined"&&navigator.requestMIDIAccess}get sysexEnabled(){return!(!this.interface||!this.interface.sysexEnabled)}get time(){return performance.now()}get version(){return"3.0.20"}get CHANNEL_EVENTS(){return this.validation&&console.warn("The CHANNEL_EVENTS enum has been moved to Enumerations.CHANNEL_EVENTS."),I.CHANNEL_EVENTS}get MIDI_SYSTEM_MESSAGES(){return this.validation&&console.warn("The MIDI_SYSTEM_MESSAGES enum has been moved to Enumerations.MIDI_SYSTEM_MESSAGES."),I.MIDI_SYSTEM_MESSAGES}get MIDI_CHANNEL_MODE_MESSAGES(){return this.validation&&console.warn("The MIDI_CHANNEL_MODE_MESSAGES enum has been moved to Enumerations.MIDI_CHANNEL_MODE_MESSAGES."),I.MIDI_CHANNEL_MODE_MESSAGES}get MIDI_CONTROL_CHANGE_MESSAGES(){return this.validation&&console.warn("The MIDI_CONTROL_CHANGE_MESSAGES enum has been moved to Enumerations.MIDI_CONTROL_CHANGE_MESSAGES."),I.MIDI_CONTROL_CHANGE_MESSAGES}get MIDI_REGISTERED_PARAMETER(){return this.validation&&console.warn("The MIDI_REGISTERED_PARAMETER enum has been moved to Enumerations.MIDI_REGISTERED_PARAMETERS."),this.MIDI_REGISTERED_PARAMETERS}get NOTES(){return this.validation&&console.warn("The NOTES enum has been deprecated."),["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]}};L.constructor=null;var Nr=globalThis&&globalThis.__awaiter||function(i,t,e,n){function s(r){return r instanceof e?r:new e(function(a){a(r)})}return new(e||(e=Promise))(function(r,a){function o(u){try{l(n.next(u))}catch(h){a(h)}}function c(u){try{l(n.throw(u))}catch(h){a(h)}}function l(u){u.done?r(u.value):s(u.value).then(o,c)}l((n=n.apply(i,t||[])).next())})};class Gt extends ji.exports.EventEmitter{constructor(t="all"){super(),this.deviceId=t,Gt.enabled().then(()=>{L.addListener("connected",e=>{e.port.type==="input"&&this._addListeners(e.port)}),L.addListener("disconnected",e=>{this._removeListeners(e.port)}),L.inputs.forEach(e=>this._addListeners(e))})}_addListeners(t){Gt.connectedDevices.has(t.id)||(Gt.connectedDevices.set(t.id,t),this.emit("connect",this._inputToDevice(t)),t.addListener("noteon","all",e=>{(this.deviceId==="all"||this.deviceId===t.id)&&this.emit("keyDown",{note:`${e.note.name}${e.note.octave}`,midi:e.note.number,velocity:e.velocity,device:this._inputToDevice(t)})}),t.addListener("noteoff","all",e=>{(this.deviceId==="all"||this.deviceId===t.id)&&this.emit("keyUp",{note:`${e.note.name}${e.note.octave}`,midi:e.note.number,velocity:e.velocity,device:this._inputToDevice(t)})}),t.addListener("controlchange","all",e=>{(this.deviceId==="all"||this.deviceId===t.id)&&e.controller.name==="holdpedal"&&this.emit(e.value?"pedalDown":"pedalUp",{device:this._inputToDevice(t)})}))}_inputToDevice(t){return{name:t.name,id:t.id,manufacturer:t.manufacturer}}_removeListeners(t){if(Gt.connectedDevices.has(t.id)){const e=Gt.connectedDevices.get(t.id);this.emit("disconnect",this._inputToDevice(e)),Gt.connectedDevices.delete(t.id),e.removeListener("noteon"),e.removeListener("noteoff"),e.removeListener("controlchange")}}emit(t,e){return super.emit(t,e)}on(t,e){return super.on(t,e),this}once(t,e){return super.once(t,e),this}off(t,e){return super.off(t,e),this}static enabled(){return Nr(this,void 0,void 0,function*(){Gt._isEnabled||(yield new Promise((t,e)=>{L.enable(n=>{n?e(n):(Gt._isEnabled=!0,t())})}))})}static getDevices(){return Nr(this,void 0,void 0,function*(){return yield Gt.enabled(),L.inputs})}}Gt.connectedDevices=new Map;Gt._isEnabled=!1;class Of extends Q{constructor(){super();E(this,"lights",[]);this.entityData.set("isBaseEntity",!0)}setup(e){super.setup(e);const n=s=>{s.childEntities.forEach(r=>n(r)),s.entityData.get("isLight")&&this.lights.push(s)};n(this)}getLightPositions(){return new Float32Array(this.lights.flatMap(e=>e.lightPosition.xyz))}getLightColors(){return new Float32Array(this.lights.flatMap(e=>e.lightColor.xyz))}getLightInfos(){return new Float32Array(this.lights.flatMap(e=>e.lightInfo.xyzw))}}const on=(i,t)=>{const e=i.updateEntity;return i.updateEntity=n=>{t(i,Xe().currentTime,n),e.call(i,n)},i},pi=({axis:i=x.up,speed:t=1}={})=>(e,n,s)=>{e.transform.rotate(ce.fromAxisAngle(i,t*s))};class Ks extends Q{constructor(e=new x([1,1,1])){super();E(this,"_color",null);this._color=e.copy(),this.entityData.set("isLight",!0)}get lightType(){throw new Error("Not implemented")}get lightPosition(){return this.globalTransform.multiplyPt3(new x([0,0,0]))}get lightColor(){return tt(this._color)}get lightInfo(){throw new Error("Not implemented")}getNumTextures(){return 0}getNumCubeTextures(){return 0}}E(Ks,"DEPTH_TEXTURE_SIZE",256);class Sn extends Ks{get lightType(){return"ambient"}get lightInfo(){return new Ne([1,0,0,0])}}class Nn extends Ks{constructor({direction:e=new x([0,-1,0]),intensity:n=1,color:s=new x([1,1,1])}={}){super(s.copy().scale(n));E(this,"_direction",null);this._direction=e.copy(),this._direction.normalize()}get lightType(){return"directional"}get lightInfo(){const e=this.globalTransform.multiplyVec3(tt(this._direction));return new Ne([2,...e.xyz])}getNumTextures(){return 1}}class Ae extends Ks{constructor({radius:e=5,intensity:n=2,color:s=new x([1,1,1])}={}){super(s);E(this,"_attenuation",null);this._attenuation=new x([1,2/e,1/(e*e)]).scale(1/n)}get lightType(){return"point"}get lightInfo(){return new Ne([3,...tt(this._attenuation).xyz])}}const kf=()=>{const i=new Q,t=_t("cube");t.transform.position=new x([0,1,-1]),t.transform.scale=x.one.copy().scale(.5),st(t,[1,1,1,1]),Mt(t,"lighting"),on(t,pi()),i.addChildEntity(t);const e=_t("cube");e.transform.scale=new x([100,1,100]),e.transform.position=new x([0,-.5,0]),st(e,[.8,.8,.8,1]),Mt(e,"lighting"),i.addChildEntity(e),i.addChildEntity(new Sn(new x([1,1,1]).scale(.1)));const n=new Ae({color:new x([1,0,0])});n.transform.position=new x([4,5,4]),on(n,(o,c,l)=>{const u=Math.sin(c/2)*2;o.transform.position=new x([u*4,5,u*4])}),i.addChildEntity(n);const s=new Ae({color:new x([0,0,1])});s.transform.position=new x([-4,5,4]),on(s,(o,c,l)=>{const u=Math.sin(c/2)*2;o.transform.position=new x([u*-4,5,u*4])}),i.addChildEntity(s);const r=new Ae({color:new x([0,1,0])});r.transform.position=new x([0,5,-3]),on(r,(o,c,l)=>{const u=Math.sin(c/2)*2;o.transform.position=new x([0,5,u*-4])}),i.addChildEntity(r);const a=new Nn({direction:new x([-1,-1,1]),intensity:.2});return i.addChildEntity(a),i};var Df={name:"lights",displayName:"Colored Lights Demo",load:kf};class Rf extends Q{constructor(){super();E(this,"handNames",["left","right"]);E(this,"handPoses",[new Float32Array(16*25),new Float32Array(16*25)]);E(this,"handRadii",[new Float32Array(25),new Float32Array(25)]);E(this,"handJoints",[[],[]]);E(this,"handBones",[[],[]]);for(let e=0;e<2;e++){for(let n=0;n<25;n++){const s=_t("cube");s.entityData.set("hand",this.handNames[e]),s.entityData.set("joint",Jt[n]),st(s,[.7,.7,1,1]),Mt(s,"lighting"),this.handJoints[e][n]=s,this.addChildEntity(s)}for(let n=0;n<24;n++){const s=_t("cube");st(s,[1,.7,.7,1]),Mt(s,"lighting"),this.handBones[e][n]=s,this.addChildEntity(s)}}}updateEntity(e){this.updateHands(),super.updateEntity(e)}updateHands(){const e=Xe(),n=tt(e.frame);for(const s of e.xrsession.inputSources)if(s.hand){const r=s.hand,a=this.handNames.indexOf(s.handedness);if(a===-1)throw new Error(`Unrecognized handedness: ${s.handedness}`);n.fillPoses(r.values(),e.referenceSpace,this.handPoses[a]),n.fillJointRadii(r.values(),this.handRadii[a]);for(let c=0;c<25;c++){const l=this.handJoints[a][c],u=new _e;l.transform=u,u.applyScale(x.one.copy().scale(this.handRadii[a][c]*1.2)),u.applyTransform(new lt(Array.from(this.handPoses[a].subarray(c*16,c*16+16))))}const o=[];for(let c=0;c<5;c++)for(let l=0;l<4;l++)o.push([c*5+l,c*5+l+1]);for(let c=1;c<=4;c++)o.push([0,c*5]);o.forEach((c,l)=>{const u=c[0],h=c[1],d=this.handBones[a][l],f=Array.from(this.handPoses[a].subarray(u*16,u*16+16)),p=Array.from(this.handPoses[a].subarray(h*16,h*16+16)),g=new lt(f),m=new lt(p),_=g.multiplyPt3(x.zero),v=m.multiplyPt3(x.zero),S=mi(x.up,v.copy().subtract(_)),A=_.copy().add(v).scale(.5),w=new _e;d.transform=w;const b=x.distance(_,v),y=this.handRadii[a][u];w.applyScale(new x([y,b,y])),w.rotate(S),w.translate(A)})}else throw new Error("No hands :(")}}const Pf=()=>{const i=new Q,t=_t("cube");t.transform.scale=new x([100,1,100]),t.transform.position=new x([0,-.5,0]),st(t,[.8,.8,.8,1]),Mt(t,"lighting"),i.addChildEntity(t),i.addChildEntity(new Sn(new x([1,1,1]).scale(.1)));const e=new Ae({color:new x([1,1,1])});e.transform.position=new x([0,5,0]),i.addChildEntity(e);const n=new Nn({direction:new x([-1,-1,1]),intensity:.5});return i.addChildEntity(n),i.addChildEntity(new Rf),i};var Lf={name:"oldhands",displayName:"Hands Demo 1",load:Pf};const Ff=()=>{const i=new Q,t=_t("cube");t.transform.scale=new x([100,1,100]),t.transform.position=new x([0,-.5,0]),st(t,[.8,.8,.8,1]),Mt(t,"lighting"),i.addChildEntity(t),i.addChildEntity(new Sn(new x([1,1,1]).scale(.1)));const e=new Ae({color:new x([1,1,1])});e.transform.position=new x([0,5,0]),i.addChildEntity(e);const n=new Nn({direction:new x([-1,-1,1]),intensity:.5});return i.addChildEntity(n),i.addChildEntity(new Le),i};var Vf={name:"hands",displayName:"Hands Demo 2",load:Ff};class Bf extends Q{constructor(e){super();E(this,"handNames",["left","right"]);E(this,"handPoses",new Float32Array(16*25));E(this,"handRadii",new Float32Array(25));E(this,"handJoints",[]);E(this,"handBones",[]);E(this,"hand");this.hand=e;for(let n=0;n<25;n++){const s=_t("sphere",{segments:1});s.entityData.set("hand",this.handNames[this.hand]),s.entityData.set("joint",Jt[n]),s.transform.scale=x.zero.copy(),st(s,[1,.7,.7,1]),Mt(s,"lighting"),this.handJoints[n]=s,this.addChildEntity(s)}for(let n=0;n<24;n++){const s=_t("cylinder",{radius:.7,height:1,segments:10});s.transform.scale=x.zero.copy(),st(s,[.7,.7,1,1]),Mt(s,"lighting"),this.handBones[n]=s,this.addChildEntity(s)}}updateHand(){const e=Xe(),n=tt(e.frame);for(const s of e.xrsession.inputSources)if(s.hand){const r=s.hand,a=this.handNames.indexOf(s.handedness);if(a===-1)throw new Error(`Unrecognized handedness: ${s.handedness}`);if(a!=this.hand)continue;n.fillPoses(r.values(),e.referenceSpace,this.handPoses),n.fillJointRadii(r.values(),this.handRadii);for(let c=0;c<25;c++){const l=this.handJoints[c],u=new _e;l.transform=u,u.applyScale(x.one.copy().scale(1.2*this.handRadii[c])),u.applyTransform(new lt(Array.from(this.handPoses.subarray(c*16,c*16+16))))}const o=[];for(let c=0;c<5;c++)for(let l=0;l<4;l++)o.push([c*5+l,c*5+l+1]);for(let c=1;c<=4;c++)o.push([0,c*5]);o.forEach((c,l)=>{const u=c[0],h=c[1],d=this.handBones[l],f=Array.from(this.handPoses.subarray(u*16,u*16+16)),p=Array.from(this.handPoses.subarray(h*16,h*16+16)),g=new lt(f),m=new lt(p),_=g.multiplyPt3(x.zero),v=m.multiplyPt3(x.zero),S=mi(x.up,v.copy().subtract(_)),A=_.copy().add(v).scale(.5),w=new _e;d.transform=w;const b=x.distance(_,v);let y=this.handRadii[u];Jt[u].includes("metacarpal")||Jt[u].includes("wrist")||(y*=1.2),w.applyScale(new x([y,b,y])),w.rotate(S),w.translate(A)})}}getJointPosition(e){const n=Jt.indexOf(e);if(n===-1)throw new Error(`Unknown joint: ${e}`);return new lt(Array.from(this.handPoses.subarray(n*16,n*16+16))).multiplyPt3(x.zero)}}class zf extends Q{constructor(){super();E(this,"hands",[]);for(let e=0;e<12;e++)this.hands[e]=new Bf(e%2),this.addChildEntity(this.hands[e]);for(let e=2;e<12;e++)this.hands[e].transform.applyScale(new x([.5,.5,.5])),this.hands[e].transform.translate(this.hands[e].getJointPosition("wrist").copy())}updateEntity(e){for(let n=0;n<12;n++)this.hands[n].updateHand();for(let n=2;n<12;n++){const s=Math.floor(n/2)*5-1;this.hands[n].transform.position=this.hands[n].getJointPosition(Jt[s]).copy().subtract(this.hands[n].getJointPosition("wrist").copy().scale(.5))}super.updateEntity(e)}}const Uf=()=>{const i=new Q,t=_t("cube");t.transform.scale=new x([100,1,100]),t.transform.position=new x([0,-.5,0]),st(t,[.8,.8,.8,1]),Mt(t,"lighting"),i.addChildEntity(t),i.addChildEntity(new Sn(new x([1,1,1]).scale(.1)));const e=new Ae({color:new x([1,1,1])});e.transform.position=new x([0,5,0]),i.addChildEntity(e);const n=new Nn({direction:new x([-1,-1,1]),intensity:.5});return i.addChildEntity(n),i.addChildEntity(new zf),i};var qf={name:"RecursiveHands",displayName:"Handsy Hands",load:Uf};const Wf=()=>{const i=new Q,t=new Q,e=_t("cube");e.transform.scale=x.one.copy().scale(.5),st(e,[1,1,1,1]),Mt(e,"lighting"),t.addChildEntity(e);const n=_t("sphere");n.useMatrixTransform(),n.transform.translate(new x([1,1,1])),n.transform.applyScale(x.one.copy().scale(.5)),st(n,[1,1,1,1]),Mt(n,"lighting"),e.addChildEntity(n),on(t,pi()),t.transform.applyScale(x.one.copy().scale(.5)),i.addChildEntity(t);const s=_t("sphere",{segments:4});s.transform.position=new x([0,1,-1]),s.transform.scale=x.one.copy().scale(.5),st(s,[1,1,1,1]),Mt(s,"lighting"),on(s,pi()),i.addChildEntity(s),i.addChildEntity(new Sn(new x([1,1,1]).scale(.1)));const r=new Ae({color:new x([1,1,1])});r.transform.position=new x([0,5,0]),i.addChildEntity(r);const a=new Nn({direction:new x([-1,-1,1]),intensity:.5});return i.addChildEntity(a),i};var jf={name:"primitives",displayName:"Primitives Demo",load:Wf};const Gf=()=>{const i=new Q,t=_t("cube");t.transform.scale=new x([100,1,100]),t.transform.position=new x([0,-.5,0]),st(t,[.8,.8,.8,1]),Mt(t,"lighting"),i.addChildEntity(t),i.addChildEntity(new Sn(new x([1,1,1]).scale(.1)));const e=new Ae({color:new x([1,1,1])});e.transform.position=new x([0,5,0]),i.addChildEntity(e);const n=new Nn({direction:new x([-1,-1,1]),intensity:.5});i.addChildEntity(n);const s=new Kt;return s.transform.translate(new x([0,.9,-.5])),i.addChildEntity(s),i.addChildEntity(new Le(!1)),i};var Hf={name:"piano",displayName:"Piano Demo",load:Gf};const Vs=[jf,Df,Lf,Vf,Hf,qf],Ga=i=>tt(Vs.find(t=>t.name===i)),Xi=class{constructor(){E(this,"_gl",null);E(this,"_xrsession",null);E(this,"_frame",null);E(this,"_referenceSpace",null);E(this,"_screenFramebuffer",null);E(this,"_baseEntity",null);E(this,"prevUpdateTime",0);E(this,"currentTime",0)}setup(){const t=Ga(Xi.selectedSceneName),e=this._baseEntity=new Of,n=this.gl;Pe.requestIntIndicesExt(n),Q.extVAO=Pe.requestVAOExt(n),Pe.requestDepthTextureExt(n),e.addChildEntity(t.load()),e.setup(n)}renderXRViewScene(t){this.renderScene(t.projectionMatrix,t.transform.inverse.matrix)}renderScene(t,e){Q.projectionMatrix=t,Q.viewMatrix=e,Q.viewPos=new Float32Array(new lt(Array.from(e)).multiplyPt3(x.zero).xyz),this.baseEntity.render()}update(t){if(this.prevUpdateTime===0){this.prevUpdateTime=t;return}const e=t-this.prevUpdateTime;this.prevUpdateTime=t,this.currentTime=t,this.baseEntity.updateEntity(e)}get gl(){return tt(this._gl)}set gl(t){this._gl=t}get screenFramebuffer(){return tt(this._screenFramebuffer)}set screenFramebuffer(t){this._screenFramebuffer=t}get xrsession(){return tt(this._xrsession)}set xrsession(t){this._xrsession=t}get frame(){return tt(this._frame)}set frame(t){this._frame=t}get referenceSpace(){return tt(this._referenceSpace)}set referenceSpace(t){this._referenceSpace=t}get baseEntity(){return tt(this._baseEntity)}};let fn=Xi;E(fn,"selectedSceneName",Vs[0].name);const Be=i=>tt(document.getElementById(i));window.onload=()=>{Zf()};const fs=window,Gi=Be("startButton"),Yf=async()=>{const i=Be("glCanvas");let t;t=fs.navigator.xr,t||(alert("WebXR not supported, using polyfill"),t=new fs.WebXRPolyfill);const e=t;if(!await e.isSessionSupported("immersive-vr"))throw new Error("No immersive-vr support");const s=await e.requestSession("immersive-vr",{requiredFeatures:["local-floor"],optionalFeatures:["hand-tracking"]});s.addEventListener("end",()=>{Gi.removeAttribute("disabled"),console.log("Session ended"),i.style.display="none"});const r=i.getContext("webgl",{xrCompatible:!0});if(!r)throw new Error("No WebGL support");const a=r;s.updateRenderState({baseLayer:new fs.XRWebGLLayer(s,a),depthFar:100,depthNear:.001});const o=await s.requestReferenceSpace("local-floor"),c=fs.scene=new fn;c.gl=a,c.xrsession=s,c.referenceSpace=o,i.style.display="block",s.requestAnimationFrame($f)},$f=(i,t)=>{try{const e=Xe(),n=e.xrsession.renderState.baseLayer;e.screenFramebuffer=n.framebuffer,e.setup(),e.xrsession.requestAnimationFrame(Ha)}catch(e){Hi(e)}},Ha=(i,t)=>{try{i/=1e3;const e=Xe(),n=e.gl;e.frame=t,i-e.prevUpdateTime>.016&&e.update(i),e.xrsession.requestAnimationFrame(Ha);const s=t.getViewerPose(e.referenceSpace);if(s){const r=e.xrsession.renderState.baseLayer;n.bindFramebuffer(n.FRAMEBUFFER,r.framebuffer),n.clearColor(.8,.8,1,1),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),n.frontFace(n.CCW),n.cullFace(n.BACK);for(const a of s.views){const o=r.getViewport(a);n.viewport(o.x,o.y,o.width,o.height),e.renderXRViewScene(a)}}else console.log("Tracking lost")}catch(e){Hi(e)}},Xf=()=>{Gi.setAttribute("disabled",""),fn.selectedSceneName.includes("piano")&&Vd().then(()=>{Kt.tonejsPiano=new Fs({velocities:5}),Kt.tonejsPiano.toDestination(),Kt.tonejsPiano.load()}),Yf().catch(Hi)},Zf=()=>{const i=Be("demoName"),t=Be("scenesDropdown");t.innerHTML="";for(const e of Vs){const n=document.createElement("a");n.classList.add("sceneDropdownItem","dropdown-item","darkButton"),n.setAttribute("scene",e.name),n.innerHTML=e.displayName,n.addEventListener("click",r=>{const a=Ga(tt(r.currentTarget.getAttribute("scene")));i.innerHTML=a.displayName,fn.selectedSceneName=a.name});const s=document.createElement("li");s.appendChild(n),t.appendChild(s)}i.innerHTML=Vs[0].displayName,Gi.addEventListener("click",Xf),Be("mainContainer").classList.remove("d-none")},Hi=i=>{const t=Xe();console.log(i),Kf(i),t.xrsession.end()},Kf=i=>{const t=Be("statusContainer"),e=Be("statusMessage");t.style.display="block",e.innerHTML+="<br/>"+i};
